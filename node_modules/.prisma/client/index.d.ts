
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model State
 * 
 */
export type State = $Result.DefaultSelection<Prisma.$StatePayload>
/**
 * Model County
 * 
 */
export type County = $Result.DefaultSelection<Prisma.$CountyPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Brewery
 * 
 */
export type Brewery = $Result.DefaultSelection<Prisma.$BreweryPayload>
/**
 * Model Beer
 * 
 */
export type Beer = $Result.DefaultSelection<Prisma.$BeerPayload>
/**
 * Model BreweryBeer
 * 
 */
export type BreweryBeer = $Result.DefaultSelection<Prisma.$BreweryBeerPayload>
/**
 * Model Food
 * 
 */
export type Food = $Result.DefaultSelection<Prisma.$FoodPayload>
/**
 * Model BreweryFood
 * 
 */
export type BreweryFood = $Result.DefaultSelection<Prisma.$BreweryFoodPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model BreweryService
 * 
 */
export type BreweryService = $Result.DefaultSelection<Prisma.$BreweryServicePayload>
/**
 * Model Music
 * 
 */
export type Music = $Result.DefaultSelection<Prisma.$MusicPayload>
/**
 * Model BreweryMusic
 * 
 */
export type BreweryMusic = $Result.DefaultSelection<Prisma.$BreweryMusicPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model BreweryEvent
 * 
 */
export type BreweryEvent = $Result.DefaultSelection<Prisma.$BreweryEventPayload>
/**
 * Model BreweryFeature
 * 
 */
export type BreweryFeature = $Result.DefaultSelection<Prisma.$BreweryFeaturePayload>
/**
 * Model OperatingHours
 * 
 */
export type OperatingHours = $Result.DefaultSelection<Prisma.$OperatingHoursPayload>
/**
 * Model TutorialStepsApp
 * 
 */
export type TutorialStepsApp = $Result.DefaultSelection<Prisma.$TutorialStepsAppPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model Tour
 * 
 */
export type Tour = $Result.DefaultSelection<Prisma.$TourPayload>
/**
 * Model TourBrewery
 * 
 */
export type TourBrewery = $Result.DefaultSelection<Prisma.$TourBreweryPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Recipient
 * 
 */
export type Recipient = $Result.DefaultSelection<Prisma.$RecipientPayload>
/**
 * Model AdType
 * 
 */
export type AdType = $Result.DefaultSelection<Prisma.$AdTypePayload>
/**
 * Model AdRates
 * 
 */
export type AdRates = $Result.DefaultSelection<Prisma.$AdRatesPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Ad
 * 
 */
export type Ad = $Result.DefaultSelection<Prisma.$AdPayload>
/**
 * Model Terms
 * 
 */
export type Terms = $Result.DefaultSelection<Prisma.$TermsPayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  BREWERY_MANAGER: 'BREWERY_MANAGER',
  BREWERY_OWNER: 'BREWERY_OWNER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const TypeText: {
  TERMS_SERVICE: 'TERMS_SERVICE',
  PRIVACY_POLICY: 'PRIVACY_POLICY',
  ABOUT_US: 'ABOUT_US'
};

export type TypeText = (typeof TypeText)[keyof typeof TypeText]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const MediaStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type MediaStatus = (typeof MediaStatus)[keyof typeof MediaStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type TypeText = $Enums.TypeText

export const TypeText: typeof $Enums.TypeText

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type MediaStatus = $Enums.MediaStatus

export const MediaStatus: typeof $Enums.MediaStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<ExtArgs>;

  /**
   * `prisma.county`: Exposes CRUD operations for the **County** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counties
    * const counties = await prisma.county.findMany()
    * ```
    */
  get county(): Prisma.CountyDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.brewery`: Exposes CRUD operations for the **Brewery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Breweries
    * const breweries = await prisma.brewery.findMany()
    * ```
    */
  get brewery(): Prisma.BreweryDelegate<ExtArgs>;

  /**
   * `prisma.beer`: Exposes CRUD operations for the **Beer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beers
    * const beers = await prisma.beer.findMany()
    * ```
    */
  get beer(): Prisma.BeerDelegate<ExtArgs>;

  /**
   * `prisma.breweryBeer`: Exposes CRUD operations for the **BreweryBeer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryBeers
    * const breweryBeers = await prisma.breweryBeer.findMany()
    * ```
    */
  get breweryBeer(): Prisma.BreweryBeerDelegate<ExtArgs>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **Food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.FoodDelegate<ExtArgs>;

  /**
   * `prisma.breweryFood`: Exposes CRUD operations for the **BreweryFood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryFoods
    * const breweryFoods = await prisma.breweryFood.findMany()
    * ```
    */
  get breweryFood(): Prisma.BreweryFoodDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.breweryService`: Exposes CRUD operations for the **BreweryService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryServices
    * const breweryServices = await prisma.breweryService.findMany()
    * ```
    */
  get breweryService(): Prisma.BreweryServiceDelegate<ExtArgs>;

  /**
   * `prisma.music`: Exposes CRUD operations for the **Music** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Music
    * const music = await prisma.music.findMany()
    * ```
    */
  get music(): Prisma.MusicDelegate<ExtArgs>;

  /**
   * `prisma.breweryMusic`: Exposes CRUD operations for the **BreweryMusic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryMusics
    * const breweryMusics = await prisma.breweryMusic.findMany()
    * ```
    */
  get breweryMusic(): Prisma.BreweryMusicDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.breweryEvent`: Exposes CRUD operations for the **BreweryEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryEvents
    * const breweryEvents = await prisma.breweryEvent.findMany()
    * ```
    */
  get breweryEvent(): Prisma.BreweryEventDelegate<ExtArgs>;

  /**
   * `prisma.breweryFeature`: Exposes CRUD operations for the **BreweryFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreweryFeatures
    * const breweryFeatures = await prisma.breweryFeature.findMany()
    * ```
    */
  get breweryFeature(): Prisma.BreweryFeatureDelegate<ExtArgs>;

  /**
   * `prisma.operatingHours`: Exposes CRUD operations for the **OperatingHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperatingHours
    * const operatingHours = await prisma.operatingHours.findMany()
    * ```
    */
  get operatingHours(): Prisma.OperatingHoursDelegate<ExtArgs>;

  /**
   * `prisma.tutorialStepsApp`: Exposes CRUD operations for the **TutorialStepsApp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TutorialStepsApps
    * const tutorialStepsApps = await prisma.tutorialStepsApp.findMany()
    * ```
    */
  get tutorialStepsApp(): Prisma.TutorialStepsAppDelegate<ExtArgs>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<ExtArgs>;

  /**
   * `prisma.tourBrewery`: Exposes CRUD operations for the **TourBrewery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourBreweries
    * const tourBreweries = await prisma.tourBrewery.findMany()
    * ```
    */
  get tourBrewery(): Prisma.TourBreweryDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.recipient`: Exposes CRUD operations for the **Recipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipients
    * const recipients = await prisma.recipient.findMany()
    * ```
    */
  get recipient(): Prisma.RecipientDelegate<ExtArgs>;

  /**
   * `prisma.adType`: Exposes CRUD operations for the **AdType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdTypes
    * const adTypes = await prisma.adType.findMany()
    * ```
    */
  get adType(): Prisma.AdTypeDelegate<ExtArgs>;

  /**
   * `prisma.adRates`: Exposes CRUD operations for the **AdRates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdRates
    * const adRates = await prisma.adRates.findMany()
    * ```
    */
  get adRates(): Prisma.AdRatesDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.ad`: Exposes CRUD operations for the **Ad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ad.findMany()
    * ```
    */
  get ad(): Prisma.AdDelegate<ExtArgs>;

  /**
   * `prisma.terms`: Exposes CRUD operations for the **Terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms
    * const terms = await prisma.terms.findMany()
    * ```
    */
  get terms(): Prisma.TermsDelegate<ExtArgs>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    State: 'State',
    County: 'County',
    City: 'City',
    Location: 'Location',
    Brewery: 'Brewery',
    Beer: 'Beer',
    BreweryBeer: 'BreweryBeer',
    Food: 'Food',
    BreweryFood: 'BreweryFood',
    Service: 'Service',
    BreweryService: 'BreweryService',
    Music: 'Music',
    BreweryMusic: 'BreweryMusic',
    Event: 'Event',
    BreweryEvent: 'BreweryEvent',
    BreweryFeature: 'BreweryFeature',
    OperatingHours: 'OperatingHours',
    TutorialStepsApp: 'TutorialStepsApp',
    Tags: 'Tags',
    Tour: 'Tour',
    TourBrewery: 'TourBrewery',
    Notification: 'Notification',
    Recipient: 'Recipient',
    AdType: 'AdType',
    AdRates: 'AdRates',
    Category: 'Category',
    Ad: 'Ad',
    Terms: 'Terms',
    Feature: 'Feature',
    Media: 'Media'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "state" | "county" | "city" | "location" | "brewery" | "beer" | "breweryBeer" | "food" | "breweryFood" | "service" | "breweryService" | "music" | "breweryMusic" | "event" | "breweryEvent" | "breweryFeature" | "operatingHours" | "tutorialStepsApp" | "tags" | "tour" | "tourBrewery" | "notification" | "recipient" | "adType" | "adRates" | "category" | "ad" | "terms" | "feature" | "media"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      State: {
        payload: Prisma.$StatePayload<ExtArgs>
        fields: Prisma.StateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          findFirst: {
            args: Prisma.StateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          findMany: {
            args: Prisma.StateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>[]
          }
          create: {
            args: Prisma.StateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          createMany: {
            args: Prisma.StateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          update: {
            args: Prisma.StateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          deleteMany: {
            args: Prisma.StateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatePayload>
          }
          aggregate: {
            args: Prisma.StateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateState>
          }
          groupBy: {
            args: Prisma.StateGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StateCountArgs<ExtArgs>
            result: $Utils.Optional<StateCountAggregateOutputType> | number
          }
        }
      }
      County: {
        payload: Prisma.$CountyPayload<ExtArgs>
        fields: Prisma.CountyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          findFirst: {
            args: Prisma.CountyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          findMany: {
            args: Prisma.CountyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>[]
          }
          create: {
            args: Prisma.CountyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          createMany: {
            args: Prisma.CountyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CountyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          update: {
            args: Prisma.CountyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          deleteMany: {
            args: Prisma.CountyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          aggregate: {
            args: Prisma.CountyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounty>
          }
          groupBy: {
            args: Prisma.CountyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CountyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CountyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CountyCountArgs<ExtArgs>
            result: $Utils.Optional<CountyCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Brewery: {
        payload: Prisma.$BreweryPayload<ExtArgs>
        fields: Prisma.BreweryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          findFirst: {
            args: Prisma.BreweryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          findMany: {
            args: Prisma.BreweryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>[]
          }
          create: {
            args: Prisma.BreweryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          createMany: {
            args: Prisma.BreweryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          update: {
            args: Prisma.BreweryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          deleteMany: {
            args: Prisma.BreweryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryPayload>
          }
          aggregate: {
            args: Prisma.BreweryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrewery>
          }
          groupBy: {
            args: Prisma.BreweryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryCountAggregateOutputType> | number
          }
        }
      }
      Beer: {
        payload: Prisma.$BeerPayload<ExtArgs>
        fields: Prisma.BeerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          findFirst: {
            args: Prisma.BeerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          findMany: {
            args: Prisma.BeerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>[]
          }
          create: {
            args: Prisma.BeerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          createMany: {
            args: Prisma.BeerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BeerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          update: {
            args: Prisma.BeerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          deleteMany: {
            args: Prisma.BeerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BeerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeerPayload>
          }
          aggregate: {
            args: Prisma.BeerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeer>
          }
          groupBy: {
            args: Prisma.BeerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BeerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BeerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BeerCountArgs<ExtArgs>
            result: $Utils.Optional<BeerCountAggregateOutputType> | number
          }
        }
      }
      BreweryBeer: {
        payload: Prisma.$BreweryBeerPayload<ExtArgs>
        fields: Prisma.BreweryBeerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryBeerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryBeerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          findFirst: {
            args: Prisma.BreweryBeerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryBeerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          findMany: {
            args: Prisma.BreweryBeerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>[]
          }
          create: {
            args: Prisma.BreweryBeerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          createMany: {
            args: Prisma.BreweryBeerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryBeerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          update: {
            args: Prisma.BreweryBeerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          deleteMany: {
            args: Prisma.BreweryBeerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryBeerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryBeerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryBeerPayload>
          }
          aggregate: {
            args: Prisma.BreweryBeerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryBeer>
          }
          groupBy: {
            args: Prisma.BreweryBeerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryBeerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryBeerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryBeerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryBeerCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryBeerCountAggregateOutputType> | number
          }
        }
      }
      Food: {
        payload: Prisma.$FoodPayload<ExtArgs>
        fields: Prisma.FoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findFirst: {
            args: Prisma.FoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findMany: {
            args: Prisma.FoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          create: {
            args: Prisma.FoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          createMany: {
            args: Prisma.FoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          update: {
            args: Prisma.FoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFood>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FoodFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FoodAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
          }
        }
      }
      BreweryFood: {
        payload: Prisma.$BreweryFoodPayload<ExtArgs>
        fields: Prisma.BreweryFoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryFoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryFoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          findFirst: {
            args: Prisma.BreweryFoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryFoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          findMany: {
            args: Prisma.BreweryFoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>[]
          }
          create: {
            args: Prisma.BreweryFoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          createMany: {
            args: Prisma.BreweryFoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryFoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          update: {
            args: Prisma.BreweryFoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          deleteMany: {
            args: Prisma.BreweryFoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryFoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryFoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFoodPayload>
          }
          aggregate: {
            args: Prisma.BreweryFoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryFood>
          }
          groupBy: {
            args: Prisma.BreweryFoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryFoodGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryFoodFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryFoodAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryFoodCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryFoodCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      BreweryService: {
        payload: Prisma.$BreweryServicePayload<ExtArgs>
        fields: Prisma.BreweryServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          findFirst: {
            args: Prisma.BreweryServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          findMany: {
            args: Prisma.BreweryServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>[]
          }
          create: {
            args: Prisma.BreweryServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          createMany: {
            args: Prisma.BreweryServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          update: {
            args: Prisma.BreweryServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          deleteMany: {
            args: Prisma.BreweryServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryServicePayload>
          }
          aggregate: {
            args: Prisma.BreweryServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryService>
          }
          groupBy: {
            args: Prisma.BreweryServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryServiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryServiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryServiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryServiceCountAggregateOutputType> | number
          }
        }
      }
      Music: {
        payload: Prisma.$MusicPayload<ExtArgs>
        fields: Prisma.MusicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MusicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MusicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          findFirst: {
            args: Prisma.MusicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MusicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          findMany: {
            args: Prisma.MusicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>[]
          }
          create: {
            args: Prisma.MusicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          createMany: {
            args: Prisma.MusicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MusicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          update: {
            args: Prisma.MusicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          deleteMany: {
            args: Prisma.MusicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MusicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MusicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicPayload>
          }
          aggregate: {
            args: Prisma.MusicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMusic>
          }
          groupBy: {
            args: Prisma.MusicGroupByArgs<ExtArgs>
            result: $Utils.Optional<MusicGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MusicFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MusicAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MusicCountArgs<ExtArgs>
            result: $Utils.Optional<MusicCountAggregateOutputType> | number
          }
        }
      }
      BreweryMusic: {
        payload: Prisma.$BreweryMusicPayload<ExtArgs>
        fields: Prisma.BreweryMusicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryMusicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryMusicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          findFirst: {
            args: Prisma.BreweryMusicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryMusicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          findMany: {
            args: Prisma.BreweryMusicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>[]
          }
          create: {
            args: Prisma.BreweryMusicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          createMany: {
            args: Prisma.BreweryMusicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryMusicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          update: {
            args: Prisma.BreweryMusicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          deleteMany: {
            args: Prisma.BreweryMusicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryMusicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryMusicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryMusicPayload>
          }
          aggregate: {
            args: Prisma.BreweryMusicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryMusic>
          }
          groupBy: {
            args: Prisma.BreweryMusicGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryMusicGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryMusicFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryMusicAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryMusicCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryMusicCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      BreweryEvent: {
        payload: Prisma.$BreweryEventPayload<ExtArgs>
        fields: Prisma.BreweryEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          findFirst: {
            args: Prisma.BreweryEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          findMany: {
            args: Prisma.BreweryEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>[]
          }
          create: {
            args: Prisma.BreweryEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          createMany: {
            args: Prisma.BreweryEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          update: {
            args: Prisma.BreweryEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          deleteMany: {
            args: Prisma.BreweryEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryEventPayload>
          }
          aggregate: {
            args: Prisma.BreweryEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryEvent>
          }
          groupBy: {
            args: Prisma.BreweryEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryEventCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryEventCountAggregateOutputType> | number
          }
        }
      }
      BreweryFeature: {
        payload: Prisma.$BreweryFeaturePayload<ExtArgs>
        fields: Prisma.BreweryFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreweryFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreweryFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          findFirst: {
            args: Prisma.BreweryFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreweryFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          findMany: {
            args: Prisma.BreweryFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>[]
          }
          create: {
            args: Prisma.BreweryFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          createMany: {
            args: Prisma.BreweryFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BreweryFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          update: {
            args: Prisma.BreweryFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          deleteMany: {
            args: Prisma.BreweryFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreweryFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreweryFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreweryFeaturePayload>
          }
          aggregate: {
            args: Prisma.BreweryFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreweryFeature>
          }
          groupBy: {
            args: Prisma.BreweryFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreweryFeatureGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BreweryFeatureFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BreweryFeatureAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BreweryFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<BreweryFeatureCountAggregateOutputType> | number
          }
        }
      }
      OperatingHours: {
        payload: Prisma.$OperatingHoursPayload<ExtArgs>
        fields: Prisma.OperatingHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatingHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatingHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          findFirst: {
            args: Prisma.OperatingHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatingHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          findMany: {
            args: Prisma.OperatingHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>[]
          }
          create: {
            args: Prisma.OperatingHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          createMany: {
            args: Prisma.OperatingHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperatingHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          update: {
            args: Prisma.OperatingHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          deleteMany: {
            args: Prisma.OperatingHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatingHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperatingHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHoursPayload>
          }
          aggregate: {
            args: Prisma.OperatingHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatingHours>
          }
          groupBy: {
            args: Prisma.OperatingHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatingHoursGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OperatingHoursFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OperatingHoursAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OperatingHoursCountArgs<ExtArgs>
            result: $Utils.Optional<OperatingHoursCountAggregateOutputType> | number
          }
        }
      }
      TutorialStepsApp: {
        payload: Prisma.$TutorialStepsAppPayload<ExtArgs>
        fields: Prisma.TutorialStepsAppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorialStepsAppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorialStepsAppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          findFirst: {
            args: Prisma.TutorialStepsAppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorialStepsAppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          findMany: {
            args: Prisma.TutorialStepsAppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>[]
          }
          create: {
            args: Prisma.TutorialStepsAppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          createMany: {
            args: Prisma.TutorialStepsAppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TutorialStepsAppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          update: {
            args: Prisma.TutorialStepsAppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          deleteMany: {
            args: Prisma.TutorialStepsAppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutorialStepsAppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TutorialStepsAppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialStepsAppPayload>
          }
          aggregate: {
            args: Prisma.TutorialStepsAppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutorialStepsApp>
          }
          groupBy: {
            args: Prisma.TutorialStepsAppGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorialStepsAppGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TutorialStepsAppFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TutorialStepsAppAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TutorialStepsAppCountArgs<ExtArgs>
            result: $Utils.Optional<TutorialStepsAppCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TagsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TagsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      Tour: {
        payload: Prisma.$TourPayload<ExtArgs>
        fields: Prisma.TourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findFirst: {
            args: Prisma.TourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findMany: {
            args: Prisma.TourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          create: {
            args: Prisma.TourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          createMany: {
            args: Prisma.TourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          update: {
            args: Prisma.TourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          deleteMany: {
            args: Prisma.TourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.TourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TourFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TourAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
      TourBrewery: {
        payload: Prisma.$TourBreweryPayload<ExtArgs>
        fields: Prisma.TourBreweryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourBreweryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourBreweryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          findFirst: {
            args: Prisma.TourBreweryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourBreweryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          findMany: {
            args: Prisma.TourBreweryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>[]
          }
          create: {
            args: Prisma.TourBreweryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          createMany: {
            args: Prisma.TourBreweryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TourBreweryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          update: {
            args: Prisma.TourBreweryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          deleteMany: {
            args: Prisma.TourBreweryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourBreweryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourBreweryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourBreweryPayload>
          }
          aggregate: {
            args: Prisma.TourBreweryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourBrewery>
          }
          groupBy: {
            args: Prisma.TourBreweryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourBreweryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TourBreweryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TourBreweryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TourBreweryCountArgs<ExtArgs>
            result: $Utils.Optional<TourBreweryCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Recipient: {
        payload: Prisma.$RecipientPayload<ExtArgs>
        fields: Prisma.RecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          findFirst: {
            args: Prisma.RecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          findMany: {
            args: Prisma.RecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>[]
          }
          create: {
            args: Prisma.RecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          createMany: {
            args: Prisma.RecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          update: {
            args: Prisma.RecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          deleteMany: {
            args: Prisma.RecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          aggregate: {
            args: Prisma.RecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipient>
          }
          groupBy: {
            args: Prisma.RecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipientGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RecipientFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RecipientAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RecipientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipientCountAggregateOutputType> | number
          }
        }
      }
      AdType: {
        payload: Prisma.$AdTypePayload<ExtArgs>
        fields: Prisma.AdTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          findFirst: {
            args: Prisma.AdTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          findMany: {
            args: Prisma.AdTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>[]
          }
          create: {
            args: Prisma.AdTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          createMany: {
            args: Prisma.AdTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          update: {
            args: Prisma.AdTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          deleteMany: {
            args: Prisma.AdTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdTypePayload>
          }
          aggregate: {
            args: Prisma.AdTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdType>
          }
          groupBy: {
            args: Prisma.AdTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdTypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdTypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdTypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AdTypeCountAggregateOutputType> | number
          }
        }
      }
      AdRates: {
        payload: Prisma.$AdRatesPayload<ExtArgs>
        fields: Prisma.AdRatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdRatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdRatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          findFirst: {
            args: Prisma.AdRatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdRatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          findMany: {
            args: Prisma.AdRatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>[]
          }
          create: {
            args: Prisma.AdRatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          createMany: {
            args: Prisma.AdRatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdRatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          update: {
            args: Prisma.AdRatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          deleteMany: {
            args: Prisma.AdRatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdRatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdRatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdRatesPayload>
          }
          aggregate: {
            args: Prisma.AdRatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdRates>
          }
          groupBy: {
            args: Prisma.AdRatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdRatesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdRatesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdRatesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdRatesCountArgs<ExtArgs>
            result: $Utils.Optional<AdRatesCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Ad: {
        payload: Prisma.$AdPayload<ExtArgs>
        fields: Prisma.AdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findFirst: {
            args: Prisma.AdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findMany: {
            args: Prisma.AdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          create: {
            args: Prisma.AdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          createMany: {
            args: Prisma.AdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          update: {
            args: Prisma.AdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          deleteMany: {
            args: Prisma.AdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          aggregate: {
            args: Prisma.AdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAd>
          }
          groupBy: {
            args: Prisma.AdGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdCountArgs<ExtArgs>
            result: $Utils.Optional<AdCountAggregateOutputType> | number
          }
        }
      }
      Terms: {
        payload: Prisma.$TermsPayload<ExtArgs>
        fields: Prisma.TermsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          findFirst: {
            args: Prisma.TermsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          findMany: {
            args: Prisma.TermsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>[]
          }
          create: {
            args: Prisma.TermsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          createMany: {
            args: Prisma.TermsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TermsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          update: {
            args: Prisma.TermsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          deleteMany: {
            args: Prisma.TermsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          aggregate: {
            args: Prisma.TermsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerms>
          }
          groupBy: {
            args: Prisma.TermsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TermsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TermsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TermsCountArgs<ExtArgs>
            result: $Utils.Optional<TermsCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FeatureFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FeatureAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MediaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MediaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedBreweries: number
    managedBreweries: number
    sentNotifications: number
    receivedNotifications: number
    Tour: number
    Ad: number
    Media: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedBreweries?: boolean | UserCountOutputTypeCountOwnedBreweriesArgs
    managedBreweries?: boolean | UserCountOutputTypeCountManagedBreweriesArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    receivedNotifications?: boolean | UserCountOutputTypeCountReceivedNotificationsArgs
    Tour?: boolean | UserCountOutputTypeCountTourArgs
    Ad?: boolean | UserCountOutputTypeCountAdArgs
    Media?: boolean | UserCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type StateCountOutputType
   */

  export type StateCountOutputType = {
    counties: number
    cities: number
    Location: number
    AdRates: number
    Ad: number
  }

  export type StateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counties?: boolean | StateCountOutputTypeCountCountiesArgs
    cities?: boolean | StateCountOutputTypeCountCitiesArgs
    Location?: boolean | StateCountOutputTypeCountLocationArgs
    AdRates?: boolean | StateCountOutputTypeCountAdRatesArgs
    Ad?: boolean | StateCountOutputTypeCountAdArgs
  }

  // Custom InputTypes
  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     */
    select?: StateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountCountiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountAdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdRatesWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountAdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type CountyCountOutputType
   */

  export type CountyCountOutputType = {
    cities: number
    Location: number
  }

  export type CountyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountyCountOutputTypeCountCitiesArgs
    Location?: boolean | CountyCountOutputTypeCountLocationArgs
  }

  // Custom InputTypes
  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyCountOutputType
     */
    select?: CountyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    User: number
    Location: number
    Tour: number
    AdRates: number
    Ad: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | CityCountOutputTypeCountUserArgs
    Location?: boolean | CityCountOutputTypeCountLocationArgs
    Tour?: boolean | CityCountOutputTypeCountTourArgs
    AdRates?: boolean | CityCountOutputTypeCountAdRatesArgs
    Ad?: boolean | CityCountOutputTypeCountAdArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountTourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdRatesWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    Brewery: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Brewery?: boolean | LocationCountOutputTypeCountBreweryArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountBreweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryWhereInput
  }


  /**
   * Count Type BreweryCountOutputType
   */

  export type BreweryCountOutputType = {
    features: number
    beers: number
    foods: number
    services: number
    music: number
    OperatingHours: number
    BreweryEvent: number
    tours: number
    media: number
  }

  export type BreweryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | BreweryCountOutputTypeCountFeaturesArgs
    beers?: boolean | BreweryCountOutputTypeCountBeersArgs
    foods?: boolean | BreweryCountOutputTypeCountFoodsArgs
    services?: boolean | BreweryCountOutputTypeCountServicesArgs
    music?: boolean | BreweryCountOutputTypeCountMusicArgs
    OperatingHours?: boolean | BreweryCountOutputTypeCountOperatingHoursArgs
    BreweryEvent?: boolean | BreweryCountOutputTypeCountBreweryEventArgs
    tours?: boolean | BreweryCountOutputTypeCountToursArgs
    media?: boolean | BreweryCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryCountOutputType
     */
    select?: BreweryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryFeatureWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountBeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryBeerWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountFoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryFoodWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryServiceWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountMusicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryMusicWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountOperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHoursWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountBreweryEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryEventWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountToursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBreweryWhereInput
  }

  /**
   * BreweryCountOutputType without action
   */
  export type BreweryCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type BeerCountOutputType
   */

  export type BeerCountOutputType = {
    breweries: number
  }

  export type BeerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | BeerCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * BeerCountOutputType without action
   */
  export type BeerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeerCountOutputType
     */
    select?: BeerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BeerCountOutputType without action
   */
  export type BeerCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryBeerWhereInput
  }


  /**
   * Count Type FoodCountOutputType
   */

  export type FoodCountOutputType = {
    breweries: number
  }

  export type FoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | FoodCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCountOutputType
     */
    select?: FoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryFoodWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    breweries: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | ServiceCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryServiceWhereInput
  }


  /**
   * Count Type MusicCountOutputType
   */

  export type MusicCountOutputType = {
    breweries: number
  }

  export type MusicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | MusicCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * MusicCountOutputType without action
   */
  export type MusicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicCountOutputType
     */
    select?: MusicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MusicCountOutputType without action
   */
  export type MusicCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryMusicWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    breweries: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | EventCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryEventWhereInput
  }


  /**
   * Count Type TourCountOutputType
   */

  export type TourCountOutputType = {
    breweries: number
  }

  export type TourCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | TourCountOutputTypeCountBreweriesArgs
  }

  // Custom InputTypes
  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBreweryWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    recipients: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | NotificationCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipientWhereInput
  }


  /**
   * Count Type AdTypeCountOutputType
   */

  export type AdTypeCountOutputType = {
    AdRates: number
    Ad: number
  }

  export type AdTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdRates?: boolean | AdTypeCountOutputTypeCountAdRatesArgs
    Ad?: boolean | AdTypeCountOutputTypeCountAdArgs
  }

  // Custom InputTypes
  /**
   * AdTypeCountOutputType without action
   */
  export type AdTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdTypeCountOutputType
     */
    select?: AdTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdTypeCountOutputType without action
   */
  export type AdTypeCountOutputTypeCountAdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdRatesWhereInput
  }

  /**
   * AdTypeCountOutputType without action
   */
  export type AdTypeCountOutputTypeCountAdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    Ad: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ad?: boolean | CategoryCountOutputTypeCountAdArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountAdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    current_password: string | null
    birthdate: string | null
    phone_number: string | null
    role: $Enums.Role | null
    state: $Enums.Status | null
    photo: string | null
    cityId: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    current_password: string | null
    birthdate: string | null
    phone_number: string | null
    role: $Enums.Role | null
    state: $Enums.Status | null
    photo: string | null
    cityId: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    current_password: number
    birthdate: number
    phone_number: number
    role: number
    state: number
    photo: number
    cityId: number
    created_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    current_password?: true
    birthdate?: true
    phone_number?: true
    role?: true
    state?: true
    photo?: true
    cityId?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    current_password?: true
    birthdate?: true
    phone_number?: true
    role?: true
    state?: true
    photo?: true
    cityId?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    current_password?: true
    birthdate?: true
    phone_number?: true
    role?: true
    state?: true
    photo?: true
    cityId?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstname: string | null
    lastname: string | null
    email: string
    current_password: string | null
    birthdate: string | null
    phone_number: string | null
    role: $Enums.Role
    state: $Enums.Status
    photo: string | null
    cityId: string
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    current_password?: boolean
    birthdate?: boolean
    phone_number?: boolean
    role?: boolean
    state?: boolean
    photo?: boolean
    cityId?: boolean
    created_at?: boolean
    ownedBreweries?: boolean | User$ownedBreweriesArgs<ExtArgs>
    managedBreweries?: boolean | User$managedBreweriesArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    Tour?: boolean | User$TourArgs<ExtArgs>
    Ad?: boolean | User$AdArgs<ExtArgs>
    Media?: boolean | User$MediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    current_password?: boolean
    birthdate?: boolean
    phone_number?: boolean
    role?: boolean
    state?: boolean
    photo?: boolean
    cityId?: boolean
    created_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedBreweries?: boolean | User$ownedBreweriesArgs<ExtArgs>
    managedBreweries?: boolean | User$managedBreweriesArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    Tour?: boolean | User$TourArgs<ExtArgs>
    Ad?: boolean | User$AdArgs<ExtArgs>
    Media?: boolean | User$MediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedBreweries: Prisma.$BreweryPayload<ExtArgs>[]
      managedBreweries: Prisma.$BreweryPayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs>
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      receivedNotifications: Prisma.$RecipientPayload<ExtArgs>[]
      Tour: Prisma.$TourPayload<ExtArgs>[]
      Ad: Prisma.$AdPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstname: string | null
      lastname: string | null
      email: string
      current_password: string | null
      birthdate: string | null
      phone_number: string | null
      role: $Enums.Role
      state: $Enums.Status
      photo: string | null
      cityId: string
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedBreweries<T extends User$ownedBreweriesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedBreweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findMany"> | Null>
    managedBreweries<T extends User$managedBreweriesArgs<ExtArgs> = {}>(args?: Subset<T, User$managedBreweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findMany"> | Null>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    receivedNotifications<T extends User$receivedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findMany"> | Null>
    Tour<T extends User$TourArgs<ExtArgs> = {}>(args?: Subset<T, User$TourArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany"> | Null>
    Ad<T extends User$AdArgs<ExtArgs> = {}>(args?: Subset<T, User$AdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    Media<T extends User$MediaArgs<ExtArgs> = {}>(args?: Subset<T, User$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly current_password: FieldRef<"User", 'String'>
    readonly birthdate: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly state: FieldRef<"User", 'Status'>
    readonly photo: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.ownedBreweries
   */
  export type User$ownedBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    where?: BreweryWhereInput
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    cursor?: BreweryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * User.managedBreweries
   */
  export type User$managedBreweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    where?: BreweryWhereInput
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    cursor?: BreweryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.receivedNotifications
   */
  export type User$receivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    where?: RecipientWhereInput
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    cursor?: RecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * User.Tour
   */
  export type User$TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * User.Ad
   */
  export type User$AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * User.Media
   */
  export type User$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model State
   */

  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    name: string | null
    state_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    state_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    name: number
    state_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    id?: true
    name?: true
    state_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    name?: true
    state_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    name?: true
    state_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which State to aggregate.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateWhereInput
    orderBy?: StateOrderByWithAggregationInput | StateOrderByWithAggregationInput[]
    by: StateScalarFieldEnum[] | StateScalarFieldEnum
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }

  export type StateGroupByOutputType = {
    id: string
    name: string
    state_id: string
    createdAt: Date
    updatedAt: Date
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    counties?: boolean | State$countiesArgs<ExtArgs>
    cities?: boolean | State$citiesArgs<ExtArgs>
    Location?: boolean | State$LocationArgs<ExtArgs>
    AdRates?: boolean | State$AdRatesArgs<ExtArgs>
    Ad?: boolean | State$AdArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>


  export type StateSelectScalar = {
    id?: boolean
    name?: boolean
    state_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counties?: boolean | State$countiesArgs<ExtArgs>
    cities?: boolean | State$citiesArgs<ExtArgs>
    Location?: boolean | State$LocationArgs<ExtArgs>
    AdRates?: boolean | State$AdRatesArgs<ExtArgs>
    Ad?: boolean | State$AdArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "State"
    objects: {
      counties: Prisma.$CountyPayload<ExtArgs>[]
      cities: Prisma.$CityPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
      AdRates: Prisma.$AdRatesPayload<ExtArgs>[]
      Ad: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      state_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["state"]>
    composites: {}
  }

  type StateGetPayload<S extends boolean | null | undefined | StateDefaultArgs> = $Result.GetResult<Prisma.$StatePayload, S>

  type StateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface StateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['State'], meta: { name: 'State' } }
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StateFindUniqueArgs>(args: SelectSubset<T, StateFindUniqueArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one State that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(args: SelectSubset<T, StateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StateFindFirstArgs>(args?: SelectSubset<T, StateFindFirstArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first State that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(args?: SelectSubset<T, StateFindFirstOrThrowArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StateFindManyArgs>(args?: SelectSubset<T, StateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
     */
    create<T extends StateCreateArgs>(args: SelectSubset<T, StateCreateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many States.
     * @param {StateCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StateCreateManyArgs>(args?: SelectSubset<T, StateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
     */
    delete<T extends StateDeleteArgs>(args: SelectSubset<T, StateDeleteArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StateUpdateArgs>(args: SelectSubset<T, StateUpdateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StateDeleteManyArgs>(args?: SelectSubset<T, StateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StateUpdateManyArgs>(args: SelectSubset<T, StateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
     */
    upsert<T extends StateUpsertArgs>(args: SelectSubset<T, StateUpsertArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more States that matches the filter.
     * @param {StateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const state = await prisma.state.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: StateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a State.
     * @param {StateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const state = await prisma.state.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): Prisma.PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the State model
   */
  readonly fields: StateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    counties<T extends State$countiesArgs<ExtArgs> = {}>(args?: Subset<T, State$countiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findMany"> | Null>
    cities<T extends State$citiesArgs<ExtArgs> = {}>(args?: Subset<T, State$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany"> | Null>
    Location<T extends State$LocationArgs<ExtArgs> = {}>(args?: Subset<T, State$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    AdRates<T extends State$AdRatesArgs<ExtArgs> = {}>(args?: Subset<T, State$AdRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findMany"> | Null>
    Ad<T extends State$AdArgs<ExtArgs> = {}>(args?: Subset<T, State$AdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the State model
   */ 
  interface StateFieldRefs {
    readonly id: FieldRef<"State", 'String'>
    readonly name: FieldRef<"State", 'String'>
    readonly state_id: FieldRef<"State", 'String'>
    readonly createdAt: FieldRef<"State", 'DateTime'>
    readonly updatedAt: FieldRef<"State", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * State findUnique
   */
  export type StateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findFirst
   */
  export type StateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State findMany
   */
  export type StateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StateOrderByWithRelationInput | StateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * State create
   */
  export type StateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to create a State.
     */
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }

  /**
   * State createMany
   */
  export type StateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many States.
     */
    data: StateCreateManyInput | StateCreateManyInput[]
  }

  /**
   * State update
   */
  export type StateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to update a State.
     */
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State updateMany
   */
  export type StateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update States.
     */
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     */
    where?: StateWhereInput
  }

  /**
   * State upsert
   */
  export type StateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The filter to search for the State to update in case it exists.
     */
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     */
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }

  /**
   * State delete
   */
  export type StateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter which State to delete.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which States to delete
     */
    where?: StateWhereInput
  }

  /**
   * State findRaw
   */
  export type StateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * State aggregateRaw
   */
  export type StateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * State.counties
   */
  export type State$countiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    cursor?: CountyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * State.cities
   */
  export type State$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * State.Location
   */
  export type State$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * State.AdRates
   */
  export type State$AdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    where?: AdRatesWhereInput
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    cursor?: AdRatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * State.Ad
   */
  export type State$AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * State without action
   */
  export type StateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
  }


  /**
   * Model County
   */

  export type AggregateCounty = {
    _count: CountyCountAggregateOutputType | null
    _min: CountyMinAggregateOutputType | null
    _max: CountyMaxAggregateOutputType | null
  }

  export type CountyMinAggregateOutputType = {
    id: string | null
    name: string | null
    county_fips: string | null
    stateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    county_fips: string | null
    stateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountyCountAggregateOutputType = {
    id: number
    name: number
    county_fips: number
    stateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountyMinAggregateInputType = {
    id?: true
    name?: true
    county_fips?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountyMaxAggregateInputType = {
    id?: true
    name?: true
    county_fips?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountyCountAggregateInputType = {
    id?: true
    name?: true
    county_fips?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which County to aggregate.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counties
    **/
    _count?: true | CountyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountyMaxAggregateInputType
  }

  export type GetCountyAggregateType<T extends CountyAggregateArgs> = {
        [P in keyof T & keyof AggregateCounty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounty[P]>
      : GetScalarType<T[P], AggregateCounty[P]>
  }




  export type CountyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyWhereInput
    orderBy?: CountyOrderByWithAggregationInput | CountyOrderByWithAggregationInput[]
    by: CountyScalarFieldEnum[] | CountyScalarFieldEnum
    having?: CountyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountyCountAggregateInputType | true
    _min?: CountyMinAggregateInputType
    _max?: CountyMaxAggregateInputType
  }

  export type CountyGroupByOutputType = {
    id: string
    name: string
    county_fips: string
    stateId: string
    createdAt: Date
    updatedAt: Date
    _count: CountyCountAggregateOutputType | null
    _min: CountyMinAggregateOutputType | null
    _max: CountyMaxAggregateOutputType | null
  }

  type GetCountyGroupByPayload<T extends CountyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountyGroupByOutputType[P]>
            : GetScalarType<T[P], CountyGroupByOutputType[P]>
        }
      >
    >


  export type CountySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    county_fips?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    state?: boolean | StateDefaultArgs<ExtArgs>
    cities?: boolean | County$citiesArgs<ExtArgs>
    Location?: boolean | County$LocationArgs<ExtArgs>
    _count?: boolean | CountyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["county"]>


  export type CountySelectScalar = {
    id?: boolean
    name?: boolean
    county_fips?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | StateDefaultArgs<ExtArgs>
    cities?: boolean | County$citiesArgs<ExtArgs>
    Location?: boolean | County$LocationArgs<ExtArgs>
    _count?: boolean | CountyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CountyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "County"
    objects: {
      state: Prisma.$StatePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      county_fips: string
      stateId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["county"]>
    composites: {}
  }

  type CountyGetPayload<S extends boolean | null | undefined | CountyDefaultArgs> = $Result.GetResult<Prisma.$CountyPayload, S>

  type CountyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountyCountAggregateInputType | true
    }

  export interface CountyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['County'], meta: { name: 'County' } }
    /**
     * Find zero or one County that matches the filter.
     * @param {CountyFindUniqueArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountyFindUniqueArgs>(args: SelectSubset<T, CountyFindUniqueArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one County that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountyFindUniqueOrThrowArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountyFindUniqueOrThrowArgs>(args: SelectSubset<T, CountyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first County that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindFirstArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountyFindFirstArgs>(args?: SelectSubset<T, CountyFindFirstArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first County that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindFirstOrThrowArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountyFindFirstOrThrowArgs>(args?: SelectSubset<T, CountyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Counties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counties
     * const counties = await prisma.county.findMany()
     * 
     * // Get first 10 Counties
     * const counties = await prisma.county.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countyWithIdOnly = await prisma.county.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountyFindManyArgs>(args?: SelectSubset<T, CountyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a County.
     * @param {CountyCreateArgs} args - Arguments to create a County.
     * @example
     * // Create one County
     * const County = await prisma.county.create({
     *   data: {
     *     // ... data to create a County
     *   }
     * })
     * 
     */
    create<T extends CountyCreateArgs>(args: SelectSubset<T, CountyCreateArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Counties.
     * @param {CountyCreateManyArgs} args - Arguments to create many Counties.
     * @example
     * // Create many Counties
     * const county = await prisma.county.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountyCreateManyArgs>(args?: SelectSubset<T, CountyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a County.
     * @param {CountyDeleteArgs} args - Arguments to delete one County.
     * @example
     * // Delete one County
     * const County = await prisma.county.delete({
     *   where: {
     *     // ... filter to delete one County
     *   }
     * })
     * 
     */
    delete<T extends CountyDeleteArgs>(args: SelectSubset<T, CountyDeleteArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one County.
     * @param {CountyUpdateArgs} args - Arguments to update one County.
     * @example
     * // Update one County
     * const county = await prisma.county.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountyUpdateArgs>(args: SelectSubset<T, CountyUpdateArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Counties.
     * @param {CountyDeleteManyArgs} args - Arguments to filter Counties to delete.
     * @example
     * // Delete a few Counties
     * const { count } = await prisma.county.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountyDeleteManyArgs>(args?: SelectSubset<T, CountyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counties
     * const county = await prisma.county.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountyUpdateManyArgs>(args: SelectSubset<T, CountyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one County.
     * @param {CountyUpsertArgs} args - Arguments to update or create a County.
     * @example
     * // Update or create a County
     * const county = await prisma.county.upsert({
     *   create: {
     *     // ... data to create a County
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the County we want to update
     *   }
     * })
     */
    upsert<T extends CountyUpsertArgs>(args: SelectSubset<T, CountyUpsertArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Counties that matches the filter.
     * @param {CountyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const county = await prisma.county.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CountyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a County.
     * @param {CountyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const county = await prisma.county.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CountyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyCountArgs} args - Arguments to filter Counties to count.
     * @example
     * // Count the number of Counties
     * const count = await prisma.county.count({
     *   where: {
     *     // ... the filter for the Counties we want to count
     *   }
     * })
    **/
    count<T extends CountyCountArgs>(
      args?: Subset<T, CountyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountyAggregateArgs>(args: Subset<T, CountyAggregateArgs>): Prisma.PrismaPromise<GetCountyAggregateType<T>>

    /**
     * Group by County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountyGroupByArgs['orderBy'] }
        : { orderBy?: CountyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the County model
   */
  readonly fields: CountyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for County.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends StateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StateDefaultArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cities<T extends County$citiesArgs<ExtArgs> = {}>(args?: Subset<T, County$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany"> | Null>
    Location<T extends County$LocationArgs<ExtArgs> = {}>(args?: Subset<T, County$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the County model
   */ 
  interface CountyFieldRefs {
    readonly id: FieldRef<"County", 'String'>
    readonly name: FieldRef<"County", 'String'>
    readonly county_fips: FieldRef<"County", 'String'>
    readonly stateId: FieldRef<"County", 'String'>
    readonly createdAt: FieldRef<"County", 'DateTime'>
    readonly updatedAt: FieldRef<"County", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * County findUnique
   */
  export type CountyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County findUniqueOrThrow
   */
  export type CountyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County findFirst
   */
  export type CountyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counties.
     */
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County findFirstOrThrow
   */
  export type CountyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counties.
     */
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County findMany
   */
  export type CountyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which Counties to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County create
   */
  export type CountyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The data needed to create a County.
     */
    data: XOR<CountyCreateInput, CountyUncheckedCreateInput>
  }

  /**
   * County createMany
   */
  export type CountyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Counties.
     */
    data: CountyCreateManyInput | CountyCreateManyInput[]
  }

  /**
   * County update
   */
  export type CountyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The data needed to update a County.
     */
    data: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
    /**
     * Choose, which County to update.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County updateMany
   */
  export type CountyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Counties.
     */
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyInput>
    /**
     * Filter which Counties to update
     */
    where?: CountyWhereInput
  }

  /**
   * County upsert
   */
  export type CountyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The filter to search for the County to update in case it exists.
     */
    where: CountyWhereUniqueInput
    /**
     * In case the County found by the `where` argument doesn't exist, create a new County with this data.
     */
    create: XOR<CountyCreateInput, CountyUncheckedCreateInput>
    /**
     * In case the County was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
  }

  /**
   * County delete
   */
  export type CountyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter which County to delete.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County deleteMany
   */
  export type CountyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counties to delete
     */
    where?: CountyWhereInput
  }

  /**
   * County findRaw
   */
  export type CountyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * County aggregateRaw
   */
  export type CountyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * County.cities
   */
  export type County$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * County.Location
   */
  export type County$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * County without action
   */
  export type CountyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    population: number | null
    ranking: number | null
  }

  export type CitySumAggregateOutputType = {
    lat: number | null
    lng: number | null
    population: number | null
    ranking: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    city_ascii: string | null
    stateId: string | null
    countyId: string | null
    lat: number | null
    lng: number | null
    population: number | null
    timezone: string | null
    ranking: number | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueCityIdentifier: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city_ascii: string | null
    stateId: string | null
    countyId: string | null
    lat: number | null
    lng: number | null
    population: number | null
    timezone: string | null
    ranking: number | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueCityIdentifier: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    city_ascii: number
    stateId: number
    countyId: number
    lat: number
    lng: number
    population: number
    timezone: number
    ranking: number
    zip: number
    createdAt: number
    updatedAt: number
    uniqueCityIdentifier: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    lat?: true
    lng?: true
    population?: true
    ranking?: true
  }

  export type CitySumAggregateInputType = {
    lat?: true
    lng?: true
    population?: true
    ranking?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    city_ascii?: true
    stateId?: true
    countyId?: true
    lat?: true
    lng?: true
    population?: true
    timezone?: true
    ranking?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    uniqueCityIdentifier?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    city_ascii?: true
    stateId?: true
    countyId?: true
    lat?: true
    lng?: true
    population?: true
    timezone?: true
    ranking?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    uniqueCityIdentifier?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    city_ascii?: true
    stateId?: true
    countyId?: true
    lat?: true
    lng?: true
    population?: true
    timezone?: true
    ranking?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    uniqueCityIdentifier?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    city_ascii: string | null
    stateId: string
    countyId: string
    lat: number | null
    lng: number | null
    population: number | null
    timezone: string | null
    ranking: number | null
    zip: string | null
    createdAt: Date
    updatedAt: Date
    uniqueCityIdentifier: string
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city_ascii?: boolean
    stateId?: boolean
    countyId?: boolean
    lat?: boolean
    lng?: boolean
    population?: boolean
    timezone?: boolean
    ranking?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueCityIdentifier?: boolean
    state?: boolean | StateDefaultArgs<ExtArgs>
    county?: boolean | CountyDefaultArgs<ExtArgs>
    User?: boolean | City$UserArgs<ExtArgs>
    Location?: boolean | City$LocationArgs<ExtArgs>
    Tour?: boolean | City$TourArgs<ExtArgs>
    AdRates?: boolean | City$AdRatesArgs<ExtArgs>
    Ad?: boolean | City$AdArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>


  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    city_ascii?: boolean
    stateId?: boolean
    countyId?: boolean
    lat?: boolean
    lng?: boolean
    population?: boolean
    timezone?: boolean
    ranking?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueCityIdentifier?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | StateDefaultArgs<ExtArgs>
    county?: boolean | CountyDefaultArgs<ExtArgs>
    User?: boolean | City$UserArgs<ExtArgs>
    Location?: boolean | City$LocationArgs<ExtArgs>
    Tour?: boolean | City$TourArgs<ExtArgs>
    AdRates?: boolean | City$AdRatesArgs<ExtArgs>
    Ad?: boolean | City$AdArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      state: Prisma.$StatePayload<ExtArgs>
      county: Prisma.$CountyPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
      Tour: Prisma.$TourPayload<ExtArgs>[]
      AdRates: Prisma.$AdRatesPayload<ExtArgs>[]
      Ad: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      city_ascii: string | null
      stateId: string
      countyId: string
      lat: number | null
      lng: number | null
      population: number | null
      timezone: string | null
      ranking: number | null
      zip: string | null
      createdAt: Date
      updatedAt: Date
      uniqueCityIdentifier: string
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * @param {CityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const city = await prisma.city.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a City.
     * @param {CityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const city = await prisma.city.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends StateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StateDefaultArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    county<T extends CountyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountyDefaultArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends City$UserArgs<ExtArgs> = {}>(args?: Subset<T, City$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    Location<T extends City$LocationArgs<ExtArgs> = {}>(args?: Subset<T, City$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    Tour<T extends City$TourArgs<ExtArgs> = {}>(args?: Subset<T, City$TourArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany"> | Null>
    AdRates<T extends City$AdRatesArgs<ExtArgs> = {}>(args?: Subset<T, City$AdRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findMany"> | Null>
    Ad<T extends City$AdArgs<ExtArgs> = {}>(args?: Subset<T, City$AdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly city_ascii: FieldRef<"City", 'String'>
    readonly stateId: FieldRef<"City", 'String'>
    readonly countyId: FieldRef<"City", 'String'>
    readonly lat: FieldRef<"City", 'Float'>
    readonly lng: FieldRef<"City", 'Float'>
    readonly population: FieldRef<"City", 'Int'>
    readonly timezone: FieldRef<"City", 'String'>
    readonly ranking: FieldRef<"City", 'Int'>
    readonly zip: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
    readonly uniqueCityIdentifier: FieldRef<"City", 'String'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City findRaw
   */
  export type CityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * City aggregateRaw
   */
  export type CityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * City.User
   */
  export type City$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.Location
   */
  export type City$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * City.Tour
   */
  export type City$TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * City.AdRates
   */
  export type City$AdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    where?: AdRatesWhereInput
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    cursor?: AdRatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * City.Ad
   */
  export type City$AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    address: string | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stateId: string | null
    countyId: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    address: string | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stateId: string | null
    countyId: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    address: number
    cityId: number
    latitude: number
    longitude: number
    zip: number
    createdAt: number
    updatedAt: number
    stateId: number
    countyId: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    latitude?: true
    longitude?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    stateId?: true
    countyId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    latitude?: true
    longitude?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    stateId?: true
    countyId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    latitude?: true
    longitude?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    stateId?: true
    countyId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    address: string
    cityId: string
    latitude: number | null
    longitude: number | null
    zip: string | null
    createdAt: Date
    updatedAt: Date
    stateId: string | null
    countyId: string | null
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stateId?: boolean
    countyId?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    Brewery?: boolean | Location$BreweryArgs<ExtArgs>
    State?: boolean | Location$StateArgs<ExtArgs>
    County?: boolean | Location$CountyArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>


  export type LocationSelectScalar = {
    id?: boolean
    address?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stateId?: boolean
    countyId?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    Brewery?: boolean | Location$BreweryArgs<ExtArgs>
    State?: boolean | Location$StateArgs<ExtArgs>
    County?: boolean | Location$CountyArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      Brewery: Prisma.$BreweryPayload<ExtArgs>[]
      State: Prisma.$StatePayload<ExtArgs> | null
      County: Prisma.$CountyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      cityId: string
      latitude: number | null
      longitude: number | null
      zip: string | null
      createdAt: Date
      updatedAt: Date
      stateId: string | null
      countyId: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * @param {LocationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const location = await prisma.location.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LocationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Location.
     * @param {LocationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const location = await prisma.location.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Brewery<T extends Location$BreweryArgs<ExtArgs> = {}>(args?: Subset<T, Location$BreweryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findMany"> | Null>
    State<T extends Location$StateArgs<ExtArgs> = {}>(args?: Subset<T, Location$StateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    County<T extends Location$CountyArgs<ExtArgs> = {}>(args?: Subset<T, Location$CountyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly cityId: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly zip: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly stateId: FieldRef<"Location", 'String'>
    readonly countyId: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location findRaw
   */
  export type LocationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Location aggregateRaw
   */
  export type LocationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Location.Brewery
   */
  export type Location$BreweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    where?: BreweryWhereInput
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    cursor?: BreweryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * Location.State
   */
  export type Location$StateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    where?: StateWhereInput
  }

  /**
   * Location.County
   */
  export type Location$CountyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Brewery
   */

  export type AggregateBrewery = {
    _count: BreweryCountAggregateOutputType | null
    _min: BreweryMinAggregateOutputType | null
    _max: BreweryMaxAggregateOutputType | null
  }

  export type BreweryMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    website: string | null
    ownerId: string | null
    managerId: string | null
    comments: string | null
    merchandise: boolean | null
    social_media: boolean | null
    status: $Enums.Status | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    website: string | null
    ownerId: string | null
    managerId: string | null
    comments: string | null
    merchandise: boolean | null
    social_media: boolean | null
    status: $Enums.Status | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryCountAggregateOutputType = {
    id: number
    name: number
    type: number
    website: number
    ownerId: number
    managerId: number
    comments: number
    merchandise: number
    social_media: number
    status: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    website?: true
    ownerId?: true
    managerId?: true
    comments?: true
    merchandise?: true
    social_media?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    website?: true
    ownerId?: true
    managerId?: true
    comments?: true
    merchandise?: true
    social_media?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    website?: true
    ownerId?: true
    managerId?: true
    comments?: true
    merchandise?: true
    social_media?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brewery to aggregate.
     */
    where?: BreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breweries to fetch.
     */
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Breweries
    **/
    _count?: true | BreweryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryMaxAggregateInputType
  }

  export type GetBreweryAggregateType<T extends BreweryAggregateArgs> = {
        [P in keyof T & keyof AggregateBrewery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrewery[P]>
      : GetScalarType<T[P], AggregateBrewery[P]>
  }




  export type BreweryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryWhereInput
    orderBy?: BreweryOrderByWithAggregationInput | BreweryOrderByWithAggregationInput[]
    by: BreweryScalarFieldEnum[] | BreweryScalarFieldEnum
    having?: BreweryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryCountAggregateInputType | true
    _min?: BreweryMinAggregateInputType
    _max?: BreweryMaxAggregateInputType
  }

  export type BreweryGroupByOutputType = {
    id: string
    name: string
    type: string | null
    website: string | null
    ownerId: string | null
    managerId: string | null
    comments: string | null
    merchandise: boolean | null
    social_media: boolean | null
    status: $Enums.Status
    locationId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryCountAggregateOutputType | null
    _min: BreweryMinAggregateOutputType | null
    _max: BreweryMaxAggregateOutputType | null
  }

  type GetBreweryGroupByPayload<T extends BreweryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryGroupByOutputType[P]>
        }
      >
    >


  export type BrewerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    website?: boolean
    ownerId?: boolean
    managerId?: boolean
    comments?: boolean
    merchandise?: boolean
    social_media?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    owner?: boolean | Brewery$ownerArgs<ExtArgs>
    manager?: boolean | Brewery$managerArgs<ExtArgs>
    features?: boolean | Brewery$featuresArgs<ExtArgs>
    beers?: boolean | Brewery$beersArgs<ExtArgs>
    foods?: boolean | Brewery$foodsArgs<ExtArgs>
    services?: boolean | Brewery$servicesArgs<ExtArgs>
    music?: boolean | Brewery$musicArgs<ExtArgs>
    OperatingHours?: boolean | Brewery$OperatingHoursArgs<ExtArgs>
    BreweryEvent?: boolean | Brewery$BreweryEventArgs<ExtArgs>
    tours?: boolean | Brewery$toursArgs<ExtArgs>
    media?: boolean | Brewery$mediaArgs<ExtArgs>
    _count?: boolean | BreweryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brewery"]>


  export type BrewerySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    website?: boolean
    ownerId?: boolean
    managerId?: boolean
    comments?: boolean
    merchandise?: boolean
    social_media?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    owner?: boolean | Brewery$ownerArgs<ExtArgs>
    manager?: boolean | Brewery$managerArgs<ExtArgs>
    features?: boolean | Brewery$featuresArgs<ExtArgs>
    beers?: boolean | Brewery$beersArgs<ExtArgs>
    foods?: boolean | Brewery$foodsArgs<ExtArgs>
    services?: boolean | Brewery$servicesArgs<ExtArgs>
    music?: boolean | Brewery$musicArgs<ExtArgs>
    OperatingHours?: boolean | Brewery$OperatingHoursArgs<ExtArgs>
    BreweryEvent?: boolean | Brewery$BreweryEventArgs<ExtArgs>
    tours?: boolean | Brewery$toursArgs<ExtArgs>
    media?: boolean | Brewery$mediaArgs<ExtArgs>
    _count?: boolean | BreweryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BreweryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brewery"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      features: Prisma.$BreweryFeaturePayload<ExtArgs>[]
      beers: Prisma.$BreweryBeerPayload<ExtArgs>[]
      foods: Prisma.$BreweryFoodPayload<ExtArgs>[]
      services: Prisma.$BreweryServicePayload<ExtArgs>[]
      music: Prisma.$BreweryMusicPayload<ExtArgs>[]
      OperatingHours: Prisma.$OperatingHoursPayload<ExtArgs>[]
      BreweryEvent: Prisma.$BreweryEventPayload<ExtArgs>[]
      tours: Prisma.$TourBreweryPayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string | null
      website: string | null
      ownerId: string | null
      managerId: string | null
      comments: string | null
      merchandise: boolean | null
      social_media: boolean | null
      status: $Enums.Status
      locationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brewery"]>
    composites: {}
  }

  type BreweryGetPayload<S extends boolean | null | undefined | BreweryDefaultArgs> = $Result.GetResult<Prisma.$BreweryPayload, S>

  type BreweryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryCountAggregateInputType | true
    }

  export interface BreweryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brewery'], meta: { name: 'Brewery' } }
    /**
     * Find zero or one Brewery that matches the filter.
     * @param {BreweryFindUniqueArgs} args - Arguments to find a Brewery
     * @example
     * // Get one Brewery
     * const brewery = await prisma.brewery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryFindUniqueArgs>(args: SelectSubset<T, BreweryFindUniqueArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brewery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryFindUniqueOrThrowArgs} args - Arguments to find a Brewery
     * @example
     * // Get one Brewery
     * const brewery = await prisma.brewery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brewery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFindFirstArgs} args - Arguments to find a Brewery
     * @example
     * // Get one Brewery
     * const brewery = await prisma.brewery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryFindFirstArgs>(args?: SelectSubset<T, BreweryFindFirstArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brewery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFindFirstOrThrowArgs} args - Arguments to find a Brewery
     * @example
     * // Get one Brewery
     * const brewery = await prisma.brewery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Breweries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Breweries
     * const breweries = await prisma.brewery.findMany()
     * 
     * // Get first 10 Breweries
     * const breweries = await prisma.brewery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryWithIdOnly = await prisma.brewery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryFindManyArgs>(args?: SelectSubset<T, BreweryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brewery.
     * @param {BreweryCreateArgs} args - Arguments to create a Brewery.
     * @example
     * // Create one Brewery
     * const Brewery = await prisma.brewery.create({
     *   data: {
     *     // ... data to create a Brewery
     *   }
     * })
     * 
     */
    create<T extends BreweryCreateArgs>(args: SelectSubset<T, BreweryCreateArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Breweries.
     * @param {BreweryCreateManyArgs} args - Arguments to create many Breweries.
     * @example
     * // Create many Breweries
     * const brewery = await prisma.brewery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryCreateManyArgs>(args?: SelectSubset<T, BreweryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brewery.
     * @param {BreweryDeleteArgs} args - Arguments to delete one Brewery.
     * @example
     * // Delete one Brewery
     * const Brewery = await prisma.brewery.delete({
     *   where: {
     *     // ... filter to delete one Brewery
     *   }
     * })
     * 
     */
    delete<T extends BreweryDeleteArgs>(args: SelectSubset<T, BreweryDeleteArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brewery.
     * @param {BreweryUpdateArgs} args - Arguments to update one Brewery.
     * @example
     * // Update one Brewery
     * const brewery = await prisma.brewery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryUpdateArgs>(args: SelectSubset<T, BreweryUpdateArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Breweries.
     * @param {BreweryDeleteManyArgs} args - Arguments to filter Breweries to delete.
     * @example
     * // Delete a few Breweries
     * const { count } = await prisma.brewery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryDeleteManyArgs>(args?: SelectSubset<T, BreweryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Breweries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Breweries
     * const brewery = await prisma.brewery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryUpdateManyArgs>(args: SelectSubset<T, BreweryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brewery.
     * @param {BreweryUpsertArgs} args - Arguments to update or create a Brewery.
     * @example
     * // Update or create a Brewery
     * const brewery = await prisma.brewery.upsert({
     *   create: {
     *     // ... data to create a Brewery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brewery we want to update
     *   }
     * })
     */
    upsert<T extends BreweryUpsertArgs>(args: SelectSubset<T, BreweryUpsertArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Breweries that matches the filter.
     * @param {BreweryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brewery = await prisma.brewery.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brewery.
     * @param {BreweryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brewery = await prisma.brewery.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Breweries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryCountArgs} args - Arguments to filter Breweries to count.
     * @example
     * // Count the number of Breweries
     * const count = await prisma.brewery.count({
     *   where: {
     *     // ... the filter for the Breweries we want to count
     *   }
     * })
    **/
    count<T extends BreweryCountArgs>(
      args?: Subset<T, BreweryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brewery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryAggregateArgs>(args: Subset<T, BreweryAggregateArgs>): Prisma.PrismaPromise<GetBreweryAggregateType<T>>

    /**
     * Group by Brewery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryGroupByArgs['orderBy'] }
        : { orderBy?: BreweryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brewery model
   */
  readonly fields: BreweryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brewery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends Brewery$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    manager<T extends Brewery$managerArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    features<T extends Brewery$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findMany"> | Null>
    beers<T extends Brewery$beersArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$beersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findMany"> | Null>
    foods<T extends Brewery$foodsArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$foodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Brewery$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findMany"> | Null>
    music<T extends Brewery$musicArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$musicArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findMany"> | Null>
    OperatingHours<T extends Brewery$OperatingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$OperatingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findMany"> | Null>
    BreweryEvent<T extends Brewery$BreweryEventArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$BreweryEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findMany"> | Null>
    tours<T extends Brewery$toursArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$toursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findMany"> | Null>
    media<T extends Brewery$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Brewery$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brewery model
   */ 
  interface BreweryFieldRefs {
    readonly id: FieldRef<"Brewery", 'String'>
    readonly name: FieldRef<"Brewery", 'String'>
    readonly type: FieldRef<"Brewery", 'String'>
    readonly website: FieldRef<"Brewery", 'String'>
    readonly ownerId: FieldRef<"Brewery", 'String'>
    readonly managerId: FieldRef<"Brewery", 'String'>
    readonly comments: FieldRef<"Brewery", 'String'>
    readonly merchandise: FieldRef<"Brewery", 'Boolean'>
    readonly social_media: FieldRef<"Brewery", 'Boolean'>
    readonly status: FieldRef<"Brewery", 'Status'>
    readonly locationId: FieldRef<"Brewery", 'String'>
    readonly createdAt: FieldRef<"Brewery", 'DateTime'>
    readonly updatedAt: FieldRef<"Brewery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brewery findUnique
   */
  export type BreweryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter, which Brewery to fetch.
     */
    where: BreweryWhereUniqueInput
  }

  /**
   * Brewery findUniqueOrThrow
   */
  export type BreweryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter, which Brewery to fetch.
     */
    where: BreweryWhereUniqueInput
  }

  /**
   * Brewery findFirst
   */
  export type BreweryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter, which Brewery to fetch.
     */
    where?: BreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breweries to fetch.
     */
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Breweries.
     */
    cursor?: BreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Breweries.
     */
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * Brewery findFirstOrThrow
   */
  export type BreweryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter, which Brewery to fetch.
     */
    where?: BreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breweries to fetch.
     */
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Breweries.
     */
    cursor?: BreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Breweries.
     */
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * Brewery findMany
   */
  export type BreweryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter, which Breweries to fetch.
     */
    where?: BreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breweries to fetch.
     */
    orderBy?: BreweryOrderByWithRelationInput | BreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Breweries.
     */
    cursor?: BreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breweries.
     */
    skip?: number
    distinct?: BreweryScalarFieldEnum | BreweryScalarFieldEnum[]
  }

  /**
   * Brewery create
   */
  export type BreweryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * The data needed to create a Brewery.
     */
    data: XOR<BreweryCreateInput, BreweryUncheckedCreateInput>
  }

  /**
   * Brewery createMany
   */
  export type BreweryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Breweries.
     */
    data: BreweryCreateManyInput | BreweryCreateManyInput[]
  }

  /**
   * Brewery update
   */
  export type BreweryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * The data needed to update a Brewery.
     */
    data: XOR<BreweryUpdateInput, BreweryUncheckedUpdateInput>
    /**
     * Choose, which Brewery to update.
     */
    where: BreweryWhereUniqueInput
  }

  /**
   * Brewery updateMany
   */
  export type BreweryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Breweries.
     */
    data: XOR<BreweryUpdateManyMutationInput, BreweryUncheckedUpdateManyInput>
    /**
     * Filter which Breweries to update
     */
    where?: BreweryWhereInput
  }

  /**
   * Brewery upsert
   */
  export type BreweryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * The filter to search for the Brewery to update in case it exists.
     */
    where: BreweryWhereUniqueInput
    /**
     * In case the Brewery found by the `where` argument doesn't exist, create a new Brewery with this data.
     */
    create: XOR<BreweryCreateInput, BreweryUncheckedCreateInput>
    /**
     * In case the Brewery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryUpdateInput, BreweryUncheckedUpdateInput>
  }

  /**
   * Brewery delete
   */
  export type BreweryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    /**
     * Filter which Brewery to delete.
     */
    where: BreweryWhereUniqueInput
  }

  /**
   * Brewery deleteMany
   */
  export type BreweryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Breweries to delete
     */
    where?: BreweryWhereInput
  }

  /**
   * Brewery findRaw
   */
  export type BreweryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Brewery aggregateRaw
   */
  export type BreweryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Brewery.owner
   */
  export type Brewery$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Brewery.manager
   */
  export type Brewery$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Brewery.features
   */
  export type Brewery$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    where?: BreweryFeatureWhereInput
    orderBy?: BreweryFeatureOrderByWithRelationInput | BreweryFeatureOrderByWithRelationInput[]
    cursor?: BreweryFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryFeatureScalarFieldEnum | BreweryFeatureScalarFieldEnum[]
  }

  /**
   * Brewery.beers
   */
  export type Brewery$beersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    where?: BreweryBeerWhereInput
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    cursor?: BreweryBeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryBeerScalarFieldEnum | BreweryBeerScalarFieldEnum[]
  }

  /**
   * Brewery.foods
   */
  export type Brewery$foodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    where?: BreweryFoodWhereInput
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    cursor?: BreweryFoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryFoodScalarFieldEnum | BreweryFoodScalarFieldEnum[]
  }

  /**
   * Brewery.services
   */
  export type Brewery$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    where?: BreweryServiceWhereInput
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    cursor?: BreweryServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryServiceScalarFieldEnum | BreweryServiceScalarFieldEnum[]
  }

  /**
   * Brewery.music
   */
  export type Brewery$musicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    where?: BreweryMusicWhereInput
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    cursor?: BreweryMusicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryMusicScalarFieldEnum | BreweryMusicScalarFieldEnum[]
  }

  /**
   * Brewery.OperatingHours
   */
  export type Brewery$OperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    where?: OperatingHoursWhereInput
    orderBy?: OperatingHoursOrderByWithRelationInput | OperatingHoursOrderByWithRelationInput[]
    cursor?: OperatingHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatingHoursScalarFieldEnum | OperatingHoursScalarFieldEnum[]
  }

  /**
   * Brewery.BreweryEvent
   */
  export type Brewery$BreweryEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    where?: BreweryEventWhereInput
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    cursor?: BreweryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryEventScalarFieldEnum | BreweryEventScalarFieldEnum[]
  }

  /**
   * Brewery.tours
   */
  export type Brewery$toursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    where?: TourBreweryWhereInput
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    cursor?: TourBreweryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourBreweryScalarFieldEnum | TourBreweryScalarFieldEnum[]
  }

  /**
   * Brewery.media
   */
  export type Brewery$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Brewery without action
   */
  export type BreweryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
  }


  /**
   * Model Beer
   */

  export type AggregateBeer = {
    _count: BeerCountAggregateOutputType | null
    _min: BeerMinAggregateOutputType | null
    _max: BeerMaxAggregateOutputType | null
  }

  export type BeerMinAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeerMaxAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeerCountAggregateOutputType = {
    id: number
    type: number
    brand: number
    name: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BeerMinAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeerMaxAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeerCountAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BeerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beer to aggregate.
     */
    where?: BeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beers to fetch.
     */
    orderBy?: BeerOrderByWithRelationInput | BeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beers
    **/
    _count?: true | BeerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeerMaxAggregateInputType
  }

  export type GetBeerAggregateType<T extends BeerAggregateArgs> = {
        [P in keyof T & keyof AggregateBeer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeer[P]>
      : GetScalarType<T[P], AggregateBeer[P]>
  }




  export type BeerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeerWhereInput
    orderBy?: BeerOrderByWithAggregationInput | BeerOrderByWithAggregationInput[]
    by: BeerScalarFieldEnum[] | BeerScalarFieldEnum
    having?: BeerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeerCountAggregateInputType | true
    _min?: BeerMinAggregateInputType
    _max?: BeerMaxAggregateInputType
  }

  export type BeerGroupByOutputType = {
    id: string
    type: string | null
    brand: string | null
    name: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: BeerCountAggregateOutputType | null
    _min: BeerMinAggregateOutputType | null
    _max: BeerMaxAggregateOutputType | null
  }

  type GetBeerGroupByPayload<T extends BeerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeerGroupByOutputType[P]>
            : GetScalarType<T[P], BeerGroupByOutputType[P]>
        }
      >
    >


  export type BeerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweries?: boolean | Beer$breweriesArgs<ExtArgs>
    _count?: boolean | BeerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beer"]>


  export type BeerSelectScalar = {
    id?: boolean
    type?: boolean
    brand?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BeerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | Beer$breweriesArgs<ExtArgs>
    _count?: boolean | BeerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BeerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Beer"
    objects: {
      breweries: Prisma.$BreweryBeerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string | null
      brand: string | null
      name: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["beer"]>
    composites: {}
  }

  type BeerGetPayload<S extends boolean | null | undefined | BeerDefaultArgs> = $Result.GetResult<Prisma.$BeerPayload, S>

  type BeerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BeerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeerCountAggregateInputType | true
    }

  export interface BeerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Beer'], meta: { name: 'Beer' } }
    /**
     * Find zero or one Beer that matches the filter.
     * @param {BeerFindUniqueArgs} args - Arguments to find a Beer
     * @example
     * // Get one Beer
     * const beer = await prisma.beer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeerFindUniqueArgs>(args: SelectSubset<T, BeerFindUniqueArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Beer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BeerFindUniqueOrThrowArgs} args - Arguments to find a Beer
     * @example
     * // Get one Beer
     * const beer = await prisma.beer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeerFindUniqueOrThrowArgs>(args: SelectSubset<T, BeerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Beer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerFindFirstArgs} args - Arguments to find a Beer
     * @example
     * // Get one Beer
     * const beer = await prisma.beer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeerFindFirstArgs>(args?: SelectSubset<T, BeerFindFirstArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Beer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerFindFirstOrThrowArgs} args - Arguments to find a Beer
     * @example
     * // Get one Beer
     * const beer = await prisma.beer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeerFindFirstOrThrowArgs>(args?: SelectSubset<T, BeerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beers
     * const beers = await prisma.beer.findMany()
     * 
     * // Get first 10 Beers
     * const beers = await prisma.beer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beerWithIdOnly = await prisma.beer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeerFindManyArgs>(args?: SelectSubset<T, BeerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Beer.
     * @param {BeerCreateArgs} args - Arguments to create a Beer.
     * @example
     * // Create one Beer
     * const Beer = await prisma.beer.create({
     *   data: {
     *     // ... data to create a Beer
     *   }
     * })
     * 
     */
    create<T extends BeerCreateArgs>(args: SelectSubset<T, BeerCreateArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beers.
     * @param {BeerCreateManyArgs} args - Arguments to create many Beers.
     * @example
     * // Create many Beers
     * const beer = await prisma.beer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeerCreateManyArgs>(args?: SelectSubset<T, BeerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Beer.
     * @param {BeerDeleteArgs} args - Arguments to delete one Beer.
     * @example
     * // Delete one Beer
     * const Beer = await prisma.beer.delete({
     *   where: {
     *     // ... filter to delete one Beer
     *   }
     * })
     * 
     */
    delete<T extends BeerDeleteArgs>(args: SelectSubset<T, BeerDeleteArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Beer.
     * @param {BeerUpdateArgs} args - Arguments to update one Beer.
     * @example
     * // Update one Beer
     * const beer = await prisma.beer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeerUpdateArgs>(args: SelectSubset<T, BeerUpdateArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beers.
     * @param {BeerDeleteManyArgs} args - Arguments to filter Beers to delete.
     * @example
     * // Delete a few Beers
     * const { count } = await prisma.beer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeerDeleteManyArgs>(args?: SelectSubset<T, BeerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beers
     * const beer = await prisma.beer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeerUpdateManyArgs>(args: SelectSubset<T, BeerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Beer.
     * @param {BeerUpsertArgs} args - Arguments to update or create a Beer.
     * @example
     * // Update or create a Beer
     * const beer = await prisma.beer.upsert({
     *   create: {
     *     // ... data to create a Beer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beer we want to update
     *   }
     * })
     */
    upsert<T extends BeerUpsertArgs>(args: SelectSubset<T, BeerUpsertArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Beers that matches the filter.
     * @param {BeerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const beer = await prisma.beer.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BeerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Beer.
     * @param {BeerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const beer = await prisma.beer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BeerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Beers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerCountArgs} args - Arguments to filter Beers to count.
     * @example
     * // Count the number of Beers
     * const count = await prisma.beer.count({
     *   where: {
     *     // ... the filter for the Beers we want to count
     *   }
     * })
    **/
    count<T extends BeerCountArgs>(
      args?: Subset<T, BeerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeerAggregateArgs>(args: Subset<T, BeerAggregateArgs>): Prisma.PrismaPromise<GetBeerAggregateType<T>>

    /**
     * Group by Beer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeerGroupByArgs['orderBy'] }
        : { orderBy?: BeerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Beer model
   */
  readonly fields: BeerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Beer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breweries<T extends Beer$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Beer$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Beer model
   */ 
  interface BeerFieldRefs {
    readonly id: FieldRef<"Beer", 'String'>
    readonly type: FieldRef<"Beer", 'String'>
    readonly brand: FieldRef<"Beer", 'String'>
    readonly name: FieldRef<"Beer", 'String'>
    readonly image: FieldRef<"Beer", 'String'>
    readonly createdAt: FieldRef<"Beer", 'DateTime'>
    readonly updatedAt: FieldRef<"Beer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Beer findUnique
   */
  export type BeerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter, which Beer to fetch.
     */
    where: BeerWhereUniqueInput
  }

  /**
   * Beer findUniqueOrThrow
   */
  export type BeerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter, which Beer to fetch.
     */
    where: BeerWhereUniqueInput
  }

  /**
   * Beer findFirst
   */
  export type BeerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter, which Beer to fetch.
     */
    where?: BeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beers to fetch.
     */
    orderBy?: BeerOrderByWithRelationInput | BeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beers.
     */
    cursor?: BeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beers.
     */
    distinct?: BeerScalarFieldEnum | BeerScalarFieldEnum[]
  }

  /**
   * Beer findFirstOrThrow
   */
  export type BeerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter, which Beer to fetch.
     */
    where?: BeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beers to fetch.
     */
    orderBy?: BeerOrderByWithRelationInput | BeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beers.
     */
    cursor?: BeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beers.
     */
    distinct?: BeerScalarFieldEnum | BeerScalarFieldEnum[]
  }

  /**
   * Beer findMany
   */
  export type BeerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter, which Beers to fetch.
     */
    where?: BeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beers to fetch.
     */
    orderBy?: BeerOrderByWithRelationInput | BeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beers.
     */
    cursor?: BeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beers.
     */
    skip?: number
    distinct?: BeerScalarFieldEnum | BeerScalarFieldEnum[]
  }

  /**
   * Beer create
   */
  export type BeerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * The data needed to create a Beer.
     */
    data: XOR<BeerCreateInput, BeerUncheckedCreateInput>
  }

  /**
   * Beer createMany
   */
  export type BeerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beers.
     */
    data: BeerCreateManyInput | BeerCreateManyInput[]
  }

  /**
   * Beer update
   */
  export type BeerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * The data needed to update a Beer.
     */
    data: XOR<BeerUpdateInput, BeerUncheckedUpdateInput>
    /**
     * Choose, which Beer to update.
     */
    where: BeerWhereUniqueInput
  }

  /**
   * Beer updateMany
   */
  export type BeerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beers.
     */
    data: XOR<BeerUpdateManyMutationInput, BeerUncheckedUpdateManyInput>
    /**
     * Filter which Beers to update
     */
    where?: BeerWhereInput
  }

  /**
   * Beer upsert
   */
  export type BeerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * The filter to search for the Beer to update in case it exists.
     */
    where: BeerWhereUniqueInput
    /**
     * In case the Beer found by the `where` argument doesn't exist, create a new Beer with this data.
     */
    create: XOR<BeerCreateInput, BeerUncheckedCreateInput>
    /**
     * In case the Beer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeerUpdateInput, BeerUncheckedUpdateInput>
  }

  /**
   * Beer delete
   */
  export type BeerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
    /**
     * Filter which Beer to delete.
     */
    where: BeerWhereUniqueInput
  }

  /**
   * Beer deleteMany
   */
  export type BeerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beers to delete
     */
    where?: BeerWhereInput
  }

  /**
   * Beer findRaw
   */
  export type BeerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Beer aggregateRaw
   */
  export type BeerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Beer.breweries
   */
  export type Beer$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    where?: BreweryBeerWhereInput
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    cursor?: BreweryBeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryBeerScalarFieldEnum | BreweryBeerScalarFieldEnum[]
  }

  /**
   * Beer without action
   */
  export type BeerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beer
     */
    select?: BeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeerInclude<ExtArgs> | null
  }


  /**
   * Model BreweryBeer
   */

  export type AggregateBreweryBeer = {
    _count: BreweryBeerCountAggregateOutputType | null
    _min: BreweryBeerMinAggregateOutputType | null
    _max: BreweryBeerMaxAggregateOutputType | null
  }

  export type BreweryBeerMinAggregateOutputType = {
    id: string | null
    breweryId: string | null
    beerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryBeerMaxAggregateOutputType = {
    id: string | null
    breweryId: string | null
    beerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryBeerCountAggregateOutputType = {
    id: number
    breweryId: number
    beerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryBeerMinAggregateInputType = {
    id?: true
    breweryId?: true
    beerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryBeerMaxAggregateInputType = {
    id?: true
    breweryId?: true
    beerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryBeerCountAggregateInputType = {
    id?: true
    breweryId?: true
    beerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryBeerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryBeer to aggregate.
     */
    where?: BreweryBeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryBeers to fetch.
     */
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryBeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryBeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryBeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryBeers
    **/
    _count?: true | BreweryBeerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryBeerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryBeerMaxAggregateInputType
  }

  export type GetBreweryBeerAggregateType<T extends BreweryBeerAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryBeer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryBeer[P]>
      : GetScalarType<T[P], AggregateBreweryBeer[P]>
  }




  export type BreweryBeerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryBeerWhereInput
    orderBy?: BreweryBeerOrderByWithAggregationInput | BreweryBeerOrderByWithAggregationInput[]
    by: BreweryBeerScalarFieldEnum[] | BreweryBeerScalarFieldEnum
    having?: BreweryBeerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryBeerCountAggregateInputType | true
    _min?: BreweryBeerMinAggregateInputType
    _max?: BreweryBeerMaxAggregateInputType
  }

  export type BreweryBeerGroupByOutputType = {
    id: string
    breweryId: string | null
    beerId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryBeerCountAggregateOutputType | null
    _min: BreweryBeerMinAggregateOutputType | null
    _max: BreweryBeerMaxAggregateOutputType | null
  }

  type GetBreweryBeerGroupByPayload<T extends BreweryBeerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryBeerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryBeerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryBeerGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryBeerGroupByOutputType[P]>
        }
      >
    >


  export type BreweryBeerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breweryId?: boolean
    beerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryBeer$breweryArgs<ExtArgs>
    beer?: boolean | BeerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryBeer"]>


  export type BreweryBeerSelectScalar = {
    id?: boolean
    breweryId?: boolean
    beerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryBeerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryBeer$breweryArgs<ExtArgs>
    beer?: boolean | BeerDefaultArgs<ExtArgs>
  }

  export type $BreweryBeerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryBeer"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs> | null
      beer: Prisma.$BeerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      breweryId: string | null
      beerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryBeer"]>
    composites: {}
  }

  type BreweryBeerGetPayload<S extends boolean | null | undefined | BreweryBeerDefaultArgs> = $Result.GetResult<Prisma.$BreweryBeerPayload, S>

  type BreweryBeerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryBeerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryBeerCountAggregateInputType | true
    }

  export interface BreweryBeerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryBeer'], meta: { name: 'BreweryBeer' } }
    /**
     * Find zero or one BreweryBeer that matches the filter.
     * @param {BreweryBeerFindUniqueArgs} args - Arguments to find a BreweryBeer
     * @example
     * // Get one BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryBeerFindUniqueArgs>(args: SelectSubset<T, BreweryBeerFindUniqueArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryBeer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryBeerFindUniqueOrThrowArgs} args - Arguments to find a BreweryBeer
     * @example
     * // Get one BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryBeerFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryBeerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryBeer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerFindFirstArgs} args - Arguments to find a BreweryBeer
     * @example
     * // Get one BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryBeerFindFirstArgs>(args?: SelectSubset<T, BreweryBeerFindFirstArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryBeer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerFindFirstOrThrowArgs} args - Arguments to find a BreweryBeer
     * @example
     * // Get one BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryBeerFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryBeerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryBeers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryBeers
     * const breweryBeers = await prisma.breweryBeer.findMany()
     * 
     * // Get first 10 BreweryBeers
     * const breweryBeers = await prisma.breweryBeer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryBeerWithIdOnly = await prisma.breweryBeer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryBeerFindManyArgs>(args?: SelectSubset<T, BreweryBeerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryBeer.
     * @param {BreweryBeerCreateArgs} args - Arguments to create a BreweryBeer.
     * @example
     * // Create one BreweryBeer
     * const BreweryBeer = await prisma.breweryBeer.create({
     *   data: {
     *     // ... data to create a BreweryBeer
     *   }
     * })
     * 
     */
    create<T extends BreweryBeerCreateArgs>(args: SelectSubset<T, BreweryBeerCreateArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryBeers.
     * @param {BreweryBeerCreateManyArgs} args - Arguments to create many BreweryBeers.
     * @example
     * // Create many BreweryBeers
     * const breweryBeer = await prisma.breweryBeer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryBeerCreateManyArgs>(args?: SelectSubset<T, BreweryBeerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryBeer.
     * @param {BreweryBeerDeleteArgs} args - Arguments to delete one BreweryBeer.
     * @example
     * // Delete one BreweryBeer
     * const BreweryBeer = await prisma.breweryBeer.delete({
     *   where: {
     *     // ... filter to delete one BreweryBeer
     *   }
     * })
     * 
     */
    delete<T extends BreweryBeerDeleteArgs>(args: SelectSubset<T, BreweryBeerDeleteArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryBeer.
     * @param {BreweryBeerUpdateArgs} args - Arguments to update one BreweryBeer.
     * @example
     * // Update one BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryBeerUpdateArgs>(args: SelectSubset<T, BreweryBeerUpdateArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryBeers.
     * @param {BreweryBeerDeleteManyArgs} args - Arguments to filter BreweryBeers to delete.
     * @example
     * // Delete a few BreweryBeers
     * const { count } = await prisma.breweryBeer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryBeerDeleteManyArgs>(args?: SelectSubset<T, BreweryBeerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryBeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryBeers
     * const breweryBeer = await prisma.breweryBeer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryBeerUpdateManyArgs>(args: SelectSubset<T, BreweryBeerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryBeer.
     * @param {BreweryBeerUpsertArgs} args - Arguments to update or create a BreweryBeer.
     * @example
     * // Update or create a BreweryBeer
     * const breweryBeer = await prisma.breweryBeer.upsert({
     *   create: {
     *     // ... data to create a BreweryBeer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryBeer we want to update
     *   }
     * })
     */
    upsert<T extends BreweryBeerUpsertArgs>(args: SelectSubset<T, BreweryBeerUpsertArgs<ExtArgs>>): Prisma__BreweryBeerClient<$Result.GetResult<Prisma.$BreweryBeerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryBeers that matches the filter.
     * @param {BreweryBeerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryBeer = await prisma.breweryBeer.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryBeerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryBeer.
     * @param {BreweryBeerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryBeer = await prisma.breweryBeer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryBeerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryBeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerCountArgs} args - Arguments to filter BreweryBeers to count.
     * @example
     * // Count the number of BreweryBeers
     * const count = await prisma.breweryBeer.count({
     *   where: {
     *     // ... the filter for the BreweryBeers we want to count
     *   }
     * })
    **/
    count<T extends BreweryBeerCountArgs>(
      args?: Subset<T, BreweryBeerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryBeerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryBeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryBeerAggregateArgs>(args: Subset<T, BreweryBeerAggregateArgs>): Prisma.PrismaPromise<GetBreweryBeerAggregateType<T>>

    /**
     * Group by BreweryBeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryBeerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryBeerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryBeerGroupByArgs['orderBy'] }
        : { orderBy?: BreweryBeerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryBeerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryBeerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryBeer model
   */
  readonly fields: BreweryBeerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryBeer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryBeerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryBeer$breweryArgs<ExtArgs> = {}>(args?: Subset<T, BreweryBeer$breweryArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    beer<T extends BeerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BeerDefaultArgs<ExtArgs>>): Prisma__BeerClient<$Result.GetResult<Prisma.$BeerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryBeer model
   */ 
  interface BreweryBeerFieldRefs {
    readonly id: FieldRef<"BreweryBeer", 'String'>
    readonly breweryId: FieldRef<"BreweryBeer", 'String'>
    readonly beerId: FieldRef<"BreweryBeer", 'String'>
    readonly createdAt: FieldRef<"BreweryBeer", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryBeer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryBeer findUnique
   */
  export type BreweryBeerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter, which BreweryBeer to fetch.
     */
    where: BreweryBeerWhereUniqueInput
  }

  /**
   * BreweryBeer findUniqueOrThrow
   */
  export type BreweryBeerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter, which BreweryBeer to fetch.
     */
    where: BreweryBeerWhereUniqueInput
  }

  /**
   * BreweryBeer findFirst
   */
  export type BreweryBeerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter, which BreweryBeer to fetch.
     */
    where?: BreweryBeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryBeers to fetch.
     */
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryBeers.
     */
    cursor?: BreweryBeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryBeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryBeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryBeers.
     */
    distinct?: BreweryBeerScalarFieldEnum | BreweryBeerScalarFieldEnum[]
  }

  /**
   * BreweryBeer findFirstOrThrow
   */
  export type BreweryBeerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter, which BreweryBeer to fetch.
     */
    where?: BreweryBeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryBeers to fetch.
     */
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryBeers.
     */
    cursor?: BreweryBeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryBeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryBeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryBeers.
     */
    distinct?: BreweryBeerScalarFieldEnum | BreweryBeerScalarFieldEnum[]
  }

  /**
   * BreweryBeer findMany
   */
  export type BreweryBeerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter, which BreweryBeers to fetch.
     */
    where?: BreweryBeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryBeers to fetch.
     */
    orderBy?: BreweryBeerOrderByWithRelationInput | BreweryBeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryBeers.
     */
    cursor?: BreweryBeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryBeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryBeers.
     */
    skip?: number
    distinct?: BreweryBeerScalarFieldEnum | BreweryBeerScalarFieldEnum[]
  }

  /**
   * BreweryBeer create
   */
  export type BreweryBeerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryBeer.
     */
    data: XOR<BreweryBeerCreateInput, BreweryBeerUncheckedCreateInput>
  }

  /**
   * BreweryBeer createMany
   */
  export type BreweryBeerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryBeers.
     */
    data: BreweryBeerCreateManyInput | BreweryBeerCreateManyInput[]
  }

  /**
   * BreweryBeer update
   */
  export type BreweryBeerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryBeer.
     */
    data: XOR<BreweryBeerUpdateInput, BreweryBeerUncheckedUpdateInput>
    /**
     * Choose, which BreweryBeer to update.
     */
    where: BreweryBeerWhereUniqueInput
  }

  /**
   * BreweryBeer updateMany
   */
  export type BreweryBeerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryBeers.
     */
    data: XOR<BreweryBeerUpdateManyMutationInput, BreweryBeerUncheckedUpdateManyInput>
    /**
     * Filter which BreweryBeers to update
     */
    where?: BreweryBeerWhereInput
  }

  /**
   * BreweryBeer upsert
   */
  export type BreweryBeerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryBeer to update in case it exists.
     */
    where: BreweryBeerWhereUniqueInput
    /**
     * In case the BreweryBeer found by the `where` argument doesn't exist, create a new BreweryBeer with this data.
     */
    create: XOR<BreweryBeerCreateInput, BreweryBeerUncheckedCreateInput>
    /**
     * In case the BreweryBeer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryBeerUpdateInput, BreweryBeerUncheckedUpdateInput>
  }

  /**
   * BreweryBeer delete
   */
  export type BreweryBeerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
    /**
     * Filter which BreweryBeer to delete.
     */
    where: BreweryBeerWhereUniqueInput
  }

  /**
   * BreweryBeer deleteMany
   */
  export type BreweryBeerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryBeers to delete
     */
    where?: BreweryBeerWhereInput
  }

  /**
   * BreweryBeer findRaw
   */
  export type BreweryBeerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryBeer aggregateRaw
   */
  export type BreweryBeerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryBeer.brewery
   */
  export type BreweryBeer$breweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    where?: BreweryWhereInput
  }

  /**
   * BreweryBeer without action
   */
  export type BreweryBeerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryBeer
     */
    select?: BreweryBeerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryBeerInclude<ExtArgs> | null
  }


  /**
   * Model Food
   */

  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCountAggregateOutputType = {
    id: number
    name: number
    type: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Food to aggregate.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithAggregationInput | FoodOrderByWithAggregationInput[]
    by: FoodScalarFieldEnum[] | FoodScalarFieldEnum
    having?: FoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }

  export type FoodGroupByOutputType = {
    id: string
    name: string
    type: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodCountAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweries?: boolean | Food$breweriesArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>


  export type FoodSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | Food$breweriesArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Food"
    objects: {
      breweries: Prisma.$BreweryFoodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["food"]>
    composites: {}
  }

  type FoodGetPayload<S extends boolean | null | undefined | FoodDefaultArgs> = $Result.GetResult<Prisma.$FoodPayload, S>

  type FoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface FoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Food'], meta: { name: 'Food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {FoodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodFindUniqueArgs>(args: SelectSubset<T, FoodFindUniqueArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Food that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodFindFirstArgs>(args?: SelectSubset<T, FoodFindFirstArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodWithIdOnly = await prisma.food.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodFindManyArgs>(args?: SelectSubset<T, FoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Food.
     * @param {FoodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
     */
    create<T extends FoodCreateArgs>(args: SelectSubset<T, FoodCreateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Foods.
     * @param {FoodCreateManyArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCreateManyArgs>(args?: SelectSubset<T, FoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Food.
     * @param {FoodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
     */
    delete<T extends FoodDeleteArgs>(args: SelectSubset<T, FoodDeleteArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Food.
     * @param {FoodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodUpdateArgs>(args: SelectSubset<T, FoodUpdateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Foods.
     * @param {FoodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDeleteManyArgs>(args?: SelectSubset<T, FoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodUpdateManyArgs>(args: SelectSubset<T, FoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food.
     * @param {FoodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
     */
    upsert<T extends FoodUpsertArgs>(args: SelectSubset<T, FoodUpsertArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Foods that matches the filter.
     * @param {FoodFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const food = await prisma.food.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FoodFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Food.
     * @param {FoodAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const food = await prisma.food.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FoodAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends FoodCountArgs>(
      args?: Subset<T, FoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Food model
   */
  readonly fields: FoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breweries<T extends Food$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Food$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Food model
   */ 
  interface FoodFieldRefs {
    readonly id: FieldRef<"Food", 'String'>
    readonly name: FieldRef<"Food", 'String'>
    readonly type: FieldRef<"Food", 'String'>
    readonly image: FieldRef<"Food", 'String'>
    readonly createdAt: FieldRef<"Food", 'DateTime'>
    readonly updatedAt: FieldRef<"Food", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Food findUnique
   */
  export type FoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findUniqueOrThrow
   */
  export type FoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findFirst
   */
  export type FoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findFirstOrThrow
   */
  export type FoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findMany
   */
  export type FoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Foods to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food create
   */
  export type FoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Food.
     */
    data: XOR<FoodCreateInput, FoodUncheckedCreateInput>
  }

  /**
   * Food createMany
   */
  export type FoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
  }

  /**
   * Food update
   */
  export type FoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Food.
     */
    data: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
    /**
     * Choose, which Food to update.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food updateMany
   */
  export type FoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
  }

  /**
   * Food upsert
   */
  export type FoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Food to update in case it exists.
     */
    where: FoodWhereUniqueInput
    /**
     * In case the Food found by the `where` argument doesn't exist, create a new Food with this data.
     */
    create: XOR<FoodCreateInput, FoodUncheckedCreateInput>
    /**
     * In case the Food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
  }

  /**
   * Food delete
   */
  export type FoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter which Food to delete.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food deleteMany
   */
  export type FoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foods to delete
     */
    where?: FoodWhereInput
  }

  /**
   * Food findRaw
   */
  export type FoodFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Food aggregateRaw
   */
  export type FoodAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Food.breweries
   */
  export type Food$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    where?: BreweryFoodWhereInput
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    cursor?: BreweryFoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryFoodScalarFieldEnum | BreweryFoodScalarFieldEnum[]
  }

  /**
   * Food without action
   */
  export type FoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
  }


  /**
   * Model BreweryFood
   */

  export type AggregateBreweryFood = {
    _count: BreweryFoodCountAggregateOutputType | null
    _min: BreweryFoodMinAggregateOutputType | null
    _max: BreweryFoodMaxAggregateOutputType | null
  }

  export type BreweryFoodMinAggregateOutputType = {
    id: string | null
    breweryId: string | null
    foodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryFoodMaxAggregateOutputType = {
    id: string | null
    breweryId: string | null
    foodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryFoodCountAggregateOutputType = {
    id: number
    breweryId: number
    foodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryFoodMinAggregateInputType = {
    id?: true
    breweryId?: true
    foodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryFoodMaxAggregateInputType = {
    id?: true
    breweryId?: true
    foodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryFoodCountAggregateInputType = {
    id?: true
    breweryId?: true
    foodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryFoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryFood to aggregate.
     */
    where?: BreweryFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFoods to fetch.
     */
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryFoods
    **/
    _count?: true | BreweryFoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryFoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryFoodMaxAggregateInputType
  }

  export type GetBreweryFoodAggregateType<T extends BreweryFoodAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryFood[P]>
      : GetScalarType<T[P], AggregateBreweryFood[P]>
  }




  export type BreweryFoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryFoodWhereInput
    orderBy?: BreweryFoodOrderByWithAggregationInput | BreweryFoodOrderByWithAggregationInput[]
    by: BreweryFoodScalarFieldEnum[] | BreweryFoodScalarFieldEnum
    having?: BreweryFoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryFoodCountAggregateInputType | true
    _min?: BreweryFoodMinAggregateInputType
    _max?: BreweryFoodMaxAggregateInputType
  }

  export type BreweryFoodGroupByOutputType = {
    id: string
    breweryId: string
    foodId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryFoodCountAggregateOutputType | null
    _min: BreweryFoodMinAggregateOutputType | null
    _max: BreweryFoodMaxAggregateOutputType | null
  }

  type GetBreweryFoodGroupByPayload<T extends BreweryFoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryFoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryFoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryFoodGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryFoodGroupByOutputType[P]>
        }
      >
    >


  export type BreweryFoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breweryId?: boolean
    foodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryFood"]>


  export type BreweryFoodSelectScalar = {
    id?: boolean
    breweryId?: boolean
    foodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryFoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    food?: boolean | FoodDefaultArgs<ExtArgs>
  }

  export type $BreweryFoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryFood"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
      food: Prisma.$FoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      breweryId: string
      foodId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryFood"]>
    composites: {}
  }

  type BreweryFoodGetPayload<S extends boolean | null | undefined | BreweryFoodDefaultArgs> = $Result.GetResult<Prisma.$BreweryFoodPayload, S>

  type BreweryFoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryFoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryFoodCountAggregateInputType | true
    }

  export interface BreweryFoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryFood'], meta: { name: 'BreweryFood' } }
    /**
     * Find zero or one BreweryFood that matches the filter.
     * @param {BreweryFoodFindUniqueArgs} args - Arguments to find a BreweryFood
     * @example
     * // Get one BreweryFood
     * const breweryFood = await prisma.breweryFood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryFoodFindUniqueArgs>(args: SelectSubset<T, BreweryFoodFindUniqueArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryFood that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryFoodFindUniqueOrThrowArgs} args - Arguments to find a BreweryFood
     * @example
     * // Get one BreweryFood
     * const breweryFood = await prisma.breweryFood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryFoodFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryFoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryFood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodFindFirstArgs} args - Arguments to find a BreweryFood
     * @example
     * // Get one BreweryFood
     * const breweryFood = await prisma.breweryFood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryFoodFindFirstArgs>(args?: SelectSubset<T, BreweryFoodFindFirstArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryFood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodFindFirstOrThrowArgs} args - Arguments to find a BreweryFood
     * @example
     * // Get one BreweryFood
     * const breweryFood = await prisma.breweryFood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryFoodFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryFoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryFoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryFoods
     * const breweryFoods = await prisma.breweryFood.findMany()
     * 
     * // Get first 10 BreweryFoods
     * const breweryFoods = await prisma.breweryFood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryFoodWithIdOnly = await prisma.breweryFood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryFoodFindManyArgs>(args?: SelectSubset<T, BreweryFoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryFood.
     * @param {BreweryFoodCreateArgs} args - Arguments to create a BreweryFood.
     * @example
     * // Create one BreweryFood
     * const BreweryFood = await prisma.breweryFood.create({
     *   data: {
     *     // ... data to create a BreweryFood
     *   }
     * })
     * 
     */
    create<T extends BreweryFoodCreateArgs>(args: SelectSubset<T, BreweryFoodCreateArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryFoods.
     * @param {BreweryFoodCreateManyArgs} args - Arguments to create many BreweryFoods.
     * @example
     * // Create many BreweryFoods
     * const breweryFood = await prisma.breweryFood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryFoodCreateManyArgs>(args?: SelectSubset<T, BreweryFoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryFood.
     * @param {BreweryFoodDeleteArgs} args - Arguments to delete one BreweryFood.
     * @example
     * // Delete one BreweryFood
     * const BreweryFood = await prisma.breweryFood.delete({
     *   where: {
     *     // ... filter to delete one BreweryFood
     *   }
     * })
     * 
     */
    delete<T extends BreweryFoodDeleteArgs>(args: SelectSubset<T, BreweryFoodDeleteArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryFood.
     * @param {BreweryFoodUpdateArgs} args - Arguments to update one BreweryFood.
     * @example
     * // Update one BreweryFood
     * const breweryFood = await prisma.breweryFood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryFoodUpdateArgs>(args: SelectSubset<T, BreweryFoodUpdateArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryFoods.
     * @param {BreweryFoodDeleteManyArgs} args - Arguments to filter BreweryFoods to delete.
     * @example
     * // Delete a few BreweryFoods
     * const { count } = await prisma.breweryFood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryFoodDeleteManyArgs>(args?: SelectSubset<T, BreweryFoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryFoods
     * const breweryFood = await prisma.breweryFood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryFoodUpdateManyArgs>(args: SelectSubset<T, BreweryFoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryFood.
     * @param {BreweryFoodUpsertArgs} args - Arguments to update or create a BreweryFood.
     * @example
     * // Update or create a BreweryFood
     * const breweryFood = await prisma.breweryFood.upsert({
     *   create: {
     *     // ... data to create a BreweryFood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryFood we want to update
     *   }
     * })
     */
    upsert<T extends BreweryFoodUpsertArgs>(args: SelectSubset<T, BreweryFoodUpsertArgs<ExtArgs>>): Prisma__BreweryFoodClient<$Result.GetResult<Prisma.$BreweryFoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryFoods that matches the filter.
     * @param {BreweryFoodFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryFood = await prisma.breweryFood.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryFoodFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryFood.
     * @param {BreweryFoodAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryFood = await prisma.breweryFood.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryFoodAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodCountArgs} args - Arguments to filter BreweryFoods to count.
     * @example
     * // Count the number of BreweryFoods
     * const count = await prisma.breweryFood.count({
     *   where: {
     *     // ... the filter for the BreweryFoods we want to count
     *   }
     * })
    **/
    count<T extends BreweryFoodCountArgs>(
      args?: Subset<T, BreweryFoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryFoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryFoodAggregateArgs>(args: Subset<T, BreweryFoodAggregateArgs>): Prisma.PrismaPromise<GetBreweryFoodAggregateType<T>>

    /**
     * Group by BreweryFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryFoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryFoodGroupByArgs['orderBy'] }
        : { orderBy?: BreweryFoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryFoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryFood model
   */
  readonly fields: BreweryFoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryFood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryFoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    food<T extends FoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodDefaultArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryFood model
   */ 
  interface BreweryFoodFieldRefs {
    readonly id: FieldRef<"BreweryFood", 'String'>
    readonly breweryId: FieldRef<"BreweryFood", 'String'>
    readonly foodId: FieldRef<"BreweryFood", 'String'>
    readonly createdAt: FieldRef<"BreweryFood", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryFood", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryFood findUnique
   */
  export type BreweryFoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFood to fetch.
     */
    where: BreweryFoodWhereUniqueInput
  }

  /**
   * BreweryFood findUniqueOrThrow
   */
  export type BreweryFoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFood to fetch.
     */
    where: BreweryFoodWhereUniqueInput
  }

  /**
   * BreweryFood findFirst
   */
  export type BreweryFoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFood to fetch.
     */
    where?: BreweryFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFoods to fetch.
     */
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryFoods.
     */
    cursor?: BreweryFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryFoods.
     */
    distinct?: BreweryFoodScalarFieldEnum | BreweryFoodScalarFieldEnum[]
  }

  /**
   * BreweryFood findFirstOrThrow
   */
  export type BreweryFoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFood to fetch.
     */
    where?: BreweryFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFoods to fetch.
     */
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryFoods.
     */
    cursor?: BreweryFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryFoods.
     */
    distinct?: BreweryFoodScalarFieldEnum | BreweryFoodScalarFieldEnum[]
  }

  /**
   * BreweryFood findMany
   */
  export type BreweryFoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFoods to fetch.
     */
    where?: BreweryFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFoods to fetch.
     */
    orderBy?: BreweryFoodOrderByWithRelationInput | BreweryFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryFoods.
     */
    cursor?: BreweryFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFoods.
     */
    skip?: number
    distinct?: BreweryFoodScalarFieldEnum | BreweryFoodScalarFieldEnum[]
  }

  /**
   * BreweryFood create
   */
  export type BreweryFoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryFood.
     */
    data: XOR<BreweryFoodCreateInput, BreweryFoodUncheckedCreateInput>
  }

  /**
   * BreweryFood createMany
   */
  export type BreweryFoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryFoods.
     */
    data: BreweryFoodCreateManyInput | BreweryFoodCreateManyInput[]
  }

  /**
   * BreweryFood update
   */
  export type BreweryFoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryFood.
     */
    data: XOR<BreweryFoodUpdateInput, BreweryFoodUncheckedUpdateInput>
    /**
     * Choose, which BreweryFood to update.
     */
    where: BreweryFoodWhereUniqueInput
  }

  /**
   * BreweryFood updateMany
   */
  export type BreweryFoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryFoods.
     */
    data: XOR<BreweryFoodUpdateManyMutationInput, BreweryFoodUncheckedUpdateManyInput>
    /**
     * Filter which BreweryFoods to update
     */
    where?: BreweryFoodWhereInput
  }

  /**
   * BreweryFood upsert
   */
  export type BreweryFoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryFood to update in case it exists.
     */
    where: BreweryFoodWhereUniqueInput
    /**
     * In case the BreweryFood found by the `where` argument doesn't exist, create a new BreweryFood with this data.
     */
    create: XOR<BreweryFoodCreateInput, BreweryFoodUncheckedCreateInput>
    /**
     * In case the BreweryFood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryFoodUpdateInput, BreweryFoodUncheckedUpdateInput>
  }

  /**
   * BreweryFood delete
   */
  export type BreweryFoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
    /**
     * Filter which BreweryFood to delete.
     */
    where: BreweryFoodWhereUniqueInput
  }

  /**
   * BreweryFood deleteMany
   */
  export type BreweryFoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryFoods to delete
     */
    where?: BreweryFoodWhereInput
  }

  /**
   * BreweryFood findRaw
   */
  export type BreweryFoodFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryFood aggregateRaw
   */
  export type BreweryFoodAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryFood without action
   */
  export type BreweryFoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFood
     */
    select?: BreweryFoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFoodInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweries?: boolean | Service$breweriesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>


  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | Service$breweriesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      breweries: Prisma.$BreweryServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * @param {ServiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const service = await prisma.service.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ServiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Service.
     * @param {ServiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const service = await prisma.service.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breweries<T extends Service$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Service$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly image: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service findRaw
   */
  export type ServiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service aggregateRaw
   */
  export type ServiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service.breweries
   */
  export type Service$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    where?: BreweryServiceWhereInput
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    cursor?: BreweryServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryServiceScalarFieldEnum | BreweryServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model BreweryService
   */

  export type AggregateBreweryService = {
    _count: BreweryServiceCountAggregateOutputType | null
    _min: BreweryServiceMinAggregateOutputType | null
    _max: BreweryServiceMaxAggregateOutputType | null
  }

  export type BreweryServiceMinAggregateOutputType = {
    id: string | null
    breweryId: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryServiceMaxAggregateOutputType = {
    id: string | null
    breweryId: string | null
    serviceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryServiceCountAggregateOutputType = {
    id: number
    breweryId: number
    serviceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryServiceMinAggregateInputType = {
    id?: true
    breweryId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryServiceMaxAggregateInputType = {
    id?: true
    breweryId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryServiceCountAggregateInputType = {
    id?: true
    breweryId?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryService to aggregate.
     */
    where?: BreweryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryServices to fetch.
     */
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryServices
    **/
    _count?: true | BreweryServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryServiceMaxAggregateInputType
  }

  export type GetBreweryServiceAggregateType<T extends BreweryServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryService[P]>
      : GetScalarType<T[P], AggregateBreweryService[P]>
  }




  export type BreweryServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryServiceWhereInput
    orderBy?: BreweryServiceOrderByWithAggregationInput | BreweryServiceOrderByWithAggregationInput[]
    by: BreweryServiceScalarFieldEnum[] | BreweryServiceScalarFieldEnum
    having?: BreweryServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryServiceCountAggregateInputType | true
    _min?: BreweryServiceMinAggregateInputType
    _max?: BreweryServiceMaxAggregateInputType
  }

  export type BreweryServiceGroupByOutputType = {
    id: string
    breweryId: string
    serviceId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryServiceCountAggregateOutputType | null
    _min: BreweryServiceMinAggregateOutputType | null
    _max: BreweryServiceMaxAggregateOutputType | null
  }

  type GetBreweryServiceGroupByPayload<T extends BreweryServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryServiceGroupByOutputType[P]>
        }
      >
    >


  export type BreweryServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breweryId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryService"]>


  export type BreweryServiceSelectScalar = {
    id?: boolean
    breweryId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BreweryServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryService"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      breweryId: string
      serviceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryService"]>
    composites: {}
  }

  type BreweryServiceGetPayload<S extends boolean | null | undefined | BreweryServiceDefaultArgs> = $Result.GetResult<Prisma.$BreweryServicePayload, S>

  type BreweryServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryServiceCountAggregateInputType | true
    }

  export interface BreweryServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryService'], meta: { name: 'BreweryService' } }
    /**
     * Find zero or one BreweryService that matches the filter.
     * @param {BreweryServiceFindUniqueArgs} args - Arguments to find a BreweryService
     * @example
     * // Get one BreweryService
     * const breweryService = await prisma.breweryService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryServiceFindUniqueArgs>(args: SelectSubset<T, BreweryServiceFindUniqueArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryServiceFindUniqueOrThrowArgs} args - Arguments to find a BreweryService
     * @example
     * // Get one BreweryService
     * const breweryService = await prisma.breweryService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceFindFirstArgs} args - Arguments to find a BreweryService
     * @example
     * // Get one BreweryService
     * const breweryService = await prisma.breweryService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryServiceFindFirstArgs>(args?: SelectSubset<T, BreweryServiceFindFirstArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceFindFirstOrThrowArgs} args - Arguments to find a BreweryService
     * @example
     * // Get one BreweryService
     * const breweryService = await prisma.breweryService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryServices
     * const breweryServices = await prisma.breweryService.findMany()
     * 
     * // Get first 10 BreweryServices
     * const breweryServices = await prisma.breweryService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryServiceWithIdOnly = await prisma.breweryService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryServiceFindManyArgs>(args?: SelectSubset<T, BreweryServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryService.
     * @param {BreweryServiceCreateArgs} args - Arguments to create a BreweryService.
     * @example
     * // Create one BreweryService
     * const BreweryService = await prisma.breweryService.create({
     *   data: {
     *     // ... data to create a BreweryService
     *   }
     * })
     * 
     */
    create<T extends BreweryServiceCreateArgs>(args: SelectSubset<T, BreweryServiceCreateArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryServices.
     * @param {BreweryServiceCreateManyArgs} args - Arguments to create many BreweryServices.
     * @example
     * // Create many BreweryServices
     * const breweryService = await prisma.breweryService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryServiceCreateManyArgs>(args?: SelectSubset<T, BreweryServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryService.
     * @param {BreweryServiceDeleteArgs} args - Arguments to delete one BreweryService.
     * @example
     * // Delete one BreweryService
     * const BreweryService = await prisma.breweryService.delete({
     *   where: {
     *     // ... filter to delete one BreweryService
     *   }
     * })
     * 
     */
    delete<T extends BreweryServiceDeleteArgs>(args: SelectSubset<T, BreweryServiceDeleteArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryService.
     * @param {BreweryServiceUpdateArgs} args - Arguments to update one BreweryService.
     * @example
     * // Update one BreweryService
     * const breweryService = await prisma.breweryService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryServiceUpdateArgs>(args: SelectSubset<T, BreweryServiceUpdateArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryServices.
     * @param {BreweryServiceDeleteManyArgs} args - Arguments to filter BreweryServices to delete.
     * @example
     * // Delete a few BreweryServices
     * const { count } = await prisma.breweryService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryServiceDeleteManyArgs>(args?: SelectSubset<T, BreweryServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryServices
     * const breweryService = await prisma.breweryService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryServiceUpdateManyArgs>(args: SelectSubset<T, BreweryServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryService.
     * @param {BreweryServiceUpsertArgs} args - Arguments to update or create a BreweryService.
     * @example
     * // Update or create a BreweryService
     * const breweryService = await prisma.breweryService.upsert({
     *   create: {
     *     // ... data to create a BreweryService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryService we want to update
     *   }
     * })
     */
    upsert<T extends BreweryServiceUpsertArgs>(args: SelectSubset<T, BreweryServiceUpsertArgs<ExtArgs>>): Prisma__BreweryServiceClient<$Result.GetResult<Prisma.$BreweryServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryServices that matches the filter.
     * @param {BreweryServiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryService = await prisma.breweryService.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryServiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryService.
     * @param {BreweryServiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryService = await prisma.breweryService.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryServiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceCountArgs} args - Arguments to filter BreweryServices to count.
     * @example
     * // Count the number of BreweryServices
     * const count = await prisma.breweryService.count({
     *   where: {
     *     // ... the filter for the BreweryServices we want to count
     *   }
     * })
    **/
    count<T extends BreweryServiceCountArgs>(
      args?: Subset<T, BreweryServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryServiceAggregateArgs>(args: Subset<T, BreweryServiceAggregateArgs>): Prisma.PrismaPromise<GetBreweryServiceAggregateType<T>>

    /**
     * Group by BreweryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryServiceGroupByArgs['orderBy'] }
        : { orderBy?: BreweryServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryService model
   */
  readonly fields: BreweryServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryService model
   */ 
  interface BreweryServiceFieldRefs {
    readonly id: FieldRef<"BreweryService", 'String'>
    readonly breweryId: FieldRef<"BreweryService", 'String'>
    readonly serviceId: FieldRef<"BreweryService", 'String'>
    readonly createdAt: FieldRef<"BreweryService", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryService findUnique
   */
  export type BreweryServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter, which BreweryService to fetch.
     */
    where: BreweryServiceWhereUniqueInput
  }

  /**
   * BreweryService findUniqueOrThrow
   */
  export type BreweryServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter, which BreweryService to fetch.
     */
    where: BreweryServiceWhereUniqueInput
  }

  /**
   * BreweryService findFirst
   */
  export type BreweryServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter, which BreweryService to fetch.
     */
    where?: BreweryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryServices to fetch.
     */
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryServices.
     */
    cursor?: BreweryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryServices.
     */
    distinct?: BreweryServiceScalarFieldEnum | BreweryServiceScalarFieldEnum[]
  }

  /**
   * BreweryService findFirstOrThrow
   */
  export type BreweryServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter, which BreweryService to fetch.
     */
    where?: BreweryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryServices to fetch.
     */
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryServices.
     */
    cursor?: BreweryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryServices.
     */
    distinct?: BreweryServiceScalarFieldEnum | BreweryServiceScalarFieldEnum[]
  }

  /**
   * BreweryService findMany
   */
  export type BreweryServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter, which BreweryServices to fetch.
     */
    where?: BreweryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryServices to fetch.
     */
    orderBy?: BreweryServiceOrderByWithRelationInput | BreweryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryServices.
     */
    cursor?: BreweryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryServices.
     */
    skip?: number
    distinct?: BreweryServiceScalarFieldEnum | BreweryServiceScalarFieldEnum[]
  }

  /**
   * BreweryService create
   */
  export type BreweryServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryService.
     */
    data: XOR<BreweryServiceCreateInput, BreweryServiceUncheckedCreateInput>
  }

  /**
   * BreweryService createMany
   */
  export type BreweryServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryServices.
     */
    data: BreweryServiceCreateManyInput | BreweryServiceCreateManyInput[]
  }

  /**
   * BreweryService update
   */
  export type BreweryServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryService.
     */
    data: XOR<BreweryServiceUpdateInput, BreweryServiceUncheckedUpdateInput>
    /**
     * Choose, which BreweryService to update.
     */
    where: BreweryServiceWhereUniqueInput
  }

  /**
   * BreweryService updateMany
   */
  export type BreweryServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryServices.
     */
    data: XOR<BreweryServiceUpdateManyMutationInput, BreweryServiceUncheckedUpdateManyInput>
    /**
     * Filter which BreweryServices to update
     */
    where?: BreweryServiceWhereInput
  }

  /**
   * BreweryService upsert
   */
  export type BreweryServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryService to update in case it exists.
     */
    where: BreweryServiceWhereUniqueInput
    /**
     * In case the BreweryService found by the `where` argument doesn't exist, create a new BreweryService with this data.
     */
    create: XOR<BreweryServiceCreateInput, BreweryServiceUncheckedCreateInput>
    /**
     * In case the BreweryService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryServiceUpdateInput, BreweryServiceUncheckedUpdateInput>
  }

  /**
   * BreweryService delete
   */
  export type BreweryServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
    /**
     * Filter which BreweryService to delete.
     */
    where: BreweryServiceWhereUniqueInput
  }

  /**
   * BreweryService deleteMany
   */
  export type BreweryServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryServices to delete
     */
    where?: BreweryServiceWhereInput
  }

  /**
   * BreweryService findRaw
   */
  export type BreweryServiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryService aggregateRaw
   */
  export type BreweryServiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryService without action
   */
  export type BreweryServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryService
     */
    select?: BreweryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryServiceInclude<ExtArgs> | null
  }


  /**
   * Model Music
   */

  export type AggregateMusic = {
    _count: MusicCountAggregateOutputType | null
    _min: MusicMinAggregateOutputType | null
    _max: MusicMaxAggregateOutputType | null
  }

  export type MusicMinAggregateOutputType = {
    id: string | null
    genre: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusicMaxAggregateOutputType = {
    id: string | null
    genre: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusicCountAggregateOutputType = {
    id: number
    genre: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MusicMinAggregateInputType = {
    id?: true
    genre?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusicMaxAggregateInputType = {
    id?: true
    genre?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusicCountAggregateInputType = {
    id?: true
    genre?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MusicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Music to aggregate.
     */
    where?: MusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Music to fetch.
     */
    orderBy?: MusicOrderByWithRelationInput | MusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Music from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Music.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Music
    **/
    _count?: true | MusicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MusicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MusicMaxAggregateInputType
  }

  export type GetMusicAggregateType<T extends MusicAggregateArgs> = {
        [P in keyof T & keyof AggregateMusic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMusic[P]>
      : GetScalarType<T[P], AggregateMusic[P]>
  }




  export type MusicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicWhereInput
    orderBy?: MusicOrderByWithAggregationInput | MusicOrderByWithAggregationInput[]
    by: MusicScalarFieldEnum[] | MusicScalarFieldEnum
    having?: MusicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MusicCountAggregateInputType | true
    _min?: MusicMinAggregateInputType
    _max?: MusicMaxAggregateInputType
  }

  export type MusicGroupByOutputType = {
    id: string
    genre: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: MusicCountAggregateOutputType | null
    _min: MusicMinAggregateOutputType | null
    _max: MusicMaxAggregateOutputType | null
  }

  type GetMusicGroupByPayload<T extends MusicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MusicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MusicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MusicGroupByOutputType[P]>
            : GetScalarType<T[P], MusicGroupByOutputType[P]>
        }
      >
    >


  export type MusicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genre?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweries?: boolean | Music$breweriesArgs<ExtArgs>
    _count?: boolean | MusicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["music"]>


  export type MusicSelectScalar = {
    id?: boolean
    genre?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MusicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | Music$breweriesArgs<ExtArgs>
    _count?: boolean | MusicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MusicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Music"
    objects: {
      breweries: Prisma.$BreweryMusicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      genre: string
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["music"]>
    composites: {}
  }

  type MusicGetPayload<S extends boolean | null | undefined | MusicDefaultArgs> = $Result.GetResult<Prisma.$MusicPayload, S>

  type MusicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MusicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MusicCountAggregateInputType | true
    }

  export interface MusicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Music'], meta: { name: 'Music' } }
    /**
     * Find zero or one Music that matches the filter.
     * @param {MusicFindUniqueArgs} args - Arguments to find a Music
     * @example
     * // Get one Music
     * const music = await prisma.music.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MusicFindUniqueArgs>(args: SelectSubset<T, MusicFindUniqueArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Music that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MusicFindUniqueOrThrowArgs} args - Arguments to find a Music
     * @example
     * // Get one Music
     * const music = await prisma.music.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MusicFindUniqueOrThrowArgs>(args: SelectSubset<T, MusicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Music that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicFindFirstArgs} args - Arguments to find a Music
     * @example
     * // Get one Music
     * const music = await prisma.music.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MusicFindFirstArgs>(args?: SelectSubset<T, MusicFindFirstArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Music that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicFindFirstOrThrowArgs} args - Arguments to find a Music
     * @example
     * // Get one Music
     * const music = await prisma.music.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MusicFindFirstOrThrowArgs>(args?: SelectSubset<T, MusicFindFirstOrThrowArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Music that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Music
     * const music = await prisma.music.findMany()
     * 
     * // Get first 10 Music
     * const music = await prisma.music.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const musicWithIdOnly = await prisma.music.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MusicFindManyArgs>(args?: SelectSubset<T, MusicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Music.
     * @param {MusicCreateArgs} args - Arguments to create a Music.
     * @example
     * // Create one Music
     * const Music = await prisma.music.create({
     *   data: {
     *     // ... data to create a Music
     *   }
     * })
     * 
     */
    create<T extends MusicCreateArgs>(args: SelectSubset<T, MusicCreateArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Music.
     * @param {MusicCreateManyArgs} args - Arguments to create many Music.
     * @example
     * // Create many Music
     * const music = await prisma.music.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MusicCreateManyArgs>(args?: SelectSubset<T, MusicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Music.
     * @param {MusicDeleteArgs} args - Arguments to delete one Music.
     * @example
     * // Delete one Music
     * const Music = await prisma.music.delete({
     *   where: {
     *     // ... filter to delete one Music
     *   }
     * })
     * 
     */
    delete<T extends MusicDeleteArgs>(args: SelectSubset<T, MusicDeleteArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Music.
     * @param {MusicUpdateArgs} args - Arguments to update one Music.
     * @example
     * // Update one Music
     * const music = await prisma.music.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MusicUpdateArgs>(args: SelectSubset<T, MusicUpdateArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Music.
     * @param {MusicDeleteManyArgs} args - Arguments to filter Music to delete.
     * @example
     * // Delete a few Music
     * const { count } = await prisma.music.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MusicDeleteManyArgs>(args?: SelectSubset<T, MusicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Music.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Music
     * const music = await prisma.music.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MusicUpdateManyArgs>(args: SelectSubset<T, MusicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Music.
     * @param {MusicUpsertArgs} args - Arguments to update or create a Music.
     * @example
     * // Update or create a Music
     * const music = await prisma.music.upsert({
     *   create: {
     *     // ... data to create a Music
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Music we want to update
     *   }
     * })
     */
    upsert<T extends MusicUpsertArgs>(args: SelectSubset<T, MusicUpsertArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Music that matches the filter.
     * @param {MusicFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const music = await prisma.music.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MusicFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Music.
     * @param {MusicAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const music = await prisma.music.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MusicAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Music.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicCountArgs} args - Arguments to filter Music to count.
     * @example
     * // Count the number of Music
     * const count = await prisma.music.count({
     *   where: {
     *     // ... the filter for the Music we want to count
     *   }
     * })
    **/
    count<T extends MusicCountArgs>(
      args?: Subset<T, MusicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MusicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Music.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MusicAggregateArgs>(args: Subset<T, MusicAggregateArgs>): Prisma.PrismaPromise<GetMusicAggregateType<T>>

    /**
     * Group by Music.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MusicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MusicGroupByArgs['orderBy'] }
        : { orderBy?: MusicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MusicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMusicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Music model
   */
  readonly fields: MusicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Music.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MusicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breweries<T extends Music$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Music$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Music model
   */ 
  interface MusicFieldRefs {
    readonly id: FieldRef<"Music", 'String'>
    readonly genre: FieldRef<"Music", 'String'>
    readonly image: FieldRef<"Music", 'String'>
    readonly createdAt: FieldRef<"Music", 'DateTime'>
    readonly updatedAt: FieldRef<"Music", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Music findUnique
   */
  export type MusicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter, which Music to fetch.
     */
    where: MusicWhereUniqueInput
  }

  /**
   * Music findUniqueOrThrow
   */
  export type MusicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter, which Music to fetch.
     */
    where: MusicWhereUniqueInput
  }

  /**
   * Music findFirst
   */
  export type MusicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter, which Music to fetch.
     */
    where?: MusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Music to fetch.
     */
    orderBy?: MusicOrderByWithRelationInput | MusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Music.
     */
    cursor?: MusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Music from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Music.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Music.
     */
    distinct?: MusicScalarFieldEnum | MusicScalarFieldEnum[]
  }

  /**
   * Music findFirstOrThrow
   */
  export type MusicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter, which Music to fetch.
     */
    where?: MusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Music to fetch.
     */
    orderBy?: MusicOrderByWithRelationInput | MusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Music.
     */
    cursor?: MusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Music from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Music.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Music.
     */
    distinct?: MusicScalarFieldEnum | MusicScalarFieldEnum[]
  }

  /**
   * Music findMany
   */
  export type MusicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter, which Music to fetch.
     */
    where?: MusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Music to fetch.
     */
    orderBy?: MusicOrderByWithRelationInput | MusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Music.
     */
    cursor?: MusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Music from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Music.
     */
    skip?: number
    distinct?: MusicScalarFieldEnum | MusicScalarFieldEnum[]
  }

  /**
   * Music create
   */
  export type MusicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * The data needed to create a Music.
     */
    data: XOR<MusicCreateInput, MusicUncheckedCreateInput>
  }

  /**
   * Music createMany
   */
  export type MusicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Music.
     */
    data: MusicCreateManyInput | MusicCreateManyInput[]
  }

  /**
   * Music update
   */
  export type MusicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * The data needed to update a Music.
     */
    data: XOR<MusicUpdateInput, MusicUncheckedUpdateInput>
    /**
     * Choose, which Music to update.
     */
    where: MusicWhereUniqueInput
  }

  /**
   * Music updateMany
   */
  export type MusicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Music.
     */
    data: XOR<MusicUpdateManyMutationInput, MusicUncheckedUpdateManyInput>
    /**
     * Filter which Music to update
     */
    where?: MusicWhereInput
  }

  /**
   * Music upsert
   */
  export type MusicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * The filter to search for the Music to update in case it exists.
     */
    where: MusicWhereUniqueInput
    /**
     * In case the Music found by the `where` argument doesn't exist, create a new Music with this data.
     */
    create: XOR<MusicCreateInput, MusicUncheckedCreateInput>
    /**
     * In case the Music was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MusicUpdateInput, MusicUncheckedUpdateInput>
  }

  /**
   * Music delete
   */
  export type MusicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
    /**
     * Filter which Music to delete.
     */
    where: MusicWhereUniqueInput
  }

  /**
   * Music deleteMany
   */
  export type MusicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Music to delete
     */
    where?: MusicWhereInput
  }

  /**
   * Music findRaw
   */
  export type MusicFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Music aggregateRaw
   */
  export type MusicAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Music.breweries
   */
  export type Music$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    where?: BreweryMusicWhereInput
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    cursor?: BreweryMusicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryMusicScalarFieldEnum | BreweryMusicScalarFieldEnum[]
  }

  /**
   * Music without action
   */
  export type MusicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Music
     */
    select?: MusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicInclude<ExtArgs> | null
  }


  /**
   * Model BreweryMusic
   */

  export type AggregateBreweryMusic = {
    _count: BreweryMusicCountAggregateOutputType | null
    _min: BreweryMusicMinAggregateOutputType | null
    _max: BreweryMusicMaxAggregateOutputType | null
  }

  export type BreweryMusicMinAggregateOutputType = {
    id: string | null
    breweryId: string | null
    musicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryMusicMaxAggregateOutputType = {
    id: string | null
    breweryId: string | null
    musicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryMusicCountAggregateOutputType = {
    id: number
    breweryId: number
    musicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryMusicMinAggregateInputType = {
    id?: true
    breweryId?: true
    musicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryMusicMaxAggregateInputType = {
    id?: true
    breweryId?: true
    musicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryMusicCountAggregateInputType = {
    id?: true
    breweryId?: true
    musicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryMusicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryMusic to aggregate.
     */
    where?: BreweryMusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryMusics to fetch.
     */
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryMusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryMusics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryMusics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryMusics
    **/
    _count?: true | BreweryMusicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryMusicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryMusicMaxAggregateInputType
  }

  export type GetBreweryMusicAggregateType<T extends BreweryMusicAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryMusic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryMusic[P]>
      : GetScalarType<T[P], AggregateBreweryMusic[P]>
  }




  export type BreweryMusicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryMusicWhereInput
    orderBy?: BreweryMusicOrderByWithAggregationInput | BreweryMusicOrderByWithAggregationInput[]
    by: BreweryMusicScalarFieldEnum[] | BreweryMusicScalarFieldEnum
    having?: BreweryMusicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryMusicCountAggregateInputType | true
    _min?: BreweryMusicMinAggregateInputType
    _max?: BreweryMusicMaxAggregateInputType
  }

  export type BreweryMusicGroupByOutputType = {
    id: string
    breweryId: string
    musicId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryMusicCountAggregateOutputType | null
    _min: BreweryMusicMinAggregateOutputType | null
    _max: BreweryMusicMaxAggregateOutputType | null
  }

  type GetBreweryMusicGroupByPayload<T extends BreweryMusicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryMusicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryMusicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryMusicGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryMusicGroupByOutputType[P]>
        }
      >
    >


  export type BreweryMusicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breweryId?: boolean
    musicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    music?: boolean | MusicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryMusic"]>


  export type BreweryMusicSelectScalar = {
    id?: boolean
    breweryId?: boolean
    musicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryMusicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    music?: boolean | MusicDefaultArgs<ExtArgs>
  }

  export type $BreweryMusicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryMusic"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
      music: Prisma.$MusicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      breweryId: string
      musicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryMusic"]>
    composites: {}
  }

  type BreweryMusicGetPayload<S extends boolean | null | undefined | BreweryMusicDefaultArgs> = $Result.GetResult<Prisma.$BreweryMusicPayload, S>

  type BreweryMusicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryMusicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryMusicCountAggregateInputType | true
    }

  export interface BreweryMusicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryMusic'], meta: { name: 'BreweryMusic' } }
    /**
     * Find zero or one BreweryMusic that matches the filter.
     * @param {BreweryMusicFindUniqueArgs} args - Arguments to find a BreweryMusic
     * @example
     * // Get one BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryMusicFindUniqueArgs>(args: SelectSubset<T, BreweryMusicFindUniqueArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryMusic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryMusicFindUniqueOrThrowArgs} args - Arguments to find a BreweryMusic
     * @example
     * // Get one BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryMusicFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryMusicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryMusic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicFindFirstArgs} args - Arguments to find a BreweryMusic
     * @example
     * // Get one BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryMusicFindFirstArgs>(args?: SelectSubset<T, BreweryMusicFindFirstArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryMusic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicFindFirstOrThrowArgs} args - Arguments to find a BreweryMusic
     * @example
     * // Get one BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryMusicFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryMusicFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryMusics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryMusics
     * const breweryMusics = await prisma.breweryMusic.findMany()
     * 
     * // Get first 10 BreweryMusics
     * const breweryMusics = await prisma.breweryMusic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryMusicWithIdOnly = await prisma.breweryMusic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryMusicFindManyArgs>(args?: SelectSubset<T, BreweryMusicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryMusic.
     * @param {BreweryMusicCreateArgs} args - Arguments to create a BreweryMusic.
     * @example
     * // Create one BreweryMusic
     * const BreweryMusic = await prisma.breweryMusic.create({
     *   data: {
     *     // ... data to create a BreweryMusic
     *   }
     * })
     * 
     */
    create<T extends BreweryMusicCreateArgs>(args: SelectSubset<T, BreweryMusicCreateArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryMusics.
     * @param {BreweryMusicCreateManyArgs} args - Arguments to create many BreweryMusics.
     * @example
     * // Create many BreweryMusics
     * const breweryMusic = await prisma.breweryMusic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryMusicCreateManyArgs>(args?: SelectSubset<T, BreweryMusicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryMusic.
     * @param {BreweryMusicDeleteArgs} args - Arguments to delete one BreweryMusic.
     * @example
     * // Delete one BreweryMusic
     * const BreweryMusic = await prisma.breweryMusic.delete({
     *   where: {
     *     // ... filter to delete one BreweryMusic
     *   }
     * })
     * 
     */
    delete<T extends BreweryMusicDeleteArgs>(args: SelectSubset<T, BreweryMusicDeleteArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryMusic.
     * @param {BreweryMusicUpdateArgs} args - Arguments to update one BreweryMusic.
     * @example
     * // Update one BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryMusicUpdateArgs>(args: SelectSubset<T, BreweryMusicUpdateArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryMusics.
     * @param {BreweryMusicDeleteManyArgs} args - Arguments to filter BreweryMusics to delete.
     * @example
     * // Delete a few BreweryMusics
     * const { count } = await prisma.breweryMusic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryMusicDeleteManyArgs>(args?: SelectSubset<T, BreweryMusicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryMusics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryMusics
     * const breweryMusic = await prisma.breweryMusic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryMusicUpdateManyArgs>(args: SelectSubset<T, BreweryMusicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryMusic.
     * @param {BreweryMusicUpsertArgs} args - Arguments to update or create a BreweryMusic.
     * @example
     * // Update or create a BreweryMusic
     * const breweryMusic = await prisma.breweryMusic.upsert({
     *   create: {
     *     // ... data to create a BreweryMusic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryMusic we want to update
     *   }
     * })
     */
    upsert<T extends BreweryMusicUpsertArgs>(args: SelectSubset<T, BreweryMusicUpsertArgs<ExtArgs>>): Prisma__BreweryMusicClient<$Result.GetResult<Prisma.$BreweryMusicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryMusics that matches the filter.
     * @param {BreweryMusicFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryMusic = await prisma.breweryMusic.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryMusicFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryMusic.
     * @param {BreweryMusicAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryMusic = await prisma.breweryMusic.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryMusicAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryMusics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicCountArgs} args - Arguments to filter BreweryMusics to count.
     * @example
     * // Count the number of BreweryMusics
     * const count = await prisma.breweryMusic.count({
     *   where: {
     *     // ... the filter for the BreweryMusics we want to count
     *   }
     * })
    **/
    count<T extends BreweryMusicCountArgs>(
      args?: Subset<T, BreweryMusicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryMusicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryMusic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryMusicAggregateArgs>(args: Subset<T, BreweryMusicAggregateArgs>): Prisma.PrismaPromise<GetBreweryMusicAggregateType<T>>

    /**
     * Group by BreweryMusic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryMusicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryMusicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryMusicGroupByArgs['orderBy'] }
        : { orderBy?: BreweryMusicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryMusicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryMusicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryMusic model
   */
  readonly fields: BreweryMusicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryMusic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryMusicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    music<T extends MusicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusicDefaultArgs<ExtArgs>>): Prisma__MusicClient<$Result.GetResult<Prisma.$MusicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryMusic model
   */ 
  interface BreweryMusicFieldRefs {
    readonly id: FieldRef<"BreweryMusic", 'String'>
    readonly breweryId: FieldRef<"BreweryMusic", 'String'>
    readonly musicId: FieldRef<"BreweryMusic", 'String'>
    readonly createdAt: FieldRef<"BreweryMusic", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryMusic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryMusic findUnique
   */
  export type BreweryMusicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter, which BreweryMusic to fetch.
     */
    where: BreweryMusicWhereUniqueInput
  }

  /**
   * BreweryMusic findUniqueOrThrow
   */
  export type BreweryMusicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter, which BreweryMusic to fetch.
     */
    where: BreweryMusicWhereUniqueInput
  }

  /**
   * BreweryMusic findFirst
   */
  export type BreweryMusicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter, which BreweryMusic to fetch.
     */
    where?: BreweryMusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryMusics to fetch.
     */
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryMusics.
     */
    cursor?: BreweryMusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryMusics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryMusics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryMusics.
     */
    distinct?: BreweryMusicScalarFieldEnum | BreweryMusicScalarFieldEnum[]
  }

  /**
   * BreweryMusic findFirstOrThrow
   */
  export type BreweryMusicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter, which BreweryMusic to fetch.
     */
    where?: BreweryMusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryMusics to fetch.
     */
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryMusics.
     */
    cursor?: BreweryMusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryMusics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryMusics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryMusics.
     */
    distinct?: BreweryMusicScalarFieldEnum | BreweryMusicScalarFieldEnum[]
  }

  /**
   * BreweryMusic findMany
   */
  export type BreweryMusicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter, which BreweryMusics to fetch.
     */
    where?: BreweryMusicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryMusics to fetch.
     */
    orderBy?: BreweryMusicOrderByWithRelationInput | BreweryMusicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryMusics.
     */
    cursor?: BreweryMusicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryMusics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryMusics.
     */
    skip?: number
    distinct?: BreweryMusicScalarFieldEnum | BreweryMusicScalarFieldEnum[]
  }

  /**
   * BreweryMusic create
   */
  export type BreweryMusicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryMusic.
     */
    data: XOR<BreweryMusicCreateInput, BreweryMusicUncheckedCreateInput>
  }

  /**
   * BreweryMusic createMany
   */
  export type BreweryMusicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryMusics.
     */
    data: BreweryMusicCreateManyInput | BreweryMusicCreateManyInput[]
  }

  /**
   * BreweryMusic update
   */
  export type BreweryMusicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryMusic.
     */
    data: XOR<BreweryMusicUpdateInput, BreweryMusicUncheckedUpdateInput>
    /**
     * Choose, which BreweryMusic to update.
     */
    where: BreweryMusicWhereUniqueInput
  }

  /**
   * BreweryMusic updateMany
   */
  export type BreweryMusicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryMusics.
     */
    data: XOR<BreweryMusicUpdateManyMutationInput, BreweryMusicUncheckedUpdateManyInput>
    /**
     * Filter which BreweryMusics to update
     */
    where?: BreweryMusicWhereInput
  }

  /**
   * BreweryMusic upsert
   */
  export type BreweryMusicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryMusic to update in case it exists.
     */
    where: BreweryMusicWhereUniqueInput
    /**
     * In case the BreweryMusic found by the `where` argument doesn't exist, create a new BreweryMusic with this data.
     */
    create: XOR<BreweryMusicCreateInput, BreweryMusicUncheckedCreateInput>
    /**
     * In case the BreweryMusic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryMusicUpdateInput, BreweryMusicUncheckedUpdateInput>
  }

  /**
   * BreweryMusic delete
   */
  export type BreweryMusicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
    /**
     * Filter which BreweryMusic to delete.
     */
    where: BreweryMusicWhereUniqueInput
  }

  /**
   * BreweryMusic deleteMany
   */
  export type BreweryMusicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryMusics to delete
     */
    where?: BreweryMusicWhereInput
  }

  /**
   * BreweryMusic findRaw
   */
  export type BreweryMusicFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryMusic aggregateRaw
   */
  export type BreweryMusicAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryMusic without action
   */
  export type BreweryMusicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryMusic
     */
    select?: BreweryMusicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryMusicInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    description: number
    date: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    description: string | null
    date: Date
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweries?: boolean | Event$breweriesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breweries?: boolean | Event$breweriesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      breweries: Prisma.$BreweryEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      date: Date
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * @param {EventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const event = await prisma.event.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Event.
     * @param {EventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const event = await prisma.event.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breweries<T extends Event$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Event$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly image: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event findRaw
   */
  export type EventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Event aggregateRaw
   */
  export type EventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Event.breweries
   */
  export type Event$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    where?: BreweryEventWhereInput
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    cursor?: BreweryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreweryEventScalarFieldEnum | BreweryEventScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model BreweryEvent
   */

  export type AggregateBreweryEvent = {
    _count: BreweryEventCountAggregateOutputType | null
    _min: BreweryEventMinAggregateOutputType | null
    _max: BreweryEventMaxAggregateOutputType | null
  }

  export type BreweryEventMinAggregateOutputType = {
    id: string | null
    breweryId: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryEventMaxAggregateOutputType = {
    id: string | null
    breweryId: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryEventCountAggregateOutputType = {
    id: number
    breweryId: number
    eventId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryEventMinAggregateInputType = {
    id?: true
    breweryId?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryEventMaxAggregateInputType = {
    id?: true
    breweryId?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryEventCountAggregateInputType = {
    id?: true
    breweryId?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryEvent to aggregate.
     */
    where?: BreweryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryEvents to fetch.
     */
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryEvents
    **/
    _count?: true | BreweryEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryEventMaxAggregateInputType
  }

  export type GetBreweryEventAggregateType<T extends BreweryEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryEvent[P]>
      : GetScalarType<T[P], AggregateBreweryEvent[P]>
  }




  export type BreweryEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryEventWhereInput
    orderBy?: BreweryEventOrderByWithAggregationInput | BreweryEventOrderByWithAggregationInput[]
    by: BreweryEventScalarFieldEnum[] | BreweryEventScalarFieldEnum
    having?: BreweryEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryEventCountAggregateInputType | true
    _min?: BreweryEventMinAggregateInputType
    _max?: BreweryEventMaxAggregateInputType
  }

  export type BreweryEventGroupByOutputType = {
    id: string
    breweryId: string
    eventId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryEventCountAggregateOutputType | null
    _min: BreweryEventMinAggregateOutputType | null
    _max: BreweryEventMaxAggregateOutputType | null
  }

  type GetBreweryEventGroupByPayload<T extends BreweryEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryEventGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryEventGroupByOutputType[P]>
        }
      >
    >


  export type BreweryEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    breweryId?: boolean
    eventId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryEvent"]>


  export type BreweryEventSelectScalar = {
    id?: boolean
    breweryId?: boolean
    eventId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $BreweryEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryEvent"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      breweryId: string
      eventId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryEvent"]>
    composites: {}
  }

  type BreweryEventGetPayload<S extends boolean | null | undefined | BreweryEventDefaultArgs> = $Result.GetResult<Prisma.$BreweryEventPayload, S>

  type BreweryEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryEventCountAggregateInputType | true
    }

  export interface BreweryEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryEvent'], meta: { name: 'BreweryEvent' } }
    /**
     * Find zero or one BreweryEvent that matches the filter.
     * @param {BreweryEventFindUniqueArgs} args - Arguments to find a BreweryEvent
     * @example
     * // Get one BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryEventFindUniqueArgs>(args: SelectSubset<T, BreweryEventFindUniqueArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryEventFindUniqueOrThrowArgs} args - Arguments to find a BreweryEvent
     * @example
     * // Get one BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryEventFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventFindFirstArgs} args - Arguments to find a BreweryEvent
     * @example
     * // Get one BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryEventFindFirstArgs>(args?: SelectSubset<T, BreweryEventFindFirstArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventFindFirstOrThrowArgs} args - Arguments to find a BreweryEvent
     * @example
     * // Get one BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryEventFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryEvents
     * const breweryEvents = await prisma.breweryEvent.findMany()
     * 
     * // Get first 10 BreweryEvents
     * const breweryEvents = await prisma.breweryEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryEventWithIdOnly = await prisma.breweryEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryEventFindManyArgs>(args?: SelectSubset<T, BreweryEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryEvent.
     * @param {BreweryEventCreateArgs} args - Arguments to create a BreweryEvent.
     * @example
     * // Create one BreweryEvent
     * const BreweryEvent = await prisma.breweryEvent.create({
     *   data: {
     *     // ... data to create a BreweryEvent
     *   }
     * })
     * 
     */
    create<T extends BreweryEventCreateArgs>(args: SelectSubset<T, BreweryEventCreateArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryEvents.
     * @param {BreweryEventCreateManyArgs} args - Arguments to create many BreweryEvents.
     * @example
     * // Create many BreweryEvents
     * const breweryEvent = await prisma.breweryEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryEventCreateManyArgs>(args?: SelectSubset<T, BreweryEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryEvent.
     * @param {BreweryEventDeleteArgs} args - Arguments to delete one BreweryEvent.
     * @example
     * // Delete one BreweryEvent
     * const BreweryEvent = await prisma.breweryEvent.delete({
     *   where: {
     *     // ... filter to delete one BreweryEvent
     *   }
     * })
     * 
     */
    delete<T extends BreweryEventDeleteArgs>(args: SelectSubset<T, BreweryEventDeleteArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryEvent.
     * @param {BreweryEventUpdateArgs} args - Arguments to update one BreweryEvent.
     * @example
     * // Update one BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryEventUpdateArgs>(args: SelectSubset<T, BreweryEventUpdateArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryEvents.
     * @param {BreweryEventDeleteManyArgs} args - Arguments to filter BreweryEvents to delete.
     * @example
     * // Delete a few BreweryEvents
     * const { count } = await prisma.breweryEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryEventDeleteManyArgs>(args?: SelectSubset<T, BreweryEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryEvents
     * const breweryEvent = await prisma.breweryEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryEventUpdateManyArgs>(args: SelectSubset<T, BreweryEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryEvent.
     * @param {BreweryEventUpsertArgs} args - Arguments to update or create a BreweryEvent.
     * @example
     * // Update or create a BreweryEvent
     * const breweryEvent = await prisma.breweryEvent.upsert({
     *   create: {
     *     // ... data to create a BreweryEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryEvent we want to update
     *   }
     * })
     */
    upsert<T extends BreweryEventUpsertArgs>(args: SelectSubset<T, BreweryEventUpsertArgs<ExtArgs>>): Prisma__BreweryEventClient<$Result.GetResult<Prisma.$BreweryEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryEvents that matches the filter.
     * @param {BreweryEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryEvent = await prisma.breweryEvent.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryEvent.
     * @param {BreweryEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryEvent = await prisma.breweryEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventCountArgs} args - Arguments to filter BreweryEvents to count.
     * @example
     * // Count the number of BreweryEvents
     * const count = await prisma.breweryEvent.count({
     *   where: {
     *     // ... the filter for the BreweryEvents we want to count
     *   }
     * })
    **/
    count<T extends BreweryEventCountArgs>(
      args?: Subset<T, BreweryEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryEventAggregateArgs>(args: Subset<T, BreweryEventAggregateArgs>): Prisma.PrismaPromise<GetBreweryEventAggregateType<T>>

    /**
     * Group by BreweryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryEventGroupByArgs['orderBy'] }
        : { orderBy?: BreweryEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryEvent model
   */
  readonly fields: BreweryEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryEvent model
   */ 
  interface BreweryEventFieldRefs {
    readonly id: FieldRef<"BreweryEvent", 'String'>
    readonly breweryId: FieldRef<"BreweryEvent", 'String'>
    readonly eventId: FieldRef<"BreweryEvent", 'String'>
    readonly createdAt: FieldRef<"BreweryEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryEvent findUnique
   */
  export type BreweryEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter, which BreweryEvent to fetch.
     */
    where: BreweryEventWhereUniqueInput
  }

  /**
   * BreweryEvent findUniqueOrThrow
   */
  export type BreweryEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter, which BreweryEvent to fetch.
     */
    where: BreweryEventWhereUniqueInput
  }

  /**
   * BreweryEvent findFirst
   */
  export type BreweryEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter, which BreweryEvent to fetch.
     */
    where?: BreweryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryEvents to fetch.
     */
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryEvents.
     */
    cursor?: BreweryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryEvents.
     */
    distinct?: BreweryEventScalarFieldEnum | BreweryEventScalarFieldEnum[]
  }

  /**
   * BreweryEvent findFirstOrThrow
   */
  export type BreweryEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter, which BreweryEvent to fetch.
     */
    where?: BreweryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryEvents to fetch.
     */
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryEvents.
     */
    cursor?: BreweryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryEvents.
     */
    distinct?: BreweryEventScalarFieldEnum | BreweryEventScalarFieldEnum[]
  }

  /**
   * BreweryEvent findMany
   */
  export type BreweryEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter, which BreweryEvents to fetch.
     */
    where?: BreweryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryEvents to fetch.
     */
    orderBy?: BreweryEventOrderByWithRelationInput | BreweryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryEvents.
     */
    cursor?: BreweryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryEvents.
     */
    skip?: number
    distinct?: BreweryEventScalarFieldEnum | BreweryEventScalarFieldEnum[]
  }

  /**
   * BreweryEvent create
   */
  export type BreweryEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryEvent.
     */
    data: XOR<BreweryEventCreateInput, BreweryEventUncheckedCreateInput>
  }

  /**
   * BreweryEvent createMany
   */
  export type BreweryEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryEvents.
     */
    data: BreweryEventCreateManyInput | BreweryEventCreateManyInput[]
  }

  /**
   * BreweryEvent update
   */
  export type BreweryEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryEvent.
     */
    data: XOR<BreweryEventUpdateInput, BreweryEventUncheckedUpdateInput>
    /**
     * Choose, which BreweryEvent to update.
     */
    where: BreweryEventWhereUniqueInput
  }

  /**
   * BreweryEvent updateMany
   */
  export type BreweryEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryEvents.
     */
    data: XOR<BreweryEventUpdateManyMutationInput, BreweryEventUncheckedUpdateManyInput>
    /**
     * Filter which BreweryEvents to update
     */
    where?: BreweryEventWhereInput
  }

  /**
   * BreweryEvent upsert
   */
  export type BreweryEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryEvent to update in case it exists.
     */
    where: BreweryEventWhereUniqueInput
    /**
     * In case the BreweryEvent found by the `where` argument doesn't exist, create a new BreweryEvent with this data.
     */
    create: XOR<BreweryEventCreateInput, BreweryEventUncheckedCreateInput>
    /**
     * In case the BreweryEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryEventUpdateInput, BreweryEventUncheckedUpdateInput>
  }

  /**
   * BreweryEvent delete
   */
  export type BreweryEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
    /**
     * Filter which BreweryEvent to delete.
     */
    where: BreweryEventWhereUniqueInput
  }

  /**
   * BreweryEvent deleteMany
   */
  export type BreweryEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryEvents to delete
     */
    where?: BreweryEventWhereInput
  }

  /**
   * BreweryEvent findRaw
   */
  export type BreweryEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryEvent aggregateRaw
   */
  export type BreweryEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryEvent without action
   */
  export type BreweryEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryEvent
     */
    select?: BreweryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryEventInclude<ExtArgs> | null
  }


  /**
   * Model BreweryFeature
   */

  export type AggregateBreweryFeature = {
    _count: BreweryFeatureCountAggregateOutputType | null
    _avg: BreweryFeatureAvgAggregateOutputType | null
    _sum: BreweryFeatureSumAggregateOutputType | null
    _min: BreweryFeatureMinAggregateOutputType | null
    _max: BreweryFeatureMaxAggregateOutputType | null
  }

  export type BreweryFeatureAvgAggregateOutputType = {
    state: number | null
  }

  export type BreweryFeatureSumAggregateOutputType = {
    state: number | null
  }

  export type BreweryFeatureMinAggregateOutputType = {
    id: string | null
    logo: string | null
    image: string | null
    description: string | null
    phone: string | null
    facebook: string | null
    x: string | null
    instagram: string | null
    highlighted: boolean | null
    capacity: string | null
    booklink: string | null
    pricerank: string | null
    state: number | null
    breweryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryFeatureMaxAggregateOutputType = {
    id: string | null
    logo: string | null
    image: string | null
    description: string | null
    phone: string | null
    facebook: string | null
    x: string | null
    instagram: string | null
    highlighted: boolean | null
    capacity: string | null
    booklink: string | null
    pricerank: string | null
    state: number | null
    breweryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreweryFeatureCountAggregateOutputType = {
    id: number
    logo: number
    image: number
    description: number
    phone: number
    facebook: number
    x: number
    instagram: number
    highlighted: number
    capacity: number
    booklink: number
    pricerank: number
    state: number
    breweryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreweryFeatureAvgAggregateInputType = {
    state?: true
  }

  export type BreweryFeatureSumAggregateInputType = {
    state?: true
  }

  export type BreweryFeatureMinAggregateInputType = {
    id?: true
    logo?: true
    image?: true
    description?: true
    phone?: true
    facebook?: true
    x?: true
    instagram?: true
    highlighted?: true
    capacity?: true
    booklink?: true
    pricerank?: true
    state?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryFeatureMaxAggregateInputType = {
    id?: true
    logo?: true
    image?: true
    description?: true
    phone?: true
    facebook?: true
    x?: true
    instagram?: true
    highlighted?: true
    capacity?: true
    booklink?: true
    pricerank?: true
    state?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreweryFeatureCountAggregateInputType = {
    id?: true
    logo?: true
    image?: true
    description?: true
    phone?: true
    facebook?: true
    x?: true
    instagram?: true
    highlighted?: true
    capacity?: true
    booklink?: true
    pricerank?: true
    state?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreweryFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryFeature to aggregate.
     */
    where?: BreweryFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFeatures to fetch.
     */
    orderBy?: BreweryFeatureOrderByWithRelationInput | BreweryFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreweryFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreweryFeatures
    **/
    _count?: true | BreweryFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreweryFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreweryFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreweryFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreweryFeatureMaxAggregateInputType
  }

  export type GetBreweryFeatureAggregateType<T extends BreweryFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateBreweryFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreweryFeature[P]>
      : GetScalarType<T[P], AggregateBreweryFeature[P]>
  }




  export type BreweryFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreweryFeatureWhereInput
    orderBy?: BreweryFeatureOrderByWithAggregationInput | BreweryFeatureOrderByWithAggregationInput[]
    by: BreweryFeatureScalarFieldEnum[] | BreweryFeatureScalarFieldEnum
    having?: BreweryFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreweryFeatureCountAggregateInputType | true
    _avg?: BreweryFeatureAvgAggregateInputType
    _sum?: BreweryFeatureSumAggregateInputType
    _min?: BreweryFeatureMinAggregateInputType
    _max?: BreweryFeatureMaxAggregateInputType
  }

  export type BreweryFeatureGroupByOutputType = {
    id: string
    logo: string | null
    image: string | null
    description: string | null
    phone: string | null
    facebook: string | null
    x: string | null
    instagram: string | null
    highlighted: boolean | null
    capacity: string | null
    booklink: string | null
    pricerank: string | null
    state: number | null
    breweryId: string
    createdAt: Date
    updatedAt: Date
    _count: BreweryFeatureCountAggregateOutputType | null
    _avg: BreweryFeatureAvgAggregateOutputType | null
    _sum: BreweryFeatureSumAggregateOutputType | null
    _min: BreweryFeatureMinAggregateOutputType | null
    _max: BreweryFeatureMaxAggregateOutputType | null
  }

  type GetBreweryFeatureGroupByPayload<T extends BreweryFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreweryFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreweryFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreweryFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], BreweryFeatureGroupByOutputType[P]>
        }
      >
    >


  export type BreweryFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logo?: boolean
    image?: boolean
    description?: boolean
    phone?: boolean
    facebook?: boolean
    x?: boolean
    instagram?: boolean
    highlighted?: boolean
    capacity?: boolean
    booklink?: boolean
    pricerank?: boolean
    state?: boolean
    breweryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breweryFeature"]>


  export type BreweryFeatureSelectScalar = {
    id?: boolean
    logo?: boolean
    image?: boolean
    description?: boolean
    phone?: boolean
    facebook?: boolean
    x?: boolean
    instagram?: boolean
    highlighted?: boolean
    capacity?: boolean
    booklink?: boolean
    pricerank?: boolean
    state?: boolean
    breweryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreweryFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
  }

  export type $BreweryFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreweryFeature"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      logo: string | null
      image: string | null
      description: string | null
      phone: string | null
      facebook: string | null
      x: string | null
      instagram: string | null
      highlighted: boolean | null
      capacity: string | null
      booklink: string | null
      pricerank: string | null
      state: number | null
      breweryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breweryFeature"]>
    composites: {}
  }

  type BreweryFeatureGetPayload<S extends boolean | null | undefined | BreweryFeatureDefaultArgs> = $Result.GetResult<Prisma.$BreweryFeaturePayload, S>

  type BreweryFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreweryFeatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreweryFeatureCountAggregateInputType | true
    }

  export interface BreweryFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreweryFeature'], meta: { name: 'BreweryFeature' } }
    /**
     * Find zero or one BreweryFeature that matches the filter.
     * @param {BreweryFeatureFindUniqueArgs} args - Arguments to find a BreweryFeature
     * @example
     * // Get one BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreweryFeatureFindUniqueArgs>(args: SelectSubset<T, BreweryFeatureFindUniqueArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreweryFeature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreweryFeatureFindUniqueOrThrowArgs} args - Arguments to find a BreweryFeature
     * @example
     * // Get one BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreweryFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, BreweryFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreweryFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureFindFirstArgs} args - Arguments to find a BreweryFeature
     * @example
     * // Get one BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreweryFeatureFindFirstArgs>(args?: SelectSubset<T, BreweryFeatureFindFirstArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreweryFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureFindFirstOrThrowArgs} args - Arguments to find a BreweryFeature
     * @example
     * // Get one BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreweryFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, BreweryFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreweryFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreweryFeatures
     * const breweryFeatures = await prisma.breweryFeature.findMany()
     * 
     * // Get first 10 BreweryFeatures
     * const breweryFeatures = await prisma.breweryFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breweryFeatureWithIdOnly = await prisma.breweryFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreweryFeatureFindManyArgs>(args?: SelectSubset<T, BreweryFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreweryFeature.
     * @param {BreweryFeatureCreateArgs} args - Arguments to create a BreweryFeature.
     * @example
     * // Create one BreweryFeature
     * const BreweryFeature = await prisma.breweryFeature.create({
     *   data: {
     *     // ... data to create a BreweryFeature
     *   }
     * })
     * 
     */
    create<T extends BreweryFeatureCreateArgs>(args: SelectSubset<T, BreweryFeatureCreateArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreweryFeatures.
     * @param {BreweryFeatureCreateManyArgs} args - Arguments to create many BreweryFeatures.
     * @example
     * // Create many BreweryFeatures
     * const breweryFeature = await prisma.breweryFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreweryFeatureCreateManyArgs>(args?: SelectSubset<T, BreweryFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BreweryFeature.
     * @param {BreweryFeatureDeleteArgs} args - Arguments to delete one BreweryFeature.
     * @example
     * // Delete one BreweryFeature
     * const BreweryFeature = await prisma.breweryFeature.delete({
     *   where: {
     *     // ... filter to delete one BreweryFeature
     *   }
     * })
     * 
     */
    delete<T extends BreweryFeatureDeleteArgs>(args: SelectSubset<T, BreweryFeatureDeleteArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreweryFeature.
     * @param {BreweryFeatureUpdateArgs} args - Arguments to update one BreweryFeature.
     * @example
     * // Update one BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreweryFeatureUpdateArgs>(args: SelectSubset<T, BreweryFeatureUpdateArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreweryFeatures.
     * @param {BreweryFeatureDeleteManyArgs} args - Arguments to filter BreweryFeatures to delete.
     * @example
     * // Delete a few BreweryFeatures
     * const { count } = await prisma.breweryFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreweryFeatureDeleteManyArgs>(args?: SelectSubset<T, BreweryFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreweryFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreweryFeatures
     * const breweryFeature = await prisma.breweryFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreweryFeatureUpdateManyArgs>(args: SelectSubset<T, BreweryFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreweryFeature.
     * @param {BreweryFeatureUpsertArgs} args - Arguments to update or create a BreweryFeature.
     * @example
     * // Update or create a BreweryFeature
     * const breweryFeature = await prisma.breweryFeature.upsert({
     *   create: {
     *     // ... data to create a BreweryFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreweryFeature we want to update
     *   }
     * })
     */
    upsert<T extends BreweryFeatureUpsertArgs>(args: SelectSubset<T, BreweryFeatureUpsertArgs<ExtArgs>>): Prisma__BreweryFeatureClient<$Result.GetResult<Prisma.$BreweryFeaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BreweryFeatures that matches the filter.
     * @param {BreweryFeatureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const breweryFeature = await prisma.breweryFeature.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BreweryFeatureFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BreweryFeature.
     * @param {BreweryFeatureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const breweryFeature = await prisma.breweryFeature.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BreweryFeatureAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BreweryFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureCountArgs} args - Arguments to filter BreweryFeatures to count.
     * @example
     * // Count the number of BreweryFeatures
     * const count = await prisma.breweryFeature.count({
     *   where: {
     *     // ... the filter for the BreweryFeatures we want to count
     *   }
     * })
    **/
    count<T extends BreweryFeatureCountArgs>(
      args?: Subset<T, BreweryFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreweryFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreweryFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreweryFeatureAggregateArgs>(args: Subset<T, BreweryFeatureAggregateArgs>): Prisma.PrismaPromise<GetBreweryFeatureAggregateType<T>>

    /**
     * Group by BreweryFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreweryFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreweryFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreweryFeatureGroupByArgs['orderBy'] }
        : { orderBy?: BreweryFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreweryFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreweryFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreweryFeature model
   */
  readonly fields: BreweryFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreweryFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreweryFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreweryFeature model
   */ 
  interface BreweryFeatureFieldRefs {
    readonly id: FieldRef<"BreweryFeature", 'String'>
    readonly logo: FieldRef<"BreweryFeature", 'String'>
    readonly image: FieldRef<"BreweryFeature", 'String'>
    readonly description: FieldRef<"BreweryFeature", 'String'>
    readonly phone: FieldRef<"BreweryFeature", 'String'>
    readonly facebook: FieldRef<"BreweryFeature", 'String'>
    readonly x: FieldRef<"BreweryFeature", 'String'>
    readonly instagram: FieldRef<"BreweryFeature", 'String'>
    readonly highlighted: FieldRef<"BreweryFeature", 'Boolean'>
    readonly capacity: FieldRef<"BreweryFeature", 'String'>
    readonly booklink: FieldRef<"BreweryFeature", 'String'>
    readonly pricerank: FieldRef<"BreweryFeature", 'String'>
    readonly state: FieldRef<"BreweryFeature", 'Int'>
    readonly breweryId: FieldRef<"BreweryFeature", 'String'>
    readonly createdAt: FieldRef<"BreweryFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"BreweryFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreweryFeature findUnique
   */
  export type BreweryFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFeature to fetch.
     */
    where: BreweryFeatureWhereUniqueInput
  }

  /**
   * BreweryFeature findUniqueOrThrow
   */
  export type BreweryFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFeature to fetch.
     */
    where: BreweryFeatureWhereUniqueInput
  }

  /**
   * BreweryFeature findFirst
   */
  export type BreweryFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFeature to fetch.
     */
    where?: BreweryFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFeatures to fetch.
     */
    orderBy?: BreweryFeatureOrderByWithRelationInput | BreweryFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryFeatures.
     */
    cursor?: BreweryFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryFeatures.
     */
    distinct?: BreweryFeatureScalarFieldEnum | BreweryFeatureScalarFieldEnum[]
  }

  /**
   * BreweryFeature findFirstOrThrow
   */
  export type BreweryFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFeature to fetch.
     */
    where?: BreweryFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFeatures to fetch.
     */
    orderBy?: BreweryFeatureOrderByWithRelationInput | BreweryFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreweryFeatures.
     */
    cursor?: BreweryFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreweryFeatures.
     */
    distinct?: BreweryFeatureScalarFieldEnum | BreweryFeatureScalarFieldEnum[]
  }

  /**
   * BreweryFeature findMany
   */
  export type BreweryFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BreweryFeatures to fetch.
     */
    where?: BreweryFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreweryFeatures to fetch.
     */
    orderBy?: BreweryFeatureOrderByWithRelationInput | BreweryFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreweryFeatures.
     */
    cursor?: BreweryFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreweryFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreweryFeatures.
     */
    skip?: number
    distinct?: BreweryFeatureScalarFieldEnum | BreweryFeatureScalarFieldEnum[]
  }

  /**
   * BreweryFeature create
   */
  export type BreweryFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a BreweryFeature.
     */
    data: XOR<BreweryFeatureCreateInput, BreweryFeatureUncheckedCreateInput>
  }

  /**
   * BreweryFeature createMany
   */
  export type BreweryFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreweryFeatures.
     */
    data: BreweryFeatureCreateManyInput | BreweryFeatureCreateManyInput[]
  }

  /**
   * BreweryFeature update
   */
  export type BreweryFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a BreweryFeature.
     */
    data: XOR<BreweryFeatureUpdateInput, BreweryFeatureUncheckedUpdateInput>
    /**
     * Choose, which BreweryFeature to update.
     */
    where: BreweryFeatureWhereUniqueInput
  }

  /**
   * BreweryFeature updateMany
   */
  export type BreweryFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreweryFeatures.
     */
    data: XOR<BreweryFeatureUpdateManyMutationInput, BreweryFeatureUncheckedUpdateManyInput>
    /**
     * Filter which BreweryFeatures to update
     */
    where?: BreweryFeatureWhereInput
  }

  /**
   * BreweryFeature upsert
   */
  export type BreweryFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the BreweryFeature to update in case it exists.
     */
    where: BreweryFeatureWhereUniqueInput
    /**
     * In case the BreweryFeature found by the `where` argument doesn't exist, create a new BreweryFeature with this data.
     */
    create: XOR<BreweryFeatureCreateInput, BreweryFeatureUncheckedCreateInput>
    /**
     * In case the BreweryFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreweryFeatureUpdateInput, BreweryFeatureUncheckedUpdateInput>
  }

  /**
   * BreweryFeature delete
   */
  export type BreweryFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
    /**
     * Filter which BreweryFeature to delete.
     */
    where: BreweryFeatureWhereUniqueInput
  }

  /**
   * BreweryFeature deleteMany
   */
  export type BreweryFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreweryFeatures to delete
     */
    where?: BreweryFeatureWhereInput
  }

  /**
   * BreweryFeature findRaw
   */
  export type BreweryFeatureFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryFeature aggregateRaw
   */
  export type BreweryFeatureAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BreweryFeature without action
   */
  export type BreweryFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreweryFeature
     */
    select?: BreweryFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryFeatureInclude<ExtArgs> | null
  }


  /**
   * Model OperatingHours
   */

  export type AggregateOperatingHours = {
    _count: OperatingHoursCountAggregateOutputType | null
    _min: OperatingHoursMinAggregateOutputType | null
    _max: OperatingHoursMaxAggregateOutputType | null
  }

  export type OperatingHoursMinAggregateOutputType = {
    id: string | null
    mondayOpen: string | null
    mondayClose: string | null
    tuesdayOpen: string | null
    tuesdayClose: string | null
    wednesdayOpen: string | null
    wednesdayClose: string | null
    thursdayOpen: string | null
    thursdayClose: string | null
    fridayOpen: string | null
    fridayClose: string | null
    saturdayOpen: string | null
    saturdayClose: string | null
    sundayOpen: string | null
    sundayClose: string | null
    breweryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHoursMaxAggregateOutputType = {
    id: string | null
    mondayOpen: string | null
    mondayClose: string | null
    tuesdayOpen: string | null
    tuesdayClose: string | null
    wednesdayOpen: string | null
    wednesdayClose: string | null
    thursdayOpen: string | null
    thursdayClose: string | null
    fridayOpen: string | null
    fridayClose: string | null
    saturdayOpen: string | null
    saturdayClose: string | null
    sundayOpen: string | null
    sundayClose: string | null
    breweryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHoursCountAggregateOutputType = {
    id: number
    mondayOpen: number
    mondayClose: number
    tuesdayOpen: number
    tuesdayClose: number
    wednesdayOpen: number
    wednesdayClose: number
    thursdayOpen: number
    thursdayClose: number
    fridayOpen: number
    fridayClose: number
    saturdayOpen: number
    saturdayClose: number
    sundayOpen: number
    sundayClose: number
    breweryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatingHoursMinAggregateInputType = {
    id?: true
    mondayOpen?: true
    mondayClose?: true
    tuesdayOpen?: true
    tuesdayClose?: true
    wednesdayOpen?: true
    wednesdayClose?: true
    thursdayOpen?: true
    thursdayClose?: true
    fridayOpen?: true
    fridayClose?: true
    saturdayOpen?: true
    saturdayClose?: true
    sundayOpen?: true
    sundayClose?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHoursMaxAggregateInputType = {
    id?: true
    mondayOpen?: true
    mondayClose?: true
    tuesdayOpen?: true
    tuesdayClose?: true
    wednesdayOpen?: true
    wednesdayClose?: true
    thursdayOpen?: true
    thursdayClose?: true
    fridayOpen?: true
    fridayClose?: true
    saturdayOpen?: true
    saturdayClose?: true
    sundayOpen?: true
    sundayClose?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHoursCountAggregateInputType = {
    id?: true
    mondayOpen?: true
    mondayClose?: true
    tuesdayOpen?: true
    tuesdayClose?: true
    wednesdayOpen?: true
    wednesdayClose?: true
    thursdayOpen?: true
    thursdayClose?: true
    fridayOpen?: true
    fridayClose?: true
    saturdayOpen?: true
    saturdayClose?: true
    sundayOpen?: true
    sundayClose?: true
    breweryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatingHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHours to aggregate.
     */
    where?: OperatingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHoursOrderByWithRelationInput | OperatingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperatingHours
    **/
    _count?: true | OperatingHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatingHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatingHoursMaxAggregateInputType
  }

  export type GetOperatingHoursAggregateType<T extends OperatingHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatingHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatingHours[P]>
      : GetScalarType<T[P], AggregateOperatingHours[P]>
  }




  export type OperatingHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHoursWhereInput
    orderBy?: OperatingHoursOrderByWithAggregationInput | OperatingHoursOrderByWithAggregationInput[]
    by: OperatingHoursScalarFieldEnum[] | OperatingHoursScalarFieldEnum
    having?: OperatingHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatingHoursCountAggregateInputType | true
    _min?: OperatingHoursMinAggregateInputType
    _max?: OperatingHoursMaxAggregateInputType
  }

  export type OperatingHoursGroupByOutputType = {
    id: string
    mondayOpen: string | null
    mondayClose: string | null
    tuesdayOpen: string | null
    tuesdayClose: string | null
    wednesdayOpen: string | null
    wednesdayClose: string | null
    thursdayOpen: string | null
    thursdayClose: string | null
    fridayOpen: string | null
    fridayClose: string | null
    saturdayOpen: string | null
    saturdayClose: string | null
    sundayOpen: string | null
    sundayClose: string | null
    breweryId: string
    createdAt: Date
    updatedAt: Date
    _count: OperatingHoursCountAggregateOutputType | null
    _min: OperatingHoursMinAggregateOutputType | null
    _max: OperatingHoursMaxAggregateOutputType | null
  }

  type GetOperatingHoursGroupByPayload<T extends OperatingHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatingHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatingHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatingHoursGroupByOutputType[P]>
            : GetScalarType<T[P], OperatingHoursGroupByOutputType[P]>
        }
      >
    >


  export type OperatingHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mondayOpen?: boolean
    mondayClose?: boolean
    tuesdayOpen?: boolean
    tuesdayClose?: boolean
    wednesdayOpen?: boolean
    wednesdayClose?: boolean
    thursdayOpen?: boolean
    thursdayClose?: boolean
    fridayOpen?: boolean
    fridayClose?: boolean
    saturdayOpen?: boolean
    saturdayClose?: boolean
    sundayOpen?: boolean
    sundayClose?: boolean
    breweryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHours"]>


  export type OperatingHoursSelectScalar = {
    id?: boolean
    mondayOpen?: boolean
    mondayClose?: boolean
    tuesdayOpen?: boolean
    tuesdayClose?: boolean
    wednesdayOpen?: boolean
    wednesdayClose?: boolean
    thursdayOpen?: boolean
    thursdayClose?: boolean
    fridayOpen?: boolean
    fridayClose?: boolean
    saturdayOpen?: boolean
    saturdayClose?: boolean
    sundayOpen?: boolean
    sundayClose?: boolean
    breweryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatingHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
  }

  export type $OperatingHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperatingHours"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mondayOpen: string | null
      mondayClose: string | null
      tuesdayOpen: string | null
      tuesdayClose: string | null
      wednesdayOpen: string | null
      wednesdayClose: string | null
      thursdayOpen: string | null
      thursdayClose: string | null
      fridayOpen: string | null
      fridayClose: string | null
      saturdayOpen: string | null
      saturdayClose: string | null
      sundayOpen: string | null
      sundayClose: string | null
      breweryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operatingHours"]>
    composites: {}
  }

  type OperatingHoursGetPayload<S extends boolean | null | undefined | OperatingHoursDefaultArgs> = $Result.GetResult<Prisma.$OperatingHoursPayload, S>

  type OperatingHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperatingHoursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperatingHoursCountAggregateInputType | true
    }

  export interface OperatingHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperatingHours'], meta: { name: 'OperatingHours' } }
    /**
     * Find zero or one OperatingHours that matches the filter.
     * @param {OperatingHoursFindUniqueArgs} args - Arguments to find a OperatingHours
     * @example
     * // Get one OperatingHours
     * const operatingHours = await prisma.operatingHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatingHoursFindUniqueArgs>(args: SelectSubset<T, OperatingHoursFindUniqueArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperatingHours that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperatingHoursFindUniqueOrThrowArgs} args - Arguments to find a OperatingHours
     * @example
     * // Get one OperatingHours
     * const operatingHours = await prisma.operatingHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatingHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatingHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperatingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursFindFirstArgs} args - Arguments to find a OperatingHours
     * @example
     * // Get one OperatingHours
     * const operatingHours = await prisma.operatingHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatingHoursFindFirstArgs>(args?: SelectSubset<T, OperatingHoursFindFirstArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperatingHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursFindFirstOrThrowArgs} args - Arguments to find a OperatingHours
     * @example
     * // Get one OperatingHours
     * const operatingHours = await prisma.operatingHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatingHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatingHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperatingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperatingHours
     * const operatingHours = await prisma.operatingHours.findMany()
     * 
     * // Get first 10 OperatingHours
     * const operatingHours = await prisma.operatingHours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatingHoursWithIdOnly = await prisma.operatingHours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatingHoursFindManyArgs>(args?: SelectSubset<T, OperatingHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperatingHours.
     * @param {OperatingHoursCreateArgs} args - Arguments to create a OperatingHours.
     * @example
     * // Create one OperatingHours
     * const OperatingHours = await prisma.operatingHours.create({
     *   data: {
     *     // ... data to create a OperatingHours
     *   }
     * })
     * 
     */
    create<T extends OperatingHoursCreateArgs>(args: SelectSubset<T, OperatingHoursCreateArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperatingHours.
     * @param {OperatingHoursCreateManyArgs} args - Arguments to create many OperatingHours.
     * @example
     * // Create many OperatingHours
     * const operatingHours = await prisma.operatingHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatingHoursCreateManyArgs>(args?: SelectSubset<T, OperatingHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperatingHours.
     * @param {OperatingHoursDeleteArgs} args - Arguments to delete one OperatingHours.
     * @example
     * // Delete one OperatingHours
     * const OperatingHours = await prisma.operatingHours.delete({
     *   where: {
     *     // ... filter to delete one OperatingHours
     *   }
     * })
     * 
     */
    delete<T extends OperatingHoursDeleteArgs>(args: SelectSubset<T, OperatingHoursDeleteArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperatingHours.
     * @param {OperatingHoursUpdateArgs} args - Arguments to update one OperatingHours.
     * @example
     * // Update one OperatingHours
     * const operatingHours = await prisma.operatingHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatingHoursUpdateArgs>(args: SelectSubset<T, OperatingHoursUpdateArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperatingHours.
     * @param {OperatingHoursDeleteManyArgs} args - Arguments to filter OperatingHours to delete.
     * @example
     * // Delete a few OperatingHours
     * const { count } = await prisma.operatingHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatingHoursDeleteManyArgs>(args?: SelectSubset<T, OperatingHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperatingHours
     * const operatingHours = await prisma.operatingHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatingHoursUpdateManyArgs>(args: SelectSubset<T, OperatingHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperatingHours.
     * @param {OperatingHoursUpsertArgs} args - Arguments to update or create a OperatingHours.
     * @example
     * // Update or create a OperatingHours
     * const operatingHours = await prisma.operatingHours.upsert({
     *   create: {
     *     // ... data to create a OperatingHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperatingHours we want to update
     *   }
     * })
     */
    upsert<T extends OperatingHoursUpsertArgs>(args: SelectSubset<T, OperatingHoursUpsertArgs<ExtArgs>>): Prisma__OperatingHoursClient<$Result.GetResult<Prisma.$OperatingHoursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more OperatingHours that matches the filter.
     * @param {OperatingHoursFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const operatingHours = await prisma.operatingHours.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: OperatingHoursFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OperatingHours.
     * @param {OperatingHoursAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const operatingHours = await prisma.operatingHours.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OperatingHoursAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursCountArgs} args - Arguments to filter OperatingHours to count.
     * @example
     * // Count the number of OperatingHours
     * const count = await prisma.operatingHours.count({
     *   where: {
     *     // ... the filter for the OperatingHours we want to count
     *   }
     * })
    **/
    count<T extends OperatingHoursCountArgs>(
      args?: Subset<T, OperatingHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatingHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatingHoursAggregateArgs>(args: Subset<T, OperatingHoursAggregateArgs>): Prisma.PrismaPromise<GetOperatingHoursAggregateType<T>>

    /**
     * Group by OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatingHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatingHoursGroupByArgs['orderBy'] }
        : { orderBy?: OperatingHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatingHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatingHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperatingHours model
   */
  readonly fields: OperatingHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperatingHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatingHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperatingHours model
   */ 
  interface OperatingHoursFieldRefs {
    readonly id: FieldRef<"OperatingHours", 'String'>
    readonly mondayOpen: FieldRef<"OperatingHours", 'String'>
    readonly mondayClose: FieldRef<"OperatingHours", 'String'>
    readonly tuesdayOpen: FieldRef<"OperatingHours", 'String'>
    readonly tuesdayClose: FieldRef<"OperatingHours", 'String'>
    readonly wednesdayOpen: FieldRef<"OperatingHours", 'String'>
    readonly wednesdayClose: FieldRef<"OperatingHours", 'String'>
    readonly thursdayOpen: FieldRef<"OperatingHours", 'String'>
    readonly thursdayClose: FieldRef<"OperatingHours", 'String'>
    readonly fridayOpen: FieldRef<"OperatingHours", 'String'>
    readonly fridayClose: FieldRef<"OperatingHours", 'String'>
    readonly saturdayOpen: FieldRef<"OperatingHours", 'String'>
    readonly saturdayClose: FieldRef<"OperatingHours", 'String'>
    readonly sundayOpen: FieldRef<"OperatingHours", 'String'>
    readonly sundayClose: FieldRef<"OperatingHours", 'String'>
    readonly breweryId: FieldRef<"OperatingHours", 'String'>
    readonly createdAt: FieldRef<"OperatingHours", 'DateTime'>
    readonly updatedAt: FieldRef<"OperatingHours", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperatingHours findUnique
   */
  export type OperatingHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where: OperatingHoursWhereUniqueInput
  }

  /**
   * OperatingHours findUniqueOrThrow
   */
  export type OperatingHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where: OperatingHoursWhereUniqueInput
  }

  /**
   * OperatingHours findFirst
   */
  export type OperatingHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where?: OperatingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHoursOrderByWithRelationInput | OperatingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHoursScalarFieldEnum | OperatingHoursScalarFieldEnum[]
  }

  /**
   * OperatingHours findFirstOrThrow
   */
  export type OperatingHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where?: OperatingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHoursOrderByWithRelationInput | OperatingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHoursScalarFieldEnum | OperatingHoursScalarFieldEnum[]
  }

  /**
   * OperatingHours findMany
   */
  export type OperatingHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where?: OperatingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHoursOrderByWithRelationInput | OperatingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperatingHours.
     */
    cursor?: OperatingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    distinct?: OperatingHoursScalarFieldEnum | OperatingHoursScalarFieldEnum[]
  }

  /**
   * OperatingHours create
   */
  export type OperatingHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a OperatingHours.
     */
    data: XOR<OperatingHoursCreateInput, OperatingHoursUncheckedCreateInput>
  }

  /**
   * OperatingHours createMany
   */
  export type OperatingHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperatingHours.
     */
    data: OperatingHoursCreateManyInput | OperatingHoursCreateManyInput[]
  }

  /**
   * OperatingHours update
   */
  export type OperatingHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a OperatingHours.
     */
    data: XOR<OperatingHoursUpdateInput, OperatingHoursUncheckedUpdateInput>
    /**
     * Choose, which OperatingHours to update.
     */
    where: OperatingHoursWhereUniqueInput
  }

  /**
   * OperatingHours updateMany
   */
  export type OperatingHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperatingHours.
     */
    data: XOR<OperatingHoursUpdateManyMutationInput, OperatingHoursUncheckedUpdateManyInput>
    /**
     * Filter which OperatingHours to update
     */
    where?: OperatingHoursWhereInput
  }

  /**
   * OperatingHours upsert
   */
  export type OperatingHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the OperatingHours to update in case it exists.
     */
    where: OperatingHoursWhereUniqueInput
    /**
     * In case the OperatingHours found by the `where` argument doesn't exist, create a new OperatingHours with this data.
     */
    create: XOR<OperatingHoursCreateInput, OperatingHoursUncheckedCreateInput>
    /**
     * In case the OperatingHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatingHoursUpdateInput, OperatingHoursUncheckedUpdateInput>
  }

  /**
   * OperatingHours delete
   */
  export type OperatingHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
    /**
     * Filter which OperatingHours to delete.
     */
    where: OperatingHoursWhereUniqueInput
  }

  /**
   * OperatingHours deleteMany
   */
  export type OperatingHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHours to delete
     */
    where?: OperatingHoursWhereInput
  }

  /**
   * OperatingHours findRaw
   */
  export type OperatingHoursFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OperatingHours aggregateRaw
   */
  export type OperatingHoursAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OperatingHours without action
   */
  export type OperatingHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHours
     */
    select?: OperatingHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHoursInclude<ExtArgs> | null
  }


  /**
   * Model TutorialStepsApp
   */

  export type AggregateTutorialStepsApp = {
    _count: TutorialStepsAppCountAggregateOutputType | null
    _avg: TutorialStepsAppAvgAggregateOutputType | null
    _sum: TutorialStepsAppSumAggregateOutputType | null
    _min: TutorialStepsAppMinAggregateOutputType | null
    _max: TutorialStepsAppMaxAggregateOutputType | null
  }

  export type TutorialStepsAppAvgAggregateOutputType = {
    orden: number | null
  }

  export type TutorialStepsAppSumAggregateOutputType = {
    orden: number | null
  }

  export type TutorialStepsAppMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    web_image: string | null
    mobile_image: string | null
    orden: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TutorialStepsAppMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    web_image: string | null
    mobile_image: string | null
    orden: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TutorialStepsAppCountAggregateOutputType = {
    id: number
    title: number
    description: number
    web_image: number
    mobile_image: number
    orden: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TutorialStepsAppAvgAggregateInputType = {
    orden?: true
  }

  export type TutorialStepsAppSumAggregateInputType = {
    orden?: true
  }

  export type TutorialStepsAppMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    web_image?: true
    mobile_image?: true
    orden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TutorialStepsAppMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    web_image?: true
    mobile_image?: true
    orden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TutorialStepsAppCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    web_image?: true
    mobile_image?: true
    orden?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TutorialStepsAppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorialStepsApp to aggregate.
     */
    where?: TutorialStepsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorialStepsApps to fetch.
     */
    orderBy?: TutorialStepsAppOrderByWithRelationInput | TutorialStepsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorialStepsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorialStepsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorialStepsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TutorialStepsApps
    **/
    _count?: true | TutorialStepsAppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutorialStepsAppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutorialStepsAppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorialStepsAppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorialStepsAppMaxAggregateInputType
  }

  export type GetTutorialStepsAppAggregateType<T extends TutorialStepsAppAggregateArgs> = {
        [P in keyof T & keyof AggregateTutorialStepsApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutorialStepsApp[P]>
      : GetScalarType<T[P], AggregateTutorialStepsApp[P]>
  }




  export type TutorialStepsAppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialStepsAppWhereInput
    orderBy?: TutorialStepsAppOrderByWithAggregationInput | TutorialStepsAppOrderByWithAggregationInput[]
    by: TutorialStepsAppScalarFieldEnum[] | TutorialStepsAppScalarFieldEnum
    having?: TutorialStepsAppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorialStepsAppCountAggregateInputType | true
    _avg?: TutorialStepsAppAvgAggregateInputType
    _sum?: TutorialStepsAppSumAggregateInputType
    _min?: TutorialStepsAppMinAggregateInputType
    _max?: TutorialStepsAppMaxAggregateInputType
  }

  export type TutorialStepsAppGroupByOutputType = {
    id: string
    title: string
    description: string
    web_image: string
    mobile_image: string
    orden: number
    createdAt: Date
    updatedAt: Date
    _count: TutorialStepsAppCountAggregateOutputType | null
    _avg: TutorialStepsAppAvgAggregateOutputType | null
    _sum: TutorialStepsAppSumAggregateOutputType | null
    _min: TutorialStepsAppMinAggregateOutputType | null
    _max: TutorialStepsAppMaxAggregateOutputType | null
  }

  type GetTutorialStepsAppGroupByPayload<T extends TutorialStepsAppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorialStepsAppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorialStepsAppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorialStepsAppGroupByOutputType[P]>
            : GetScalarType<T[P], TutorialStepsAppGroupByOutputType[P]>
        }
      >
    >


  export type TutorialStepsAppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    web_image?: boolean
    mobile_image?: boolean
    orden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tutorialStepsApp"]>


  export type TutorialStepsAppSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    web_image?: boolean
    mobile_image?: boolean
    orden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TutorialStepsAppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TutorialStepsApp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      web_image: string
      mobile_image: string
      orden: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tutorialStepsApp"]>
    composites: {}
  }

  type TutorialStepsAppGetPayload<S extends boolean | null | undefined | TutorialStepsAppDefaultArgs> = $Result.GetResult<Prisma.$TutorialStepsAppPayload, S>

  type TutorialStepsAppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TutorialStepsAppFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TutorialStepsAppCountAggregateInputType | true
    }

  export interface TutorialStepsAppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TutorialStepsApp'], meta: { name: 'TutorialStepsApp' } }
    /**
     * Find zero or one TutorialStepsApp that matches the filter.
     * @param {TutorialStepsAppFindUniqueArgs} args - Arguments to find a TutorialStepsApp
     * @example
     * // Get one TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutorialStepsAppFindUniqueArgs>(args: SelectSubset<T, TutorialStepsAppFindUniqueArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TutorialStepsApp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TutorialStepsAppFindUniqueOrThrowArgs} args - Arguments to find a TutorialStepsApp
     * @example
     * // Get one TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutorialStepsAppFindUniqueOrThrowArgs>(args: SelectSubset<T, TutorialStepsAppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TutorialStepsApp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppFindFirstArgs} args - Arguments to find a TutorialStepsApp
     * @example
     * // Get one TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutorialStepsAppFindFirstArgs>(args?: SelectSubset<T, TutorialStepsAppFindFirstArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TutorialStepsApp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppFindFirstOrThrowArgs} args - Arguments to find a TutorialStepsApp
     * @example
     * // Get one TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutorialStepsAppFindFirstOrThrowArgs>(args?: SelectSubset<T, TutorialStepsAppFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TutorialStepsApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TutorialStepsApps
     * const tutorialStepsApps = await prisma.tutorialStepsApp.findMany()
     * 
     * // Get first 10 TutorialStepsApps
     * const tutorialStepsApps = await prisma.tutorialStepsApp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorialStepsAppWithIdOnly = await prisma.tutorialStepsApp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutorialStepsAppFindManyArgs>(args?: SelectSubset<T, TutorialStepsAppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TutorialStepsApp.
     * @param {TutorialStepsAppCreateArgs} args - Arguments to create a TutorialStepsApp.
     * @example
     * // Create one TutorialStepsApp
     * const TutorialStepsApp = await prisma.tutorialStepsApp.create({
     *   data: {
     *     // ... data to create a TutorialStepsApp
     *   }
     * })
     * 
     */
    create<T extends TutorialStepsAppCreateArgs>(args: SelectSubset<T, TutorialStepsAppCreateArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TutorialStepsApps.
     * @param {TutorialStepsAppCreateManyArgs} args - Arguments to create many TutorialStepsApps.
     * @example
     * // Create many TutorialStepsApps
     * const tutorialStepsApp = await prisma.tutorialStepsApp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutorialStepsAppCreateManyArgs>(args?: SelectSubset<T, TutorialStepsAppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TutorialStepsApp.
     * @param {TutorialStepsAppDeleteArgs} args - Arguments to delete one TutorialStepsApp.
     * @example
     * // Delete one TutorialStepsApp
     * const TutorialStepsApp = await prisma.tutorialStepsApp.delete({
     *   where: {
     *     // ... filter to delete one TutorialStepsApp
     *   }
     * })
     * 
     */
    delete<T extends TutorialStepsAppDeleteArgs>(args: SelectSubset<T, TutorialStepsAppDeleteArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TutorialStepsApp.
     * @param {TutorialStepsAppUpdateArgs} args - Arguments to update one TutorialStepsApp.
     * @example
     * // Update one TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutorialStepsAppUpdateArgs>(args: SelectSubset<T, TutorialStepsAppUpdateArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TutorialStepsApps.
     * @param {TutorialStepsAppDeleteManyArgs} args - Arguments to filter TutorialStepsApps to delete.
     * @example
     * // Delete a few TutorialStepsApps
     * const { count } = await prisma.tutorialStepsApp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutorialStepsAppDeleteManyArgs>(args?: SelectSubset<T, TutorialStepsAppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TutorialStepsApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TutorialStepsApps
     * const tutorialStepsApp = await prisma.tutorialStepsApp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutorialStepsAppUpdateManyArgs>(args: SelectSubset<T, TutorialStepsAppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TutorialStepsApp.
     * @param {TutorialStepsAppUpsertArgs} args - Arguments to update or create a TutorialStepsApp.
     * @example
     * // Update or create a TutorialStepsApp
     * const tutorialStepsApp = await prisma.tutorialStepsApp.upsert({
     *   create: {
     *     // ... data to create a TutorialStepsApp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TutorialStepsApp we want to update
     *   }
     * })
     */
    upsert<T extends TutorialStepsAppUpsertArgs>(args: SelectSubset<T, TutorialStepsAppUpsertArgs<ExtArgs>>): Prisma__TutorialStepsAppClient<$Result.GetResult<Prisma.$TutorialStepsAppPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TutorialStepsApps that matches the filter.
     * @param {TutorialStepsAppFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tutorialStepsApp = await prisma.tutorialStepsApp.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TutorialStepsAppFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TutorialStepsApp.
     * @param {TutorialStepsAppAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tutorialStepsApp = await prisma.tutorialStepsApp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TutorialStepsAppAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TutorialStepsApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppCountArgs} args - Arguments to filter TutorialStepsApps to count.
     * @example
     * // Count the number of TutorialStepsApps
     * const count = await prisma.tutorialStepsApp.count({
     *   where: {
     *     // ... the filter for the TutorialStepsApps we want to count
     *   }
     * })
    **/
    count<T extends TutorialStepsAppCountArgs>(
      args?: Subset<T, TutorialStepsAppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorialStepsAppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TutorialStepsApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorialStepsAppAggregateArgs>(args: Subset<T, TutorialStepsAppAggregateArgs>): Prisma.PrismaPromise<GetTutorialStepsAppAggregateType<T>>

    /**
     * Group by TutorialStepsApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialStepsAppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorialStepsAppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorialStepsAppGroupByArgs['orderBy'] }
        : { orderBy?: TutorialStepsAppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorialStepsAppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorialStepsAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TutorialStepsApp model
   */
  readonly fields: TutorialStepsAppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TutorialStepsApp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorialStepsAppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TutorialStepsApp model
   */ 
  interface TutorialStepsAppFieldRefs {
    readonly id: FieldRef<"TutorialStepsApp", 'String'>
    readonly title: FieldRef<"TutorialStepsApp", 'String'>
    readonly description: FieldRef<"TutorialStepsApp", 'String'>
    readonly web_image: FieldRef<"TutorialStepsApp", 'String'>
    readonly mobile_image: FieldRef<"TutorialStepsApp", 'String'>
    readonly orden: FieldRef<"TutorialStepsApp", 'Int'>
    readonly createdAt: FieldRef<"TutorialStepsApp", 'DateTime'>
    readonly updatedAt: FieldRef<"TutorialStepsApp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TutorialStepsApp findUnique
   */
  export type TutorialStepsAppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter, which TutorialStepsApp to fetch.
     */
    where: TutorialStepsAppWhereUniqueInput
  }

  /**
   * TutorialStepsApp findUniqueOrThrow
   */
  export type TutorialStepsAppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter, which TutorialStepsApp to fetch.
     */
    where: TutorialStepsAppWhereUniqueInput
  }

  /**
   * TutorialStepsApp findFirst
   */
  export type TutorialStepsAppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter, which TutorialStepsApp to fetch.
     */
    where?: TutorialStepsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorialStepsApps to fetch.
     */
    orderBy?: TutorialStepsAppOrderByWithRelationInput | TutorialStepsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorialStepsApps.
     */
    cursor?: TutorialStepsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorialStepsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorialStepsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorialStepsApps.
     */
    distinct?: TutorialStepsAppScalarFieldEnum | TutorialStepsAppScalarFieldEnum[]
  }

  /**
   * TutorialStepsApp findFirstOrThrow
   */
  export type TutorialStepsAppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter, which TutorialStepsApp to fetch.
     */
    where?: TutorialStepsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorialStepsApps to fetch.
     */
    orderBy?: TutorialStepsAppOrderByWithRelationInput | TutorialStepsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TutorialStepsApps.
     */
    cursor?: TutorialStepsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorialStepsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorialStepsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TutorialStepsApps.
     */
    distinct?: TutorialStepsAppScalarFieldEnum | TutorialStepsAppScalarFieldEnum[]
  }

  /**
   * TutorialStepsApp findMany
   */
  export type TutorialStepsAppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter, which TutorialStepsApps to fetch.
     */
    where?: TutorialStepsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TutorialStepsApps to fetch.
     */
    orderBy?: TutorialStepsAppOrderByWithRelationInput | TutorialStepsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TutorialStepsApps.
     */
    cursor?: TutorialStepsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TutorialStepsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TutorialStepsApps.
     */
    skip?: number
    distinct?: TutorialStepsAppScalarFieldEnum | TutorialStepsAppScalarFieldEnum[]
  }

  /**
   * TutorialStepsApp create
   */
  export type TutorialStepsAppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * The data needed to create a TutorialStepsApp.
     */
    data: XOR<TutorialStepsAppCreateInput, TutorialStepsAppUncheckedCreateInput>
  }

  /**
   * TutorialStepsApp createMany
   */
  export type TutorialStepsAppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TutorialStepsApps.
     */
    data: TutorialStepsAppCreateManyInput | TutorialStepsAppCreateManyInput[]
  }

  /**
   * TutorialStepsApp update
   */
  export type TutorialStepsAppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * The data needed to update a TutorialStepsApp.
     */
    data: XOR<TutorialStepsAppUpdateInput, TutorialStepsAppUncheckedUpdateInput>
    /**
     * Choose, which TutorialStepsApp to update.
     */
    where: TutorialStepsAppWhereUniqueInput
  }

  /**
   * TutorialStepsApp updateMany
   */
  export type TutorialStepsAppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TutorialStepsApps.
     */
    data: XOR<TutorialStepsAppUpdateManyMutationInput, TutorialStepsAppUncheckedUpdateManyInput>
    /**
     * Filter which TutorialStepsApps to update
     */
    where?: TutorialStepsAppWhereInput
  }

  /**
   * TutorialStepsApp upsert
   */
  export type TutorialStepsAppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * The filter to search for the TutorialStepsApp to update in case it exists.
     */
    where: TutorialStepsAppWhereUniqueInput
    /**
     * In case the TutorialStepsApp found by the `where` argument doesn't exist, create a new TutorialStepsApp with this data.
     */
    create: XOR<TutorialStepsAppCreateInput, TutorialStepsAppUncheckedCreateInput>
    /**
     * In case the TutorialStepsApp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorialStepsAppUpdateInput, TutorialStepsAppUncheckedUpdateInput>
  }

  /**
   * TutorialStepsApp delete
   */
  export type TutorialStepsAppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
    /**
     * Filter which TutorialStepsApp to delete.
     */
    where: TutorialStepsAppWhereUniqueInput
  }

  /**
   * TutorialStepsApp deleteMany
   */
  export type TutorialStepsAppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TutorialStepsApps to delete
     */
    where?: TutorialStepsAppWhereInput
  }

  /**
   * TutorialStepsApp findRaw
   */
  export type TutorialStepsAppFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TutorialStepsApp aggregateRaw
   */
  export type TutorialStepsAppAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TutorialStepsApp without action
   */
  export type TutorialStepsAppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialStepsApp
     */
    select?: TutorialStepsAppSelect<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tags"]>


  export type TagsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * @param {TagsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tags = await prisma.tags.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TagsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tags.
     * @param {TagsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tags = await prisma.tags.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */ 
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly name: FieldRef<"Tags", 'String'>
    readonly createdAt: FieldRef<"Tags", 'DateTime'>
    readonly updatedAt: FieldRef<"Tags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
  }

  /**
   * Tags findRaw
   */
  export type TagsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tags aggregateRaw
   */
  export type TagsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
  }


  /**
   * Model Tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    radius: number | null
    breweryCount: number | null
    days: number | null
  }

  export type TourSumAggregateOutputType = {
    radius: number | null
    breweryCount: number | null
    days: number | null
  }

  export type TourMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    userId: string | null
    cityId: string | null
    radius: number | null
    startDate: Date | null
    breweryCount: number | null
    days: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    userId: string | null
    cityId: string | null
    radius: number | null
    startDate: Date | null
    breweryCount: number | null
    days: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    userId: number
    cityId: number
    radius: number
    startDate: number
    breweryCount: number
    days: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    radius?: true
    breweryCount?: true
    days?: true
  }

  export type TourSumAggregateInputType = {
    radius?: true
    breweryCount?: true
    days?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    userId?: true
    cityId?: true
    radius?: true
    startDate?: true
    breweryCount?: true
    days?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    userId?: true
    cityId?: true
    radius?: true
    startDate?: true
    breweryCount?: true
    days?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    userId?: true
    cityId?: true
    radius?: true
    startDate?: true
    breweryCount?: true
    days?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
    orderBy?: TourOrderByWithAggregationInput | TourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    userId: string
    cityId: string
    radius: number
    startDate: Date
    breweryCount: number
    days: number
    createdAt: Date
    updatedAt: Date
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    userId?: boolean
    cityId?: boolean
    radius?: boolean
    startDate?: boolean
    breweryCount?: boolean
    days?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    breweries?: boolean | Tour$breweriesArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>


  export type TourSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    userId?: boolean
    cityId?: boolean
    radius?: boolean
    startDate?: boolean
    breweryCount?: boolean
    days?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    breweries?: boolean | Tour$breweriesArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tour"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      breweries: Prisma.$TourBreweryPayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      userId: string
      cityId: string
      radius: number
      startDate: Date
      breweryCount: number
      days: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type TourGetPayload<S extends boolean | null | undefined | TourDefaultArgs> = $Result.GetResult<Prisma.$TourPayload, S>

  type TourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tour'], meta: { name: 'Tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFindUniqueArgs>(args: SelectSubset<T, TourFindUniqueArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFindFirstArgs>(args?: SelectSubset<T, TourFindFirstArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFindManyArgs>(args?: SelectSubset<T, TourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends TourCreateArgs>(args: SelectSubset<T, TourCreateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tours.
     * @param {TourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCreateManyArgs>(args?: SelectSubset<T, TourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends TourDeleteArgs>(args: SelectSubset<T, TourDeleteArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourUpdateArgs>(args: SelectSubset<T, TourUpdateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourDeleteManyArgs>(args?: SelectSubset<T, TourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourUpdateManyArgs>(args: SelectSubset<T, TourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends TourUpsertArgs>(args: SelectSubset<T, TourUpsertArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tours that matches the filter.
     * @param {TourFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tour = await prisma.tour.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TourFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tour.
     * @param {TourAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tour = await prisma.tour.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TourAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tour model
   */
  readonly fields: TourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    breweries<T extends Tour$breweriesArgs<ExtArgs> = {}>(args?: Subset<T, Tour$breweriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findMany"> | Null>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tour model
   */ 
  interface TourFieldRefs {
    readonly id: FieldRef<"Tour", 'String'>
    readonly name: FieldRef<"Tour", 'String'>
    readonly description: FieldRef<"Tour", 'String'>
    readonly image: FieldRef<"Tour", 'String'>
    readonly userId: FieldRef<"Tour", 'String'>
    readonly cityId: FieldRef<"Tour", 'String'>
    readonly radius: FieldRef<"Tour", 'Float'>
    readonly startDate: FieldRef<"Tour", 'DateTime'>
    readonly breweryCount: FieldRef<"Tour", 'Int'>
    readonly days: FieldRef<"Tour", 'Int'>
    readonly createdAt: FieldRef<"Tour", 'DateTime'>
    readonly updatedAt: FieldRef<"Tour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tour findUnique
   */
  export type TourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findFirst
   */
  export type TourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findMany
   */
  export type TourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour create
   */
  export type TourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
  }

  /**
   * Tour createMany
   */
  export type TourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
  }

  /**
   * Tour update
   */
  export type TourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
  }

  /**
   * Tour upsert
   */
  export type TourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
  }

  /**
   * Tour delete
   */
  export type TourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
  }

  /**
   * Tour findRaw
   */
  export type TourFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tour aggregateRaw
   */
  export type TourAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tour.breweries
   */
  export type Tour$breweriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    where?: TourBreweryWhereInput
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    cursor?: TourBreweryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourBreweryScalarFieldEnum | TourBreweryScalarFieldEnum[]
  }

  /**
   * Tour without action
   */
  export type TourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
  }


  /**
   * Model TourBrewery
   */

  export type AggregateTourBrewery = {
    _count: TourBreweryCountAggregateOutputType | null
    _avg: TourBreweryAvgAggregateOutputType | null
    _sum: TourBrewerySumAggregateOutputType | null
    _min: TourBreweryMinAggregateOutputType | null
    _max: TourBreweryMaxAggregateOutputType | null
  }

  export type TourBreweryAvgAggregateOutputType = {
    distance: number | null
  }

  export type TourBrewerySumAggregateOutputType = {
    distance: number | null
  }

  export type TourBreweryMinAggregateOutputType = {
    id: string | null
    tourId: string | null
    breweryId: string | null
    distance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourBreweryMaxAggregateOutputType = {
    id: string | null
    tourId: string | null
    breweryId: string | null
    distance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourBreweryCountAggregateOutputType = {
    id: number
    tourId: number
    breweryId: number
    distance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourBreweryAvgAggregateInputType = {
    distance?: true
  }

  export type TourBrewerySumAggregateInputType = {
    distance?: true
  }

  export type TourBreweryMinAggregateInputType = {
    id?: true
    tourId?: true
    breweryId?: true
    distance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourBreweryMaxAggregateInputType = {
    id?: true
    tourId?: true
    breweryId?: true
    distance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourBreweryCountAggregateInputType = {
    id?: true
    tourId?: true
    breweryId?: true
    distance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourBreweryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourBrewery to aggregate.
     */
    where?: TourBreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBreweries to fetch.
     */
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourBreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBreweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBreweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourBreweries
    **/
    _count?: true | TourBreweryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourBreweryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourBrewerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourBreweryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourBreweryMaxAggregateInputType
  }

  export type GetTourBreweryAggregateType<T extends TourBreweryAggregateArgs> = {
        [P in keyof T & keyof AggregateTourBrewery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourBrewery[P]>
      : GetScalarType<T[P], AggregateTourBrewery[P]>
  }




  export type TourBreweryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourBreweryWhereInput
    orderBy?: TourBreweryOrderByWithAggregationInput | TourBreweryOrderByWithAggregationInput[]
    by: TourBreweryScalarFieldEnum[] | TourBreweryScalarFieldEnum
    having?: TourBreweryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourBreweryCountAggregateInputType | true
    _avg?: TourBreweryAvgAggregateInputType
    _sum?: TourBrewerySumAggregateInputType
    _min?: TourBreweryMinAggregateInputType
    _max?: TourBreweryMaxAggregateInputType
  }

  export type TourBreweryGroupByOutputType = {
    id: string
    tourId: string
    breweryId: string | null
    distance: number
    createdAt: Date
    updatedAt: Date
    _count: TourBreweryCountAggregateOutputType | null
    _avg: TourBreweryAvgAggregateOutputType | null
    _sum: TourBrewerySumAggregateOutputType | null
    _min: TourBreweryMinAggregateOutputType | null
    _max: TourBreweryMaxAggregateOutputType | null
  }

  type GetTourBreweryGroupByPayload<T extends TourBreweryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourBreweryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourBreweryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourBreweryGroupByOutputType[P]>
            : GetScalarType<T[P], TourBreweryGroupByOutputType[P]>
        }
      >
    >


  export type TourBrewerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    breweryId?: boolean
    distance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    brewery?: boolean | TourBrewery$breweryArgs<ExtArgs>
  }, ExtArgs["result"]["tourBrewery"]>


  export type TourBrewerySelectScalar = {
    id?: boolean
    tourId?: boolean
    breweryId?: boolean
    distance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourBreweryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    brewery?: boolean | TourBrewery$breweryArgs<ExtArgs>
  }

  export type $TourBreweryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourBrewery"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      brewery: Prisma.$BreweryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tourId: string
      breweryId: string | null
      distance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tourBrewery"]>
    composites: {}
  }

  type TourBreweryGetPayload<S extends boolean | null | undefined | TourBreweryDefaultArgs> = $Result.GetResult<Prisma.$TourBreweryPayload, S>

  type TourBreweryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourBreweryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourBreweryCountAggregateInputType | true
    }

  export interface TourBreweryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourBrewery'], meta: { name: 'TourBrewery' } }
    /**
     * Find zero or one TourBrewery that matches the filter.
     * @param {TourBreweryFindUniqueArgs} args - Arguments to find a TourBrewery
     * @example
     * // Get one TourBrewery
     * const tourBrewery = await prisma.tourBrewery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourBreweryFindUniqueArgs>(args: SelectSubset<T, TourBreweryFindUniqueArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourBrewery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourBreweryFindUniqueOrThrowArgs} args - Arguments to find a TourBrewery
     * @example
     * // Get one TourBrewery
     * const tourBrewery = await prisma.tourBrewery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourBreweryFindUniqueOrThrowArgs>(args: SelectSubset<T, TourBreweryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourBrewery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryFindFirstArgs} args - Arguments to find a TourBrewery
     * @example
     * // Get one TourBrewery
     * const tourBrewery = await prisma.tourBrewery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourBreweryFindFirstArgs>(args?: SelectSubset<T, TourBreweryFindFirstArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourBrewery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryFindFirstOrThrowArgs} args - Arguments to find a TourBrewery
     * @example
     * // Get one TourBrewery
     * const tourBrewery = await prisma.tourBrewery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourBreweryFindFirstOrThrowArgs>(args?: SelectSubset<T, TourBreweryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourBreweries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourBreweries
     * const tourBreweries = await prisma.tourBrewery.findMany()
     * 
     * // Get first 10 TourBreweries
     * const tourBreweries = await prisma.tourBrewery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourBreweryWithIdOnly = await prisma.tourBrewery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourBreweryFindManyArgs>(args?: SelectSubset<T, TourBreweryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourBrewery.
     * @param {TourBreweryCreateArgs} args - Arguments to create a TourBrewery.
     * @example
     * // Create one TourBrewery
     * const TourBrewery = await prisma.tourBrewery.create({
     *   data: {
     *     // ... data to create a TourBrewery
     *   }
     * })
     * 
     */
    create<T extends TourBreweryCreateArgs>(args: SelectSubset<T, TourBreweryCreateArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourBreweries.
     * @param {TourBreweryCreateManyArgs} args - Arguments to create many TourBreweries.
     * @example
     * // Create many TourBreweries
     * const tourBrewery = await prisma.tourBrewery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourBreweryCreateManyArgs>(args?: SelectSubset<T, TourBreweryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TourBrewery.
     * @param {TourBreweryDeleteArgs} args - Arguments to delete one TourBrewery.
     * @example
     * // Delete one TourBrewery
     * const TourBrewery = await prisma.tourBrewery.delete({
     *   where: {
     *     // ... filter to delete one TourBrewery
     *   }
     * })
     * 
     */
    delete<T extends TourBreweryDeleteArgs>(args: SelectSubset<T, TourBreweryDeleteArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourBrewery.
     * @param {TourBreweryUpdateArgs} args - Arguments to update one TourBrewery.
     * @example
     * // Update one TourBrewery
     * const tourBrewery = await prisma.tourBrewery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourBreweryUpdateArgs>(args: SelectSubset<T, TourBreweryUpdateArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourBreweries.
     * @param {TourBreweryDeleteManyArgs} args - Arguments to filter TourBreweries to delete.
     * @example
     * // Delete a few TourBreweries
     * const { count } = await prisma.tourBrewery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourBreweryDeleteManyArgs>(args?: SelectSubset<T, TourBreweryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourBreweries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourBreweries
     * const tourBrewery = await prisma.tourBrewery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourBreweryUpdateManyArgs>(args: SelectSubset<T, TourBreweryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourBrewery.
     * @param {TourBreweryUpsertArgs} args - Arguments to update or create a TourBrewery.
     * @example
     * // Update or create a TourBrewery
     * const tourBrewery = await prisma.tourBrewery.upsert({
     *   create: {
     *     // ... data to create a TourBrewery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourBrewery we want to update
     *   }
     * })
     */
    upsert<T extends TourBreweryUpsertArgs>(args: SelectSubset<T, TourBreweryUpsertArgs<ExtArgs>>): Prisma__TourBreweryClient<$Result.GetResult<Prisma.$TourBreweryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TourBreweries that matches the filter.
     * @param {TourBreweryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tourBrewery = await prisma.tourBrewery.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TourBreweryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TourBrewery.
     * @param {TourBreweryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tourBrewery = await prisma.tourBrewery.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TourBreweryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TourBreweries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryCountArgs} args - Arguments to filter TourBreweries to count.
     * @example
     * // Count the number of TourBreweries
     * const count = await prisma.tourBrewery.count({
     *   where: {
     *     // ... the filter for the TourBreweries we want to count
     *   }
     * })
    **/
    count<T extends TourBreweryCountArgs>(
      args?: Subset<T, TourBreweryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourBreweryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourBrewery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourBreweryAggregateArgs>(args: Subset<T, TourBreweryAggregateArgs>): Prisma.PrismaPromise<GetTourBreweryAggregateType<T>>

    /**
     * Group by TourBrewery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourBreweryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourBreweryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourBreweryGroupByArgs['orderBy'] }
        : { orderBy?: TourBreweryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourBreweryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourBreweryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourBrewery model
   */
  readonly fields: TourBreweryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourBrewery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourBreweryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brewery<T extends TourBrewery$breweryArgs<ExtArgs> = {}>(args?: Subset<T, TourBrewery$breweryArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourBrewery model
   */ 
  interface TourBreweryFieldRefs {
    readonly id: FieldRef<"TourBrewery", 'String'>
    readonly tourId: FieldRef<"TourBrewery", 'String'>
    readonly breweryId: FieldRef<"TourBrewery", 'String'>
    readonly distance: FieldRef<"TourBrewery", 'Float'>
    readonly createdAt: FieldRef<"TourBrewery", 'DateTime'>
    readonly updatedAt: FieldRef<"TourBrewery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TourBrewery findUnique
   */
  export type TourBreweryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter, which TourBrewery to fetch.
     */
    where: TourBreweryWhereUniqueInput
  }

  /**
   * TourBrewery findUniqueOrThrow
   */
  export type TourBreweryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter, which TourBrewery to fetch.
     */
    where: TourBreweryWhereUniqueInput
  }

  /**
   * TourBrewery findFirst
   */
  export type TourBreweryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter, which TourBrewery to fetch.
     */
    where?: TourBreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBreweries to fetch.
     */
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourBreweries.
     */
    cursor?: TourBreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBreweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBreweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourBreweries.
     */
    distinct?: TourBreweryScalarFieldEnum | TourBreweryScalarFieldEnum[]
  }

  /**
   * TourBrewery findFirstOrThrow
   */
  export type TourBreweryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter, which TourBrewery to fetch.
     */
    where?: TourBreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBreweries to fetch.
     */
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourBreweries.
     */
    cursor?: TourBreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBreweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBreweries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourBreweries.
     */
    distinct?: TourBreweryScalarFieldEnum | TourBreweryScalarFieldEnum[]
  }

  /**
   * TourBrewery findMany
   */
  export type TourBreweryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter, which TourBreweries to fetch.
     */
    where?: TourBreweryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourBreweries to fetch.
     */
    orderBy?: TourBreweryOrderByWithRelationInput | TourBreweryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourBreweries.
     */
    cursor?: TourBreweryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourBreweries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourBreweries.
     */
    skip?: number
    distinct?: TourBreweryScalarFieldEnum | TourBreweryScalarFieldEnum[]
  }

  /**
   * TourBrewery create
   */
  export type TourBreweryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * The data needed to create a TourBrewery.
     */
    data: XOR<TourBreweryCreateInput, TourBreweryUncheckedCreateInput>
  }

  /**
   * TourBrewery createMany
   */
  export type TourBreweryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourBreweries.
     */
    data: TourBreweryCreateManyInput | TourBreweryCreateManyInput[]
  }

  /**
   * TourBrewery update
   */
  export type TourBreweryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * The data needed to update a TourBrewery.
     */
    data: XOR<TourBreweryUpdateInput, TourBreweryUncheckedUpdateInput>
    /**
     * Choose, which TourBrewery to update.
     */
    where: TourBreweryWhereUniqueInput
  }

  /**
   * TourBrewery updateMany
   */
  export type TourBreweryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourBreweries.
     */
    data: XOR<TourBreweryUpdateManyMutationInput, TourBreweryUncheckedUpdateManyInput>
    /**
     * Filter which TourBreweries to update
     */
    where?: TourBreweryWhereInput
  }

  /**
   * TourBrewery upsert
   */
  export type TourBreweryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * The filter to search for the TourBrewery to update in case it exists.
     */
    where: TourBreweryWhereUniqueInput
    /**
     * In case the TourBrewery found by the `where` argument doesn't exist, create a new TourBrewery with this data.
     */
    create: XOR<TourBreweryCreateInput, TourBreweryUncheckedCreateInput>
    /**
     * In case the TourBrewery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourBreweryUpdateInput, TourBreweryUncheckedUpdateInput>
  }

  /**
   * TourBrewery delete
   */
  export type TourBreweryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
    /**
     * Filter which TourBrewery to delete.
     */
    where: TourBreweryWhereUniqueInput
  }

  /**
   * TourBrewery deleteMany
   */
  export type TourBreweryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourBreweries to delete
     */
    where?: TourBreweryWhereInput
  }

  /**
   * TourBrewery findRaw
   */
  export type TourBreweryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TourBrewery aggregateRaw
   */
  export type TourBreweryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TourBrewery.brewery
   */
  export type TourBrewery$breweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brewery
     */
    select?: BrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreweryInclude<ExtArgs> | null
    where?: BreweryWhereInput
  }

  /**
   * TourBrewery without action
   */
  export type TourBreweryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourBrewery
     */
    select?: TourBrewerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourBreweryInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    senderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    senderId: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipients: Prisma.$RecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      senderId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipients<T extends Notification$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification.recipients
   */
  export type Notification$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    where?: RecipientWhereInput
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    cursor?: RecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Recipient
   */

  export type AggregateRecipient = {
    _count: RecipientCountAggregateOutputType | null
    _min: RecipientMinAggregateOutputType | null
    _max: RecipientMaxAggregateOutputType | null
  }

  export type RecipientMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipientMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipientCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipientMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipientMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipientCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipient to aggregate.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipients
    **/
    _count?: true | RecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipientMaxAggregateInputType
  }

  export type GetRecipientAggregateType<T extends RecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipient[P]>
      : GetScalarType<T[P], AggregateRecipient[P]>
  }




  export type RecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipientWhereInput
    orderBy?: RecipientOrderByWithAggregationInput | RecipientOrderByWithAggregationInput[]
    by: RecipientScalarFieldEnum[] | RecipientScalarFieldEnum
    having?: RecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipientCountAggregateInputType | true
    _min?: RecipientMinAggregateInputType
    _max?: RecipientMaxAggregateInputType
  }

  export type RecipientGroupByOutputType = {
    id: string
    notificationId: string
    userId: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: RecipientCountAggregateOutputType | null
    _min: RecipientMinAggregateOutputType | null
    _max: RecipientMaxAggregateOutputType | null
  }

  type GetRecipientGroupByPayload<T extends RecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipientGroupByOutputType[P]>
        }
      >
    >


  export type RecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipient"]>


  export type RecipientSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipient"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      userId: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recipient"]>
    composites: {}
  }

  type RecipientGetPayload<S extends boolean | null | undefined | RecipientDefaultArgs> = $Result.GetResult<Prisma.$RecipientPayload, S>

  type RecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipientCountAggregateInputType | true
    }

  export interface RecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipient'], meta: { name: 'Recipient' } }
    /**
     * Find zero or one Recipient that matches the filter.
     * @param {RecipientFindUniqueArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipientFindUniqueArgs>(args: SelectSubset<T, RecipientFindUniqueArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipientFindUniqueOrThrowArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindFirstArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipientFindFirstArgs>(args?: SelectSubset<T, RecipientFindFirstArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindFirstOrThrowArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipients
     * const recipients = await prisma.recipient.findMany()
     * 
     * // Get first 10 Recipients
     * const recipients = await prisma.recipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipientWithIdOnly = await prisma.recipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipientFindManyArgs>(args?: SelectSubset<T, RecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipient.
     * @param {RecipientCreateArgs} args - Arguments to create a Recipient.
     * @example
     * // Create one Recipient
     * const Recipient = await prisma.recipient.create({
     *   data: {
     *     // ... data to create a Recipient
     *   }
     * })
     * 
     */
    create<T extends RecipientCreateArgs>(args: SelectSubset<T, RecipientCreateArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipients.
     * @param {RecipientCreateManyArgs} args - Arguments to create many Recipients.
     * @example
     * // Create many Recipients
     * const recipient = await prisma.recipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipientCreateManyArgs>(args?: SelectSubset<T, RecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recipient.
     * @param {RecipientDeleteArgs} args - Arguments to delete one Recipient.
     * @example
     * // Delete one Recipient
     * const Recipient = await prisma.recipient.delete({
     *   where: {
     *     // ... filter to delete one Recipient
     *   }
     * })
     * 
     */
    delete<T extends RecipientDeleteArgs>(args: SelectSubset<T, RecipientDeleteArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipient.
     * @param {RecipientUpdateArgs} args - Arguments to update one Recipient.
     * @example
     * // Update one Recipient
     * const recipient = await prisma.recipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipientUpdateArgs>(args: SelectSubset<T, RecipientUpdateArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipients.
     * @param {RecipientDeleteManyArgs} args - Arguments to filter Recipients to delete.
     * @example
     * // Delete a few Recipients
     * const { count } = await prisma.recipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipientDeleteManyArgs>(args?: SelectSubset<T, RecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipients
     * const recipient = await prisma.recipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipientUpdateManyArgs>(args: SelectSubset<T, RecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipient.
     * @param {RecipientUpsertArgs} args - Arguments to update or create a Recipient.
     * @example
     * // Update or create a Recipient
     * const recipient = await prisma.recipient.upsert({
     *   create: {
     *     // ... data to create a Recipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipient we want to update
     *   }
     * })
     */
    upsert<T extends RecipientUpsertArgs>(args: SelectSubset<T, RecipientUpsertArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Recipients that matches the filter.
     * @param {RecipientFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const recipient = await prisma.recipient.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: RecipientFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Recipient.
     * @param {RecipientAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const recipient = await prisma.recipient.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RecipientAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientCountArgs} args - Arguments to filter Recipients to count.
     * @example
     * // Count the number of Recipients
     * const count = await prisma.recipient.count({
     *   where: {
     *     // ... the filter for the Recipients we want to count
     *   }
     * })
    **/
    count<T extends RecipientCountArgs>(
      args?: Subset<T, RecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipientAggregateArgs>(args: Subset<T, RecipientAggregateArgs>): Prisma.PrismaPromise<GetRecipientAggregateType<T>>

    /**
     * Group by Recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipientGroupByArgs['orderBy'] }
        : { orderBy?: RecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipient model
   */
  readonly fields: RecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipient model
   */ 
  interface RecipientFieldRefs {
    readonly id: FieldRef<"Recipient", 'String'>
    readonly notificationId: FieldRef<"Recipient", 'String'>
    readonly userId: FieldRef<"Recipient", 'String'>
    readonly read: FieldRef<"Recipient", 'Boolean'>
    readonly createdAt: FieldRef<"Recipient", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipient findUnique
   */
  export type RecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient findUniqueOrThrow
   */
  export type RecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient findFirst
   */
  export type RecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipients.
     */
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient findFirstOrThrow
   */
  export type RecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipients.
     */
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient findMany
   */
  export type RecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter, which Recipients to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient create
   */
  export type RecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipient.
     */
    data: XOR<RecipientCreateInput, RecipientUncheckedCreateInput>
  }

  /**
   * Recipient createMany
   */
  export type RecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipients.
     */
    data: RecipientCreateManyInput | RecipientCreateManyInput[]
  }

  /**
   * Recipient update
   */
  export type RecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipient.
     */
    data: XOR<RecipientUpdateInput, RecipientUncheckedUpdateInput>
    /**
     * Choose, which Recipient to update.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient updateMany
   */
  export type RecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipients.
     */
    data: XOR<RecipientUpdateManyMutationInput, RecipientUncheckedUpdateManyInput>
    /**
     * Filter which Recipients to update
     */
    where?: RecipientWhereInput
  }

  /**
   * Recipient upsert
   */
  export type RecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipient to update in case it exists.
     */
    where: RecipientWhereUniqueInput
    /**
     * In case the Recipient found by the `where` argument doesn't exist, create a new Recipient with this data.
     */
    create: XOR<RecipientCreateInput, RecipientUncheckedCreateInput>
    /**
     * In case the Recipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipientUpdateInput, RecipientUncheckedUpdateInput>
  }

  /**
   * Recipient delete
   */
  export type RecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
    /**
     * Filter which Recipient to delete.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient deleteMany
   */
  export type RecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipients to delete
     */
    where?: RecipientWhereInput
  }

  /**
   * Recipient findRaw
   */
  export type RecipientFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Recipient aggregateRaw
   */
  export type RecipientAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Recipient without action
   */
  export type RecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipientInclude<ExtArgs> | null
  }


  /**
   * Model AdType
   */

  export type AggregateAdType = {
    _count: AdTypeCountAggregateOutputType | null
    _avg: AdTypeAvgAggregateOutputType | null
    _sum: AdTypeSumAggregateOutputType | null
    _min: AdTypeMinAggregateOutputType | null
    _max: AdTypeMaxAggregateOutputType | null
  }

  export type AdTypeAvgAggregateOutputType = {
    limit: number | null
    desktop_width: number | null
    desktop_height: number | null
    mobile_width: number | null
    mobile_height: number | null
    desktop_file_size: number | null
    mobile_file_size: number | null
  }

  export type AdTypeSumAggregateOutputType = {
    limit: number | null
    desktop_width: number | null
    desktop_height: number | null
    mobile_width: number | null
    mobile_height: number | null
    desktop_file_size: number | null
    mobile_file_size: number | null
  }

  export type AdTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    limit: number | null
    desktop_width: number | null
    desktop_height: number | null
    mobile_width: number | null
    mobile_height: number | null
    desktop_file_size: number | null
    mobile_file_size: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    limit: number | null
    desktop_width: number | null
    desktop_height: number | null
    mobile_width: number | null
    mobile_height: number | null
    desktop_file_size: number | null
    mobile_file_size: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdTypeAvgAggregateInputType = {
    limit?: true
    desktop_width?: true
    desktop_height?: true
    mobile_width?: true
    mobile_height?: true
    desktop_file_size?: true
    mobile_file_size?: true
  }

  export type AdTypeSumAggregateInputType = {
    limit?: true
    desktop_width?: true
    desktop_height?: true
    mobile_width?: true
    mobile_height?: true
    desktop_file_size?: true
    mobile_file_size?: true
  }

  export type AdTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    limit?: true
    desktop_width?: true
    desktop_height?: true
    mobile_width?: true
    mobile_height?: true
    desktop_file_size?: true
    mobile_file_size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    limit?: true
    desktop_width?: true
    desktop_height?: true
    mobile_width?: true
    mobile_height?: true
    desktop_file_size?: true
    mobile_file_size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    limit?: true
    desktop_width?: true
    desktop_height?: true
    mobile_width?: true
    mobile_height?: true
    desktop_file_size?: true
    mobile_file_size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdType to aggregate.
     */
    where?: AdTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdTypes to fetch.
     */
    orderBy?: AdTypeOrderByWithRelationInput | AdTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdTypes
    **/
    _count?: true | AdTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdTypeMaxAggregateInputType
  }

  export type GetAdTypeAggregateType<T extends AdTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAdType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdType[P]>
      : GetScalarType<T[P], AggregateAdType[P]>
  }




  export type AdTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdTypeWhereInput
    orderBy?: AdTypeOrderByWithAggregationInput | AdTypeOrderByWithAggregationInput[]
    by: AdTypeScalarFieldEnum[] | AdTypeScalarFieldEnum
    having?: AdTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdTypeCountAggregateInputType | true
    _avg?: AdTypeAvgAggregateInputType
    _sum?: AdTypeSumAggregateInputType
    _min?: AdTypeMinAggregateInputType
    _max?: AdTypeMaxAggregateInputType
  }

  export type AdTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: AdTypeCountAggregateOutputType | null
    _avg: AdTypeAvgAggregateOutputType | null
    _sum: AdTypeSumAggregateOutputType | null
    _min: AdTypeMinAggregateOutputType | null
    _max: AdTypeMaxAggregateOutputType | null
  }

  type GetAdTypeGroupByPayload<T extends AdTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AdTypeGroupByOutputType[P]>
        }
      >
    >


  export type AdTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    limit?: boolean
    desktop_width?: boolean
    desktop_height?: boolean
    mobile_width?: boolean
    mobile_height?: boolean
    desktop_file_size?: boolean
    mobile_file_size?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AdRates?: boolean | AdType$AdRatesArgs<ExtArgs>
    Ad?: boolean | AdType$AdArgs<ExtArgs>
    _count?: boolean | AdTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adType"]>


  export type AdTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    limit?: boolean
    desktop_width?: boolean
    desktop_height?: boolean
    mobile_width?: boolean
    mobile_height?: boolean
    desktop_file_size?: boolean
    mobile_file_size?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdRates?: boolean | AdType$AdRatesArgs<ExtArgs>
    Ad?: boolean | AdType$AdArgs<ExtArgs>
    _count?: boolean | AdTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdType"
    objects: {
      AdRates: Prisma.$AdRatesPayload<ExtArgs>[]
      Ad: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      limit: number
      desktop_width: number
      desktop_height: number
      mobile_width: number
      mobile_height: number
      desktop_file_size: number
      mobile_file_size: number
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adType"]>
    composites: {}
  }

  type AdTypeGetPayload<S extends boolean | null | undefined | AdTypeDefaultArgs> = $Result.GetResult<Prisma.$AdTypePayload, S>

  type AdTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdTypeCountAggregateInputType | true
    }

  export interface AdTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdType'], meta: { name: 'AdType' } }
    /**
     * Find zero or one AdType that matches the filter.
     * @param {AdTypeFindUniqueArgs} args - Arguments to find a AdType
     * @example
     * // Get one AdType
     * const adType = await prisma.adType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdTypeFindUniqueArgs>(args: SelectSubset<T, AdTypeFindUniqueArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdTypeFindUniqueOrThrowArgs} args - Arguments to find a AdType
     * @example
     * // Get one AdType
     * const adType = await prisma.adType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AdTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeFindFirstArgs} args - Arguments to find a AdType
     * @example
     * // Get one AdType
     * const adType = await prisma.adType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdTypeFindFirstArgs>(args?: SelectSubset<T, AdTypeFindFirstArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeFindFirstOrThrowArgs} args - Arguments to find a AdType
     * @example
     * // Get one AdType
     * const adType = await prisma.adType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AdTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdTypes
     * const adTypes = await prisma.adType.findMany()
     * 
     * // Get first 10 AdTypes
     * const adTypes = await prisma.adType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adTypeWithIdOnly = await prisma.adType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdTypeFindManyArgs>(args?: SelectSubset<T, AdTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdType.
     * @param {AdTypeCreateArgs} args - Arguments to create a AdType.
     * @example
     * // Create one AdType
     * const AdType = await prisma.adType.create({
     *   data: {
     *     // ... data to create a AdType
     *   }
     * })
     * 
     */
    create<T extends AdTypeCreateArgs>(args: SelectSubset<T, AdTypeCreateArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdTypes.
     * @param {AdTypeCreateManyArgs} args - Arguments to create many AdTypes.
     * @example
     * // Create many AdTypes
     * const adType = await prisma.adType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdTypeCreateManyArgs>(args?: SelectSubset<T, AdTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdType.
     * @param {AdTypeDeleteArgs} args - Arguments to delete one AdType.
     * @example
     * // Delete one AdType
     * const AdType = await prisma.adType.delete({
     *   where: {
     *     // ... filter to delete one AdType
     *   }
     * })
     * 
     */
    delete<T extends AdTypeDeleteArgs>(args: SelectSubset<T, AdTypeDeleteArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdType.
     * @param {AdTypeUpdateArgs} args - Arguments to update one AdType.
     * @example
     * // Update one AdType
     * const adType = await prisma.adType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdTypeUpdateArgs>(args: SelectSubset<T, AdTypeUpdateArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdTypes.
     * @param {AdTypeDeleteManyArgs} args - Arguments to filter AdTypes to delete.
     * @example
     * // Delete a few AdTypes
     * const { count } = await prisma.adType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdTypeDeleteManyArgs>(args?: SelectSubset<T, AdTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdTypes
     * const adType = await prisma.adType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdTypeUpdateManyArgs>(args: SelectSubset<T, AdTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdType.
     * @param {AdTypeUpsertArgs} args - Arguments to update or create a AdType.
     * @example
     * // Update or create a AdType
     * const adType = await prisma.adType.upsert({
     *   create: {
     *     // ... data to create a AdType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdType we want to update
     *   }
     * })
     */
    upsert<T extends AdTypeUpsertArgs>(args: SelectSubset<T, AdTypeUpsertArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AdTypes that matches the filter.
     * @param {AdTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const adType = await prisma.adType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AdTypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AdType.
     * @param {AdTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const adType = await prisma.adType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdTypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AdTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeCountArgs} args - Arguments to filter AdTypes to count.
     * @example
     * // Count the number of AdTypes
     * const count = await prisma.adType.count({
     *   where: {
     *     // ... the filter for the AdTypes we want to count
     *   }
     * })
    **/
    count<T extends AdTypeCountArgs>(
      args?: Subset<T, AdTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdTypeAggregateArgs>(args: Subset<T, AdTypeAggregateArgs>): Prisma.PrismaPromise<GetAdTypeAggregateType<T>>

    /**
     * Group by AdType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdTypeGroupByArgs['orderBy'] }
        : { orderBy?: AdTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdType model
   */
  readonly fields: AdTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AdRates<T extends AdType$AdRatesArgs<ExtArgs> = {}>(args?: Subset<T, AdType$AdRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findMany"> | Null>
    Ad<T extends AdType$AdArgs<ExtArgs> = {}>(args?: Subset<T, AdType$AdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdType model
   */ 
  interface AdTypeFieldRefs {
    readonly id: FieldRef<"AdType", 'String'>
    readonly name: FieldRef<"AdType", 'String'>
    readonly description: FieldRef<"AdType", 'String'>
    readonly image: FieldRef<"AdType", 'String'>
    readonly limit: FieldRef<"AdType", 'Int'>
    readonly desktop_width: FieldRef<"AdType", 'Int'>
    readonly desktop_height: FieldRef<"AdType", 'Int'>
    readonly mobile_width: FieldRef<"AdType", 'Int'>
    readonly mobile_height: FieldRef<"AdType", 'Int'>
    readonly desktop_file_size: FieldRef<"AdType", 'Int'>
    readonly mobile_file_size: FieldRef<"AdType", 'Int'>
    readonly status: FieldRef<"AdType", 'Status'>
    readonly createdAt: FieldRef<"AdType", 'DateTime'>
    readonly updatedAt: FieldRef<"AdType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdType findUnique
   */
  export type AdTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdType to fetch.
     */
    where: AdTypeWhereUniqueInput
  }

  /**
   * AdType findUniqueOrThrow
   */
  export type AdTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdType to fetch.
     */
    where: AdTypeWhereUniqueInput
  }

  /**
   * AdType findFirst
   */
  export type AdTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdType to fetch.
     */
    where?: AdTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdTypes to fetch.
     */
    orderBy?: AdTypeOrderByWithRelationInput | AdTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdTypes.
     */
    cursor?: AdTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdTypes.
     */
    distinct?: AdTypeScalarFieldEnum | AdTypeScalarFieldEnum[]
  }

  /**
   * AdType findFirstOrThrow
   */
  export type AdTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdType to fetch.
     */
    where?: AdTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdTypes to fetch.
     */
    orderBy?: AdTypeOrderByWithRelationInput | AdTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdTypes.
     */
    cursor?: AdTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdTypes.
     */
    distinct?: AdTypeScalarFieldEnum | AdTypeScalarFieldEnum[]
  }

  /**
   * AdType findMany
   */
  export type AdTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter, which AdTypes to fetch.
     */
    where?: AdTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdTypes to fetch.
     */
    orderBy?: AdTypeOrderByWithRelationInput | AdTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdTypes.
     */
    cursor?: AdTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdTypes.
     */
    skip?: number
    distinct?: AdTypeScalarFieldEnum | AdTypeScalarFieldEnum[]
  }

  /**
   * AdType create
   */
  export type AdTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AdType.
     */
    data: XOR<AdTypeCreateInput, AdTypeUncheckedCreateInput>
  }

  /**
   * AdType createMany
   */
  export type AdTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdTypes.
     */
    data: AdTypeCreateManyInput | AdTypeCreateManyInput[]
  }

  /**
   * AdType update
   */
  export type AdTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AdType.
     */
    data: XOR<AdTypeUpdateInput, AdTypeUncheckedUpdateInput>
    /**
     * Choose, which AdType to update.
     */
    where: AdTypeWhereUniqueInput
  }

  /**
   * AdType updateMany
   */
  export type AdTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdTypes.
     */
    data: XOR<AdTypeUpdateManyMutationInput, AdTypeUncheckedUpdateManyInput>
    /**
     * Filter which AdTypes to update
     */
    where?: AdTypeWhereInput
  }

  /**
   * AdType upsert
   */
  export type AdTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AdType to update in case it exists.
     */
    where: AdTypeWhereUniqueInput
    /**
     * In case the AdType found by the `where` argument doesn't exist, create a new AdType with this data.
     */
    create: XOR<AdTypeCreateInput, AdTypeUncheckedCreateInput>
    /**
     * In case the AdType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdTypeUpdateInput, AdTypeUncheckedUpdateInput>
  }

  /**
   * AdType delete
   */
  export type AdTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
    /**
     * Filter which AdType to delete.
     */
    where: AdTypeWhereUniqueInput
  }

  /**
   * AdType deleteMany
   */
  export type AdTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdTypes to delete
     */
    where?: AdTypeWhereInput
  }

  /**
   * AdType findRaw
   */
  export type AdTypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdType aggregateRaw
   */
  export type AdTypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdType.AdRates
   */
  export type AdType$AdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    where?: AdRatesWhereInput
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    cursor?: AdRatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * AdType.Ad
   */
  export type AdType$AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * AdType without action
   */
  export type AdTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdType
     */
    select?: AdTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdTypeInclude<ExtArgs> | null
  }


  /**
   * Model AdRates
   */

  export type AggregateAdRates = {
    _count: AdRatesCountAggregateOutputType | null
    _avg: AdRatesAvgAggregateOutputType | null
    _sum: AdRatesSumAggregateOutputType | null
    _min: AdRatesMinAggregateOutputType | null
    _max: AdRatesMaxAggregateOutputType | null
  }

  export type AdRatesAvgAggregateOutputType = {
    rate: number | null
  }

  export type AdRatesSumAggregateOutputType = {
    rate: number | null
  }

  export type AdRatesMinAggregateOutputType = {
    id: string | null
    stateId: string | null
    cityId: string | null
    adTypeId: string | null
    rate: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdRatesMaxAggregateOutputType = {
    id: string | null
    stateId: string | null
    cityId: string | null
    adTypeId: string | null
    rate: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdRatesCountAggregateOutputType = {
    id: number
    stateId: number
    cityId: number
    adTypeId: number
    rate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdRatesAvgAggregateInputType = {
    rate?: true
  }

  export type AdRatesSumAggregateInputType = {
    rate?: true
  }

  export type AdRatesMinAggregateInputType = {
    id?: true
    stateId?: true
    cityId?: true
    adTypeId?: true
    rate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdRatesMaxAggregateInputType = {
    id?: true
    stateId?: true
    cityId?: true
    adTypeId?: true
    rate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdRatesCountAggregateInputType = {
    id?: true
    stateId?: true
    cityId?: true
    adTypeId?: true
    rate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdRatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdRates to aggregate.
     */
    where?: AdRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRates to fetch.
     */
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdRates
    **/
    _count?: true | AdRatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdRatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdRatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdRatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdRatesMaxAggregateInputType
  }

  export type GetAdRatesAggregateType<T extends AdRatesAggregateArgs> = {
        [P in keyof T & keyof AggregateAdRates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdRates[P]>
      : GetScalarType<T[P], AggregateAdRates[P]>
  }




  export type AdRatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdRatesWhereInput
    orderBy?: AdRatesOrderByWithAggregationInput | AdRatesOrderByWithAggregationInput[]
    by: AdRatesScalarFieldEnum[] | AdRatesScalarFieldEnum
    having?: AdRatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdRatesCountAggregateInputType | true
    _avg?: AdRatesAvgAggregateInputType
    _sum?: AdRatesSumAggregateInputType
    _min?: AdRatesMinAggregateInputType
    _max?: AdRatesMaxAggregateInputType
  }

  export type AdRatesGroupByOutputType = {
    id: string
    stateId: string
    cityId: string
    adTypeId: string
    rate: number
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: AdRatesCountAggregateOutputType | null
    _avg: AdRatesAvgAggregateOutputType | null
    _sum: AdRatesSumAggregateOutputType | null
    _min: AdRatesMinAggregateOutputType | null
    _max: AdRatesMaxAggregateOutputType | null
  }

  type GetAdRatesGroupByPayload<T extends AdRatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdRatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdRatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdRatesGroupByOutputType[P]>
            : GetScalarType<T[P], AdRatesGroupByOutputType[P]>
        }
      >
    >


  export type AdRatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateId?: boolean
    cityId?: boolean
    adTypeId?: boolean
    rate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    state?: boolean | StateDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    adType?: boolean | AdTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adRates"]>


  export type AdRatesSelectScalar = {
    id?: boolean
    stateId?: boolean
    cityId?: boolean
    adTypeId?: boolean
    rate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdRatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | StateDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    adType?: boolean | AdTypeDefaultArgs<ExtArgs>
  }

  export type $AdRatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdRates"
    objects: {
      state: Prisma.$StatePayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      adType: Prisma.$AdTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stateId: string
      cityId: string
      adTypeId: string
      rate: number
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adRates"]>
    composites: {}
  }

  type AdRatesGetPayload<S extends boolean | null | undefined | AdRatesDefaultArgs> = $Result.GetResult<Prisma.$AdRatesPayload, S>

  type AdRatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdRatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdRatesCountAggregateInputType | true
    }

  export interface AdRatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdRates'], meta: { name: 'AdRates' } }
    /**
     * Find zero or one AdRates that matches the filter.
     * @param {AdRatesFindUniqueArgs} args - Arguments to find a AdRates
     * @example
     * // Get one AdRates
     * const adRates = await prisma.adRates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdRatesFindUniqueArgs>(args: SelectSubset<T, AdRatesFindUniqueArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdRates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdRatesFindUniqueOrThrowArgs} args - Arguments to find a AdRates
     * @example
     * // Get one AdRates
     * const adRates = await prisma.adRates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdRatesFindUniqueOrThrowArgs>(args: SelectSubset<T, AdRatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesFindFirstArgs} args - Arguments to find a AdRates
     * @example
     * // Get one AdRates
     * const adRates = await prisma.adRates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdRatesFindFirstArgs>(args?: SelectSubset<T, AdRatesFindFirstArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdRates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesFindFirstOrThrowArgs} args - Arguments to find a AdRates
     * @example
     * // Get one AdRates
     * const adRates = await prisma.adRates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdRatesFindFirstOrThrowArgs>(args?: SelectSubset<T, AdRatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdRates
     * const adRates = await prisma.adRates.findMany()
     * 
     * // Get first 10 AdRates
     * const adRates = await prisma.adRates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adRatesWithIdOnly = await prisma.adRates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdRatesFindManyArgs>(args?: SelectSubset<T, AdRatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdRates.
     * @param {AdRatesCreateArgs} args - Arguments to create a AdRates.
     * @example
     * // Create one AdRates
     * const AdRates = await prisma.adRates.create({
     *   data: {
     *     // ... data to create a AdRates
     *   }
     * })
     * 
     */
    create<T extends AdRatesCreateArgs>(args: SelectSubset<T, AdRatesCreateArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdRates.
     * @param {AdRatesCreateManyArgs} args - Arguments to create many AdRates.
     * @example
     * // Create many AdRates
     * const adRates = await prisma.adRates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdRatesCreateManyArgs>(args?: SelectSubset<T, AdRatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdRates.
     * @param {AdRatesDeleteArgs} args - Arguments to delete one AdRates.
     * @example
     * // Delete one AdRates
     * const AdRates = await prisma.adRates.delete({
     *   where: {
     *     // ... filter to delete one AdRates
     *   }
     * })
     * 
     */
    delete<T extends AdRatesDeleteArgs>(args: SelectSubset<T, AdRatesDeleteArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdRates.
     * @param {AdRatesUpdateArgs} args - Arguments to update one AdRates.
     * @example
     * // Update one AdRates
     * const adRates = await prisma.adRates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdRatesUpdateArgs>(args: SelectSubset<T, AdRatesUpdateArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdRates.
     * @param {AdRatesDeleteManyArgs} args - Arguments to filter AdRates to delete.
     * @example
     * // Delete a few AdRates
     * const { count } = await prisma.adRates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdRatesDeleteManyArgs>(args?: SelectSubset<T, AdRatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdRates
     * const adRates = await prisma.adRates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdRatesUpdateManyArgs>(args: SelectSubset<T, AdRatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdRates.
     * @param {AdRatesUpsertArgs} args - Arguments to update or create a AdRates.
     * @example
     * // Update or create a AdRates
     * const adRates = await prisma.adRates.upsert({
     *   create: {
     *     // ... data to create a AdRates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdRates we want to update
     *   }
     * })
     */
    upsert<T extends AdRatesUpsertArgs>(args: SelectSubset<T, AdRatesUpsertArgs<ExtArgs>>): Prisma__AdRatesClient<$Result.GetResult<Prisma.$AdRatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AdRates that matches the filter.
     * @param {AdRatesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const adRates = await prisma.adRates.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AdRatesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AdRates.
     * @param {AdRatesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const adRates = await prisma.adRates.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdRatesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AdRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesCountArgs} args - Arguments to filter AdRates to count.
     * @example
     * // Count the number of AdRates
     * const count = await prisma.adRates.count({
     *   where: {
     *     // ... the filter for the AdRates we want to count
     *   }
     * })
    **/
    count<T extends AdRatesCountArgs>(
      args?: Subset<T, AdRatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdRatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdRatesAggregateArgs>(args: Subset<T, AdRatesAggregateArgs>): Prisma.PrismaPromise<GetAdRatesAggregateType<T>>

    /**
     * Group by AdRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdRatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdRatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdRatesGroupByArgs['orderBy'] }
        : { orderBy?: AdRatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdRatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdRatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdRates model
   */
  readonly fields: AdRatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdRates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdRatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends StateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StateDefaultArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    adType<T extends AdTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdTypeDefaultArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdRates model
   */ 
  interface AdRatesFieldRefs {
    readonly id: FieldRef<"AdRates", 'String'>
    readonly stateId: FieldRef<"AdRates", 'String'>
    readonly cityId: FieldRef<"AdRates", 'String'>
    readonly adTypeId: FieldRef<"AdRates", 'String'>
    readonly rate: FieldRef<"AdRates", 'Float'>
    readonly status: FieldRef<"AdRates", 'Status'>
    readonly createdAt: FieldRef<"AdRates", 'DateTime'>
    readonly updatedAt: FieldRef<"AdRates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdRates findUnique
   */
  export type AdRatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter, which AdRates to fetch.
     */
    where: AdRatesWhereUniqueInput
  }

  /**
   * AdRates findUniqueOrThrow
   */
  export type AdRatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter, which AdRates to fetch.
     */
    where: AdRatesWhereUniqueInput
  }

  /**
   * AdRates findFirst
   */
  export type AdRatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter, which AdRates to fetch.
     */
    where?: AdRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRates to fetch.
     */
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdRates.
     */
    cursor?: AdRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdRates.
     */
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * AdRates findFirstOrThrow
   */
  export type AdRatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter, which AdRates to fetch.
     */
    where?: AdRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRates to fetch.
     */
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdRates.
     */
    cursor?: AdRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdRates.
     */
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * AdRates findMany
   */
  export type AdRatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter, which AdRates to fetch.
     */
    where?: AdRatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdRates to fetch.
     */
    orderBy?: AdRatesOrderByWithRelationInput | AdRatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdRates.
     */
    cursor?: AdRatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdRates.
     */
    skip?: number
    distinct?: AdRatesScalarFieldEnum | AdRatesScalarFieldEnum[]
  }

  /**
   * AdRates create
   */
  export type AdRatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * The data needed to create a AdRates.
     */
    data: XOR<AdRatesCreateInput, AdRatesUncheckedCreateInput>
  }

  /**
   * AdRates createMany
   */
  export type AdRatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdRates.
     */
    data: AdRatesCreateManyInput | AdRatesCreateManyInput[]
  }

  /**
   * AdRates update
   */
  export type AdRatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * The data needed to update a AdRates.
     */
    data: XOR<AdRatesUpdateInput, AdRatesUncheckedUpdateInput>
    /**
     * Choose, which AdRates to update.
     */
    where: AdRatesWhereUniqueInput
  }

  /**
   * AdRates updateMany
   */
  export type AdRatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdRates.
     */
    data: XOR<AdRatesUpdateManyMutationInput, AdRatesUncheckedUpdateManyInput>
    /**
     * Filter which AdRates to update
     */
    where?: AdRatesWhereInput
  }

  /**
   * AdRates upsert
   */
  export type AdRatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * The filter to search for the AdRates to update in case it exists.
     */
    where: AdRatesWhereUniqueInput
    /**
     * In case the AdRates found by the `where` argument doesn't exist, create a new AdRates with this data.
     */
    create: XOR<AdRatesCreateInput, AdRatesUncheckedCreateInput>
    /**
     * In case the AdRates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdRatesUpdateInput, AdRatesUncheckedUpdateInput>
  }

  /**
   * AdRates delete
   */
  export type AdRatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
    /**
     * Filter which AdRates to delete.
     */
    where: AdRatesWhereUniqueInput
  }

  /**
   * AdRates deleteMany
   */
  export type AdRatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdRates to delete
     */
    where?: AdRatesWhereInput
  }

  /**
   * AdRates findRaw
   */
  export type AdRatesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdRates aggregateRaw
   */
  export type AdRatesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdRates without action
   */
  export type AdRatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdRates
     */
    select?: AdRatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdRatesInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Ad?: boolean | Category$AdArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ad?: boolean | Category$AdArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      Ad: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ad<T extends Category$AdArgs<ExtArgs> = {}>(args?: Subset<T, Category$AdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category.Ad
   */
  export type Category$AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Ad
   */

  export type AggregateAd = {
    _count: AdCountAggregateOutputType | null
    _avg: AdAvgAggregateOutputType | null
    _sum: AdSumAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  export type AdAvgAggregateOutputType = {
    totalCost: number | null
    selectedDays: number | null
    clicks: number | null
    views: number | null
  }

  export type AdSumAggregateOutputType = {
    totalCost: number | null
    selectedDays: number[]
    clicks: number | null
    views: number | null
  }

  export type AdMinAggregateOutputType = {
    id: string | null
    name: string | null
    adTypesId: string | null
    linkUrl: string | null
    buttonName: string | null
    desktopFile: string | null
    mobileFile: string | null
    font: string | null
    text1: string | null
    text1Color: string | null
    text2: string | null
    text2Color: string | null
    bgImage: string | null
    payStatus: string | null
    status: $Enums.Status | null
    totalCost: number | null
    userId: string | null
    categoryId: string | null
    urlVideo: string | null
    desktopVideoFile: string | null
    desktopVideoPreview: string | null
    mobileVideoFile: string | null
    mobileVideoPreview: string | null
    stateId: string | null
    cityId: string | null
    startDate: Date | null
    endDate: Date | null
    clicks: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdMaxAggregateOutputType = {
    id: string | null
    name: string | null
    adTypesId: string | null
    linkUrl: string | null
    buttonName: string | null
    desktopFile: string | null
    mobileFile: string | null
    font: string | null
    text1: string | null
    text1Color: string | null
    text2: string | null
    text2Color: string | null
    bgImage: string | null
    payStatus: string | null
    status: $Enums.Status | null
    totalCost: number | null
    userId: string | null
    categoryId: string | null
    urlVideo: string | null
    desktopVideoFile: string | null
    desktopVideoPreview: string | null
    mobileVideoFile: string | null
    mobileVideoPreview: string | null
    stateId: string | null
    cityId: string | null
    startDate: Date | null
    endDate: Date | null
    clicks: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdCountAggregateOutputType = {
    id: number
    name: number
    adTypesId: number
    linkUrl: number
    buttonName: number
    desktopFile: number
    mobileFile: number
    font: number
    text1: number
    text1Color: number
    text2: number
    text2Color: number
    bgImage: number
    payStatus: number
    status: number
    totalCost: number
    userId: number
    categoryId: number
    urlVideo: number
    desktopVideoFile: number
    desktopVideoPreview: number
    mobileVideoFile: number
    mobileVideoPreview: number
    stateId: number
    cityId: number
    selectedDays: number
    selectedDates: number
    startDate: number
    endDate: number
    clicks: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdAvgAggregateInputType = {
    totalCost?: true
    selectedDays?: true
    clicks?: true
    views?: true
  }

  export type AdSumAggregateInputType = {
    totalCost?: true
    selectedDays?: true
    clicks?: true
    views?: true
  }

  export type AdMinAggregateInputType = {
    id?: true
    name?: true
    adTypesId?: true
    linkUrl?: true
    buttonName?: true
    desktopFile?: true
    mobileFile?: true
    font?: true
    text1?: true
    text1Color?: true
    text2?: true
    text2Color?: true
    bgImage?: true
    payStatus?: true
    status?: true
    totalCost?: true
    userId?: true
    categoryId?: true
    urlVideo?: true
    desktopVideoFile?: true
    desktopVideoPreview?: true
    mobileVideoFile?: true
    mobileVideoPreview?: true
    stateId?: true
    cityId?: true
    startDate?: true
    endDate?: true
    clicks?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdMaxAggregateInputType = {
    id?: true
    name?: true
    adTypesId?: true
    linkUrl?: true
    buttonName?: true
    desktopFile?: true
    mobileFile?: true
    font?: true
    text1?: true
    text1Color?: true
    text2?: true
    text2Color?: true
    bgImage?: true
    payStatus?: true
    status?: true
    totalCost?: true
    userId?: true
    categoryId?: true
    urlVideo?: true
    desktopVideoFile?: true
    desktopVideoPreview?: true
    mobileVideoFile?: true
    mobileVideoPreview?: true
    stateId?: true
    cityId?: true
    startDate?: true
    endDate?: true
    clicks?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdCountAggregateInputType = {
    id?: true
    name?: true
    adTypesId?: true
    linkUrl?: true
    buttonName?: true
    desktopFile?: true
    mobileFile?: true
    font?: true
    text1?: true
    text1Color?: true
    text2?: true
    text2Color?: true
    bgImage?: true
    payStatus?: true
    status?: true
    totalCost?: true
    userId?: true
    categoryId?: true
    urlVideo?: true
    desktopVideoFile?: true
    desktopVideoPreview?: true
    mobileVideoFile?: true
    mobileVideoPreview?: true
    stateId?: true
    cityId?: true
    selectedDays?: true
    selectedDates?: true
    startDate?: true
    endDate?: true
    clicks?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ad to aggregate.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ads
    **/
    _count?: true | AdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMaxAggregateInputType
  }

  export type GetAdAggregateType<T extends AdAggregateArgs> = {
        [P in keyof T & keyof AggregateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd[P]>
      : GetScalarType<T[P], AggregateAd[P]>
  }




  export type AdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
    orderBy?: AdOrderByWithAggregationInput | AdOrderByWithAggregationInput[]
    by: AdScalarFieldEnum[] | AdScalarFieldEnum
    having?: AdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCountAggregateInputType | true
    _avg?: AdAvgAggregateInputType
    _sum?: AdSumAggregateInputType
    _min?: AdMinAggregateInputType
    _max?: AdMaxAggregateInputType
  }

  export type AdGroupByOutputType = {
    id: string
    name: string
    adTypesId: string
    linkUrl: string | null
    buttonName: string | null
    desktopFile: string | null
    mobileFile: string | null
    font: string | null
    text1: string | null
    text1Color: string | null
    text2: string | null
    text2Color: string | null
    bgImage: string | null
    payStatus: string | null
    status: $Enums.Status
    totalCost: number | null
    userId: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId: string | null
    cityId: string | null
    selectedDays: number[]
    selectedDates: Date[]
    startDate: Date
    endDate: Date
    clicks: number
    views: number
    createdAt: Date
    updatedAt: Date
    _count: AdCountAggregateOutputType | null
    _avg: AdAvgAggregateOutputType | null
    _sum: AdSumAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  type GetAdGroupByPayload<T extends AdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupByOutputType[P]>
        }
      >
    >


  export type AdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    adTypesId?: boolean
    linkUrl?: boolean
    buttonName?: boolean
    desktopFile?: boolean
    mobileFile?: boolean
    font?: boolean
    text1?: boolean
    text1Color?: boolean
    text2?: boolean
    text2Color?: boolean
    bgImage?: boolean
    payStatus?: boolean
    status?: boolean
    totalCost?: boolean
    userId?: boolean
    categoryId?: boolean
    urlVideo?: boolean
    desktopVideoFile?: boolean
    desktopVideoPreview?: boolean
    mobileVideoFile?: boolean
    mobileVideoPreview?: boolean
    stateId?: boolean
    cityId?: boolean
    selectedDays?: boolean
    selectedDates?: boolean
    startDate?: boolean
    endDate?: boolean
    clicks?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adType?: boolean | AdTypeDefaultArgs<ExtArgs>
    user?: boolean | Ad$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    state?: boolean | Ad$stateArgs<ExtArgs>
    city?: boolean | Ad$cityArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>


  export type AdSelectScalar = {
    id?: boolean
    name?: boolean
    adTypesId?: boolean
    linkUrl?: boolean
    buttonName?: boolean
    desktopFile?: boolean
    mobileFile?: boolean
    font?: boolean
    text1?: boolean
    text1Color?: boolean
    text2?: boolean
    text2Color?: boolean
    bgImage?: boolean
    payStatus?: boolean
    status?: boolean
    totalCost?: boolean
    userId?: boolean
    categoryId?: boolean
    urlVideo?: boolean
    desktopVideoFile?: boolean
    desktopVideoPreview?: boolean
    mobileVideoFile?: boolean
    mobileVideoPreview?: boolean
    stateId?: boolean
    cityId?: boolean
    selectedDays?: boolean
    selectedDates?: boolean
    startDate?: boolean
    endDate?: boolean
    clicks?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adType?: boolean | AdTypeDefaultArgs<ExtArgs>
    user?: boolean | Ad$userArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    state?: boolean | Ad$stateArgs<ExtArgs>
    city?: boolean | Ad$cityArgs<ExtArgs>
  }

  export type $AdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ad"
    objects: {
      adType: Prisma.$AdTypePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs>
      state: Prisma.$StatePayload<ExtArgs> | null
      city: Prisma.$CityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      adTypesId: string
      linkUrl: string | null
      buttonName: string | null
      desktopFile: string | null
      mobileFile: string | null
      font: string | null
      text1: string | null
      text1Color: string | null
      text2: string | null
      text2Color: string | null
      bgImage: string | null
      payStatus: string | null
      status: $Enums.Status
      totalCost: number | null
      userId: string | null
      categoryId: string
      urlVideo: string
      desktopVideoFile: string
      desktopVideoPreview: string
      mobileVideoFile: string
      mobileVideoPreview: string
      stateId: string | null
      cityId: string | null
      selectedDays: number[]
      selectedDates: Date[]
      startDate: Date
      endDate: Date
      clicks: number
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ad"]>
    composites: {}
  }

  type AdGetPayload<S extends boolean | null | undefined | AdDefaultArgs> = $Result.GetResult<Prisma.$AdPayload, S>

  type AdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdCountAggregateInputType | true
    }

  export interface AdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ad'], meta: { name: 'Ad' } }
    /**
     * Find zero or one Ad that matches the filter.
     * @param {AdFindUniqueArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdFindUniqueArgs>(args: SelectSubset<T, AdFindUniqueArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdFindUniqueOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdFindUniqueOrThrowArgs>(args: SelectSubset<T, AdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdFindFirstArgs>(args?: SelectSubset<T, AdFindFirstArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdFindFirstOrThrowArgs>(args?: SelectSubset<T, AdFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ad.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adWithIdOnly = await prisma.ad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdFindManyArgs>(args?: SelectSubset<T, AdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ad.
     * @param {AdCreateArgs} args - Arguments to create a Ad.
     * @example
     * // Create one Ad
     * const Ad = await prisma.ad.create({
     *   data: {
     *     // ... data to create a Ad
     *   }
     * })
     * 
     */
    create<T extends AdCreateArgs>(args: SelectSubset<T, AdCreateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ads.
     * @param {AdCreateManyArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCreateManyArgs>(args?: SelectSubset<T, AdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ad.
     * @param {AdDeleteArgs} args - Arguments to delete one Ad.
     * @example
     * // Delete one Ad
     * const Ad = await prisma.ad.delete({
     *   where: {
     *     // ... filter to delete one Ad
     *   }
     * })
     * 
     */
    delete<T extends AdDeleteArgs>(args: SelectSubset<T, AdDeleteArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ad.
     * @param {AdUpdateArgs} args - Arguments to update one Ad.
     * @example
     * // Update one Ad
     * const ad = await prisma.ad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdUpdateArgs>(args: SelectSubset<T, AdUpdateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ads.
     * @param {AdDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdDeleteManyArgs>(args?: SelectSubset<T, AdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdUpdateManyArgs>(args: SelectSubset<T, AdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ad.
     * @param {AdUpsertArgs} args - Arguments to update or create a Ad.
     * @example
     * // Update or create a Ad
     * const ad = await prisma.ad.upsert({
     *   create: {
     *     // ... data to create a Ad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad we want to update
     *   }
     * })
     */
    upsert<T extends AdUpsertArgs>(args: SelectSubset<T, AdUpsertArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ads that matches the filter.
     * @param {AdFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ad = await prisma.ad.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AdFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ad.
     * @param {AdAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ad = await prisma.ad.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ad.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends AdCountArgs>(
      args?: Subset<T, AdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAggregateArgs>(args: Subset<T, AdAggregateArgs>): Prisma.PrismaPromise<GetAdAggregateType<T>>

    /**
     * Group by Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ad model
   */
  readonly fields: AdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adType<T extends AdTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdTypeDefaultArgs<ExtArgs>>): Prisma__AdTypeClient<$Result.GetResult<Prisma.$AdTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends Ad$userArgs<ExtArgs> = {}>(args?: Subset<T, Ad$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    state<T extends Ad$stateArgs<ExtArgs> = {}>(args?: Subset<T, Ad$stateArgs<ExtArgs>>): Prisma__StateClient<$Result.GetResult<Prisma.$StatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    city<T extends Ad$cityArgs<ExtArgs> = {}>(args?: Subset<T, Ad$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ad model
   */ 
  interface AdFieldRefs {
    readonly id: FieldRef<"Ad", 'String'>
    readonly name: FieldRef<"Ad", 'String'>
    readonly adTypesId: FieldRef<"Ad", 'String'>
    readonly linkUrl: FieldRef<"Ad", 'String'>
    readonly buttonName: FieldRef<"Ad", 'String'>
    readonly desktopFile: FieldRef<"Ad", 'String'>
    readonly mobileFile: FieldRef<"Ad", 'String'>
    readonly font: FieldRef<"Ad", 'String'>
    readonly text1: FieldRef<"Ad", 'String'>
    readonly text1Color: FieldRef<"Ad", 'String'>
    readonly text2: FieldRef<"Ad", 'String'>
    readonly text2Color: FieldRef<"Ad", 'String'>
    readonly bgImage: FieldRef<"Ad", 'String'>
    readonly payStatus: FieldRef<"Ad", 'String'>
    readonly status: FieldRef<"Ad", 'Status'>
    readonly totalCost: FieldRef<"Ad", 'Float'>
    readonly userId: FieldRef<"Ad", 'String'>
    readonly categoryId: FieldRef<"Ad", 'String'>
    readonly urlVideo: FieldRef<"Ad", 'String'>
    readonly desktopVideoFile: FieldRef<"Ad", 'String'>
    readonly desktopVideoPreview: FieldRef<"Ad", 'String'>
    readonly mobileVideoFile: FieldRef<"Ad", 'String'>
    readonly mobileVideoPreview: FieldRef<"Ad", 'String'>
    readonly stateId: FieldRef<"Ad", 'String'>
    readonly cityId: FieldRef<"Ad", 'String'>
    readonly selectedDays: FieldRef<"Ad", 'Int[]'>
    readonly selectedDates: FieldRef<"Ad", 'DateTime[]'>
    readonly startDate: FieldRef<"Ad", 'DateTime'>
    readonly endDate: FieldRef<"Ad", 'DateTime'>
    readonly clicks: FieldRef<"Ad", 'Int'>
    readonly views: FieldRef<"Ad", 'Int'>
    readonly createdAt: FieldRef<"Ad", 'DateTime'>
    readonly updatedAt: FieldRef<"Ad", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ad findUnique
   */
  export type AdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findUniqueOrThrow
   */
  export type AdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findFirst
   */
  export type AdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findFirstOrThrow
   */
  export type AdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findMany
   */
  export type AdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ads to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad create
   */
  export type AdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to create a Ad.
     */
    data: XOR<AdCreateInput, AdUncheckedCreateInput>
  }

  /**
   * Ad createMany
   */
  export type AdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
  }

  /**
   * Ad update
   */
  export type AdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to update a Ad.
     */
    data: XOR<AdUpdateInput, AdUncheckedUpdateInput>
    /**
     * Choose, which Ad to update.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad updateMany
   */
  export type AdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
  }

  /**
   * Ad upsert
   */
  export type AdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The filter to search for the Ad to update in case it exists.
     */
    where: AdWhereUniqueInput
    /**
     * In case the Ad found by the `where` argument doesn't exist, create a new Ad with this data.
     */
    create: XOR<AdCreateInput, AdUncheckedCreateInput>
    /**
     * In case the Ad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdUpdateInput, AdUncheckedUpdateInput>
  }

  /**
   * Ad delete
   */
  export type AdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter which Ad to delete.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad deleteMany
   */
  export type AdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ads to delete
     */
    where?: AdWhereInput
  }

  /**
   * Ad findRaw
   */
  export type AdFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ad aggregateRaw
   */
  export type AdAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ad.user
   */
  export type Ad$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ad.state
   */
  export type Ad$stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateInclude<ExtArgs> | null
    where?: StateWhereInput
  }

  /**
   * Ad.city
   */
  export type Ad$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * Ad without action
   */
  export type AdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
  }


  /**
   * Model Terms
   */

  export type AggregateTerms = {
    _count: TermsCountAggregateOutputType | null
    _min: TermsMinAggregateOutputType | null
    _max: TermsMaxAggregateOutputType | null
  }

  export type TermsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.TypeText | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.TypeText | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TermsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TermsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terms to aggregate.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terms
    **/
    _count?: true | TermsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsMaxAggregateInputType
  }

  export type GetTermsAggregateType<T extends TermsAggregateArgs> = {
        [P in keyof T & keyof AggregateTerms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerms[P]>
      : GetScalarType<T[P], AggregateTerms[P]>
  }




  export type TermsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsWhereInput
    orderBy?: TermsOrderByWithAggregationInput | TermsOrderByWithAggregationInput[]
    by: TermsScalarFieldEnum[] | TermsScalarFieldEnum
    having?: TermsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsCountAggregateInputType | true
    _min?: TermsMinAggregateInputType
    _max?: TermsMaxAggregateInputType
  }

  export type TermsGroupByOutputType = {
    id: string
    title: string
    content: string
    type: $Enums.TypeText
    createdAt: Date
    updatedAt: Date
    _count: TermsCountAggregateOutputType | null
    _min: TermsMinAggregateOutputType | null
    _max: TermsMaxAggregateOutputType | null
  }

  type GetTermsGroupByPayload<T extends TermsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsGroupByOutputType[P]>
            : GetScalarType<T[P], TermsGroupByOutputType[P]>
        }
      >
    >


  export type TermsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["terms"]>


  export type TermsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TermsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Terms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      type: $Enums.TypeText
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["terms"]>
    composites: {}
  }

  type TermsGetPayload<S extends boolean | null | undefined | TermsDefaultArgs> = $Result.GetResult<Prisma.$TermsPayload, S>

  type TermsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TermsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TermsCountAggregateInputType | true
    }

  export interface TermsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Terms'], meta: { name: 'Terms' } }
    /**
     * Find zero or one Terms that matches the filter.
     * @param {TermsFindUniqueArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsFindUniqueArgs>(args: SelectSubset<T, TermsFindUniqueArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Terms that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TermsFindUniqueOrThrowArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsFindUniqueOrThrowArgs>(args: SelectSubset<T, TermsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindFirstArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsFindFirstArgs>(args?: SelectSubset<T, TermsFindFirstArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindFirstOrThrowArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsFindFirstOrThrowArgs>(args?: SelectSubset<T, TermsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.terms.findMany()
     * 
     * // Get first 10 Terms
     * const terms = await prisma.terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsWithIdOnly = await prisma.terms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermsFindManyArgs>(args?: SelectSubset<T, TermsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Terms.
     * @param {TermsCreateArgs} args - Arguments to create a Terms.
     * @example
     * // Create one Terms
     * const Terms = await prisma.terms.create({
     *   data: {
     *     // ... data to create a Terms
     *   }
     * })
     * 
     */
    create<T extends TermsCreateArgs>(args: SelectSubset<T, TermsCreateArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Terms.
     * @param {TermsCreateManyArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const terms = await prisma.terms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermsCreateManyArgs>(args?: SelectSubset<T, TermsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Terms.
     * @param {TermsDeleteArgs} args - Arguments to delete one Terms.
     * @example
     * // Delete one Terms
     * const Terms = await prisma.terms.delete({
     *   where: {
     *     // ... filter to delete one Terms
     *   }
     * })
     * 
     */
    delete<T extends TermsDeleteArgs>(args: SelectSubset<T, TermsDeleteArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Terms.
     * @param {TermsUpdateArgs} args - Arguments to update one Terms.
     * @example
     * // Update one Terms
     * const terms = await prisma.terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermsUpdateArgs>(args: SelectSubset<T, TermsUpdateArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Terms.
     * @param {TermsDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermsDeleteManyArgs>(args?: SelectSubset<T, TermsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const terms = await prisma.terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermsUpdateManyArgs>(args: SelectSubset<T, TermsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terms.
     * @param {TermsUpsertArgs} args - Arguments to update or create a Terms.
     * @example
     * // Update or create a Terms
     * const terms = await prisma.terms.upsert({
     *   create: {
     *     // ... data to create a Terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms we want to update
     *   }
     * })
     */
    upsert<T extends TermsUpsertArgs>(args: SelectSubset<T, TermsUpsertArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Terms that matches the filter.
     * @param {TermsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const terms = await prisma.terms.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TermsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Terms.
     * @param {TermsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const terms = await prisma.terms.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TermsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.terms.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
    **/
    count<T extends TermsCountArgs>(
      args?: Subset<T, TermsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsAggregateArgs>(args: Subset<T, TermsAggregateArgs>): Prisma.PrismaPromise<GetTermsAggregateType<T>>

    /**
     * Group by Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsGroupByArgs['orderBy'] }
        : { orderBy?: TermsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Terms model
   */
  readonly fields: TermsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Terms model
   */ 
  interface TermsFieldRefs {
    readonly id: FieldRef<"Terms", 'String'>
    readonly title: FieldRef<"Terms", 'String'>
    readonly content: FieldRef<"Terms", 'String'>
    readonly type: FieldRef<"Terms", 'TypeText'>
    readonly createdAt: FieldRef<"Terms", 'DateTime'>
    readonly updatedAt: FieldRef<"Terms", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Terms findUnique
   */
  export type TermsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where: TermsWhereUniqueInput
  }

  /**
   * Terms findUniqueOrThrow
   */
  export type TermsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where: TermsWhereUniqueInput
  }

  /**
   * Terms findFirst
   */
  export type TermsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }

  /**
   * Terms findFirstOrThrow
   */
  export type TermsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }

  /**
   * Terms findMany
   */
  export type TermsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }

  /**
   * Terms create
   */
  export type TermsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * The data needed to create a Terms.
     */
    data: XOR<TermsCreateInput, TermsUncheckedCreateInput>
  }

  /**
   * Terms createMany
   */
  export type TermsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terms.
     */
    data: TermsCreateManyInput | TermsCreateManyInput[]
  }

  /**
   * Terms update
   */
  export type TermsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * The data needed to update a Terms.
     */
    data: XOR<TermsUpdateInput, TermsUncheckedUpdateInput>
    /**
     * Choose, which Terms to update.
     */
    where: TermsWhereUniqueInput
  }

  /**
   * Terms updateMany
   */
  export type TermsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terms.
     */
    data: XOR<TermsUpdateManyMutationInput, TermsUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermsWhereInput
  }

  /**
   * Terms upsert
   */
  export type TermsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * The filter to search for the Terms to update in case it exists.
     */
    where: TermsWhereUniqueInput
    /**
     * In case the Terms found by the `where` argument doesn't exist, create a new Terms with this data.
     */
    create: XOR<TermsCreateInput, TermsUncheckedCreateInput>
    /**
     * In case the Terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsUpdateInput, TermsUncheckedUpdateInput>
  }

  /**
   * Terms delete
   */
  export type TermsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Filter which Terms to delete.
     */
    where: TermsWhereUniqueInput
  }

  /**
   * Terms deleteMany
   */
  export type TermsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terms to delete
     */
    where?: TermsWhereInput
  }

  /**
   * Terms findRaw
   */
  export type TermsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Terms aggregateRaw
   */
  export type TermsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Terms without action
   */
  export type TermsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>


  export type FeatureSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Features that matches the filter.
     * @param {FeatureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feature = await prisma.feature.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FeatureFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Feature.
     * @param {FeatureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feature = await prisma.feature.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FeatureAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */ 
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'String'>
    readonly name: FieldRef<"Feature", 'String'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
  }

  /**
   * Feature findRaw
   */
  export type FeatureFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Feature aggregateRaw
   */
  export type FeatureAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    type: $Enums.MediaType | null
    url: string | null
    thumbnail: string | null
    status: $Enums.MediaStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    breweryId: string | null
    approvedById: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MediaType | null
    url: string | null
    thumbnail: string | null
    status: $Enums.MediaStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    breweryId: string | null
    approvedById: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    type: number
    url: number
    thumbnail: number
    status: number
    createdAt: number
    updatedAt: number
    breweryId: number
    approvedById: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    thumbnail?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    breweryId?: true
    approvedById?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    thumbnail?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    breweryId?: true
    approvedById?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    thumbnail?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    breweryId?: true
    approvedById?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    type: $Enums.MediaType
    url: string
    thumbnail: string | null
    status: $Enums.MediaStatus
    createdAt: Date
    updatedAt: Date
    breweryId: string
    approvedById: string | null
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweryId?: boolean
    approvedById?: boolean
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    approvedBy?: boolean | Media$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>


  export type MediaSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    thumbnail?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    breweryId?: boolean
    approvedById?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brewery?: boolean | BreweryDefaultArgs<ExtArgs>
    approvedBy?: boolean | Media$approvedByArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      brewery: Prisma.$BreweryPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MediaType
      url: string
      thumbnail: string | null
      status: $Enums.MediaStatus
      createdAt: Date
      updatedAt: Date
      breweryId: string
      approvedById: string | null
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * @param {MediaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const media = await prisma.media.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MediaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Media.
     * @param {MediaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const media = await prisma.media.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MediaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brewery<T extends BreweryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreweryDefaultArgs<ExtArgs>>): Prisma__BreweryClient<$Result.GetResult<Prisma.$BreweryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends Media$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Media$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'MediaType'>
    readonly url: FieldRef<"Media", 'String'>
    readonly thumbnail: FieldRef<"Media", 'String'>
    readonly status: FieldRef<"Media", 'MediaStatus'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly breweryId: FieldRef<"Media", 'String'>
    readonly approvedById: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media findRaw
   */
  export type MediaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Media aggregateRaw
   */
  export type MediaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Media.approvedBy
   */
  export type Media$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    current_password: 'current_password',
    birthdate: 'birthdate',
    phone_number: 'phone_number',
    role: 'role',
    state: 'state',
    photo: 'photo',
    cityId: 'cityId',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    state_id: 'state_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const CountyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    county_fips: 'county_fips',
    stateId: 'stateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountyScalarFieldEnum = (typeof CountyScalarFieldEnum)[keyof typeof CountyScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city_ascii: 'city_ascii',
    stateId: 'stateId',
    countyId: 'countyId',
    lat: 'lat',
    lng: 'lng',
    population: 'population',
    timezone: 'timezone',
    ranking: 'ranking',
    zip: 'zip',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uniqueCityIdentifier: 'uniqueCityIdentifier'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    address: 'address',
    cityId: 'cityId',
    latitude: 'latitude',
    longitude: 'longitude',
    zip: 'zip',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stateId: 'stateId',
    countyId: 'countyId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const BreweryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    website: 'website',
    ownerId: 'ownerId',
    managerId: 'managerId',
    comments: 'comments',
    merchandise: 'merchandise',
    social_media: 'social_media',
    status: 'status',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryScalarFieldEnum = (typeof BreweryScalarFieldEnum)[keyof typeof BreweryScalarFieldEnum]


  export const BeerScalarFieldEnum: {
    id: 'id',
    type: 'type',
    brand: 'brand',
    name: 'name',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BeerScalarFieldEnum = (typeof BeerScalarFieldEnum)[keyof typeof BeerScalarFieldEnum]


  export const BreweryBeerScalarFieldEnum: {
    id: 'id',
    breweryId: 'breweryId',
    beerId: 'beerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryBeerScalarFieldEnum = (typeof BreweryBeerScalarFieldEnum)[keyof typeof BreweryBeerScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const BreweryFoodScalarFieldEnum: {
    id: 'id',
    breweryId: 'breweryId',
    foodId: 'foodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryFoodScalarFieldEnum = (typeof BreweryFoodScalarFieldEnum)[keyof typeof BreweryFoodScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BreweryServiceScalarFieldEnum: {
    id: 'id',
    breweryId: 'breweryId',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryServiceScalarFieldEnum = (typeof BreweryServiceScalarFieldEnum)[keyof typeof BreweryServiceScalarFieldEnum]


  export const MusicScalarFieldEnum: {
    id: 'id',
    genre: 'genre',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MusicScalarFieldEnum = (typeof MusicScalarFieldEnum)[keyof typeof MusicScalarFieldEnum]


  export const BreweryMusicScalarFieldEnum: {
    id: 'id',
    breweryId: 'breweryId',
    musicId: 'musicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryMusicScalarFieldEnum = (typeof BreweryMusicScalarFieldEnum)[keyof typeof BreweryMusicScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    date: 'date',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const BreweryEventScalarFieldEnum: {
    id: 'id',
    breweryId: 'breweryId',
    eventId: 'eventId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryEventScalarFieldEnum = (typeof BreweryEventScalarFieldEnum)[keyof typeof BreweryEventScalarFieldEnum]


  export const BreweryFeatureScalarFieldEnum: {
    id: 'id',
    logo: 'logo',
    image: 'image',
    description: 'description',
    phone: 'phone',
    facebook: 'facebook',
    x: 'x',
    instagram: 'instagram',
    highlighted: 'highlighted',
    capacity: 'capacity',
    booklink: 'booklink',
    pricerank: 'pricerank',
    state: 'state',
    breweryId: 'breweryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreweryFeatureScalarFieldEnum = (typeof BreweryFeatureScalarFieldEnum)[keyof typeof BreweryFeatureScalarFieldEnum]


  export const OperatingHoursScalarFieldEnum: {
    id: 'id',
    mondayOpen: 'mondayOpen',
    mondayClose: 'mondayClose',
    tuesdayOpen: 'tuesdayOpen',
    tuesdayClose: 'tuesdayClose',
    wednesdayOpen: 'wednesdayOpen',
    wednesdayClose: 'wednesdayClose',
    thursdayOpen: 'thursdayOpen',
    thursdayClose: 'thursdayClose',
    fridayOpen: 'fridayOpen',
    fridayClose: 'fridayClose',
    saturdayOpen: 'saturdayOpen',
    saturdayClose: 'saturdayClose',
    sundayOpen: 'sundayOpen',
    sundayClose: 'sundayClose',
    breweryId: 'breweryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatingHoursScalarFieldEnum = (typeof OperatingHoursScalarFieldEnum)[keyof typeof OperatingHoursScalarFieldEnum]


  export const TutorialStepsAppScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    web_image: 'web_image',
    mobile_image: 'mobile_image',
    orden: 'orden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TutorialStepsAppScalarFieldEnum = (typeof TutorialStepsAppScalarFieldEnum)[keyof typeof TutorialStepsAppScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    userId: 'userId',
    cityId: 'cityId',
    radius: 'radius',
    startDate: 'startDate',
    breweryCount: 'breweryCount',
    days: 'days',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const TourBreweryScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    breweryId: 'breweryId',
    distance: 'distance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourBreweryScalarFieldEnum = (typeof TourBreweryScalarFieldEnum)[keyof typeof TourBreweryScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    senderId: 'senderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const RecipientScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipientScalarFieldEnum = (typeof RecipientScalarFieldEnum)[keyof typeof RecipientScalarFieldEnum]


  export const AdTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    limit: 'limit',
    desktop_width: 'desktop_width',
    desktop_height: 'desktop_height',
    mobile_width: 'mobile_width',
    mobile_height: 'mobile_height',
    desktop_file_size: 'desktop_file_size',
    mobile_file_size: 'mobile_file_size',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdTypeScalarFieldEnum = (typeof AdTypeScalarFieldEnum)[keyof typeof AdTypeScalarFieldEnum]


  export const AdRatesScalarFieldEnum: {
    id: 'id',
    stateId: 'stateId',
    cityId: 'cityId',
    adTypeId: 'adTypeId',
    rate: 'rate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdRatesScalarFieldEnum = (typeof AdRatesScalarFieldEnum)[keyof typeof AdRatesScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const AdScalarFieldEnum: {
    id: 'id',
    name: 'name',
    adTypesId: 'adTypesId',
    linkUrl: 'linkUrl',
    buttonName: 'buttonName',
    desktopFile: 'desktopFile',
    mobileFile: 'mobileFile',
    font: 'font',
    text1: 'text1',
    text1Color: 'text1Color',
    text2: 'text2',
    text2Color: 'text2Color',
    bgImage: 'bgImage',
    payStatus: 'payStatus',
    status: 'status',
    totalCost: 'totalCost',
    userId: 'userId',
    categoryId: 'categoryId',
    urlVideo: 'urlVideo',
    desktopVideoFile: 'desktopVideoFile',
    desktopVideoPreview: 'desktopVideoPreview',
    mobileVideoFile: 'mobileVideoFile',
    mobileVideoPreview: 'mobileVideoPreview',
    stateId: 'stateId',
    cityId: 'cityId',
    selectedDays: 'selectedDays',
    selectedDates: 'selectedDates',
    startDate: 'startDate',
    endDate: 'endDate',
    clicks: 'clicks',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdScalarFieldEnum = (typeof AdScalarFieldEnum)[keyof typeof AdScalarFieldEnum]


  export const TermsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TermsScalarFieldEnum = (typeof TermsScalarFieldEnum)[keyof typeof TermsScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    thumbnail: 'thumbnail',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    breweryId: 'breweryId',
    approvedById: 'approvedById'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TypeText'
   */
  export type EnumTypeTextFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeText'>
    


  /**
   * Reference to a field of type 'TypeText[]'
   */
  export type ListEnumTypeTextFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeText[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'MediaStatus'
   */
  export type EnumMediaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaStatus'>
    


  /**
   * Reference to a field of type 'MediaStatus[]'
   */
  export type ListEnumMediaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    current_password?: StringNullableFilter<"User"> | string | null
    birthdate?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    state?: EnumStatusFilter<"User"> | $Enums.Status
    photo?: StringNullableFilter<"User"> | string | null
    cityId?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    ownedBreweries?: BreweryListRelationFilter
    managedBreweries?: BreweryListRelationFilter
    city?: XOR<CityRelationFilter, CityWhereInput>
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: RecipientListRelationFilter
    Tour?: TourListRelationFilter
    Ad?: AdListRelationFilter
    Media?: MediaListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    current_password?: SortOrder
    birthdate?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    state?: SortOrder
    photo?: SortOrder
    cityId?: SortOrder
    created_at?: SortOrder
    ownedBreweries?: BreweryOrderByRelationAggregateInput
    managedBreweries?: BreweryOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    receivedNotifications?: RecipientOrderByRelationAggregateInput
    Tour?: TourOrderByRelationAggregateInput
    Ad?: AdOrderByRelationAggregateInput
    Media?: MediaOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    current_password?: StringNullableFilter<"User"> | string | null
    birthdate?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    state?: EnumStatusFilter<"User"> | $Enums.Status
    photo?: StringNullableFilter<"User"> | string | null
    cityId?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    ownedBreweries?: BreweryListRelationFilter
    managedBreweries?: BreweryListRelationFilter
    city?: XOR<CityRelationFilter, CityWhereInput>
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: RecipientListRelationFilter
    Tour?: TourListRelationFilter
    Ad?: AdListRelationFilter
    Media?: MediaListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    current_password?: SortOrder
    birthdate?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    state?: SortOrder
    photo?: SortOrder
    cityId?: SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstname?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastname?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    current_password?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthdate?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    state?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityId?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StateWhereInput = {
    AND?: StateWhereInput | StateWhereInput[]
    OR?: StateWhereInput[]
    NOT?: StateWhereInput | StateWhereInput[]
    id?: StringFilter<"State"> | string
    name?: StringFilter<"State"> | string
    state_id?: StringFilter<"State"> | string
    createdAt?: DateTimeFilter<"State"> | Date | string
    updatedAt?: DateTimeFilter<"State"> | Date | string
    counties?: CountyListRelationFilter
    cities?: CityListRelationFilter
    Location?: LocationListRelationFilter
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    state_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    counties?: CountyOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
    AdRates?: AdRatesOrderByRelationAggregateInput
    Ad?: AdOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    state_id?: string
    AND?: StateWhereInput | StateWhereInput[]
    OR?: StateWhereInput[]
    NOT?: StateWhereInput | StateWhereInput[]
    name?: StringFilter<"State"> | string
    createdAt?: DateTimeFilter<"State"> | Date | string
    updatedAt?: DateTimeFilter<"State"> | Date | string
    counties?: CountyListRelationFilter
    cities?: CityListRelationFilter
    Location?: LocationListRelationFilter
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }, "id" | "state_id">

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    state_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: StateScalarWhereWithAggregatesInput | StateScalarWhereWithAggregatesInput[]
    OR?: StateScalarWhereWithAggregatesInput[]
    NOT?: StateScalarWhereWithAggregatesInput | StateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"State"> | string
    name?: StringWithAggregatesFilter<"State"> | string
    state_id?: StringWithAggregatesFilter<"State"> | string
    createdAt?: DateTimeWithAggregatesFilter<"State"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"State"> | Date | string
  }

  export type CountyWhereInput = {
    AND?: CountyWhereInput | CountyWhereInput[]
    OR?: CountyWhereInput[]
    NOT?: CountyWhereInput | CountyWhereInput[]
    id?: StringFilter<"County"> | string
    name?: StringFilter<"County"> | string
    county_fips?: StringFilter<"County"> | string
    stateId?: StringFilter<"County"> | string
    createdAt?: DateTimeFilter<"County"> | Date | string
    updatedAt?: DateTimeFilter<"County"> | Date | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    cities?: CityListRelationFilter
    Location?: LocationListRelationFilter
  }

  export type CountyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    county_fips?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    state?: StateOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
  }

  export type CountyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    county_fips?: string
    AND?: CountyWhereInput | CountyWhereInput[]
    OR?: CountyWhereInput[]
    NOT?: CountyWhereInput | CountyWhereInput[]
    name?: StringFilter<"County"> | string
    stateId?: StringFilter<"County"> | string
    createdAt?: DateTimeFilter<"County"> | Date | string
    updatedAt?: DateTimeFilter<"County"> | Date | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    cities?: CityListRelationFilter
    Location?: LocationListRelationFilter
  }, "id" | "county_fips">

  export type CountyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    county_fips?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountyCountOrderByAggregateInput
    _max?: CountyMaxOrderByAggregateInput
    _min?: CountyMinOrderByAggregateInput
  }

  export type CountyScalarWhereWithAggregatesInput = {
    AND?: CountyScalarWhereWithAggregatesInput | CountyScalarWhereWithAggregatesInput[]
    OR?: CountyScalarWhereWithAggregatesInput[]
    NOT?: CountyScalarWhereWithAggregatesInput | CountyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"County"> | string
    name?: StringWithAggregatesFilter<"County"> | string
    county_fips?: StringWithAggregatesFilter<"County"> | string
    stateId?: StringWithAggregatesFilter<"County"> | string
    createdAt?: DateTimeWithAggregatesFilter<"County"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"County"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    city_ascii?: StringNullableFilter<"City"> | string | null
    stateId?: StringFilter<"City"> | string
    countyId?: StringFilter<"City"> | string
    lat?: FloatNullableFilter<"City"> | number | null
    lng?: FloatNullableFilter<"City"> | number | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    ranking?: IntNullableFilter<"City"> | number | null
    zip?: StringNullableFilter<"City"> | string | null
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    uniqueCityIdentifier?: StringFilter<"City"> | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    county?: XOR<CountyRelationFilter, CountyWhereInput>
    User?: UserListRelationFilter
    Location?: LocationListRelationFilter
    Tour?: TourListRelationFilter
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city_ascii?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    ranking?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueCityIdentifier?: SortOrder
    state?: StateOrderByWithRelationInput
    county?: CountyOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
    Tour?: TourOrderByRelationAggregateInput
    AdRates?: AdRatesOrderByRelationAggregateInput
    Ad?: AdOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uniqueCityIdentifier?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    city_ascii?: StringNullableFilter<"City"> | string | null
    stateId?: StringFilter<"City"> | string
    countyId?: StringFilter<"City"> | string
    lat?: FloatNullableFilter<"City"> | number | null
    lng?: FloatNullableFilter<"City"> | number | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    ranking?: IntNullableFilter<"City"> | number | null
    zip?: StringNullableFilter<"City"> | string | null
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    county?: XOR<CountyRelationFilter, CountyWhereInput>
    User?: UserListRelationFilter
    Location?: LocationListRelationFilter
    Tour?: TourListRelationFilter
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }, "id" | "uniqueCityIdentifier">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city_ascii?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    ranking?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueCityIdentifier?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    city_ascii?: StringNullableWithAggregatesFilter<"City"> | string | null
    stateId?: StringWithAggregatesFilter<"City"> | string
    countyId?: StringWithAggregatesFilter<"City"> | string
    lat?: FloatNullableWithAggregatesFilter<"City"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"City"> | number | null
    population?: IntNullableWithAggregatesFilter<"City"> | number | null
    timezone?: StringNullableWithAggregatesFilter<"City"> | string | null
    ranking?: IntNullableWithAggregatesFilter<"City"> | number | null
    zip?: StringNullableWithAggregatesFilter<"City"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    uniqueCityIdentifier?: StringWithAggregatesFilter<"City"> | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    cityId?: StringFilter<"Location"> | string
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    zip?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    stateId?: StringNullableFilter<"Location"> | string | null
    countyId?: StringNullableFilter<"Location"> | string | null
    city?: XOR<CityRelationFilter, CityWhereInput>
    Brewery?: BreweryListRelationFilter
    State?: XOR<StateNullableRelationFilter, StateWhereInput> | null
    County?: XOR<CountyNullableRelationFilter, CountyWhereInput> | null
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    city?: CityOrderByWithRelationInput
    Brewery?: BreweryOrderByRelationAggregateInput
    State?: StateOrderByWithRelationInput
    County?: CountyOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    address?: StringFilter<"Location"> | string
    cityId?: StringFilter<"Location"> | string
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    zip?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    stateId?: StringNullableFilter<"Location"> | string | null
    countyId?: StringNullableFilter<"Location"> | string | null
    city?: XOR<CityRelationFilter, CityWhereInput>
    Brewery?: BreweryListRelationFilter
    State?: XOR<StateNullableRelationFilter, StateWhereInput> | null
    County?: XOR<CountyNullableRelationFilter, CountyWhereInput> | null
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    address?: StringWithAggregatesFilter<"Location"> | string
    cityId?: StringWithAggregatesFilter<"Location"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    zip?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    stateId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    countyId?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type BreweryWhereInput = {
    AND?: BreweryWhereInput | BreweryWhereInput[]
    OR?: BreweryWhereInput[]
    NOT?: BreweryWhereInput | BreweryWhereInput[]
    id?: StringFilter<"Brewery"> | string
    name?: StringFilter<"Brewery"> | string
    type?: StringNullableFilter<"Brewery"> | string | null
    website?: StringNullableFilter<"Brewery"> | string | null
    ownerId?: StringNullableFilter<"Brewery"> | string | null
    managerId?: StringNullableFilter<"Brewery"> | string | null
    comments?: StringNullableFilter<"Brewery"> | string | null
    merchandise?: BoolNullableFilter<"Brewery"> | boolean | null
    social_media?: BoolNullableFilter<"Brewery"> | boolean | null
    status?: EnumStatusFilter<"Brewery"> | $Enums.Status
    locationId?: StringFilter<"Brewery"> | string
    createdAt?: DateTimeFilter<"Brewery"> | Date | string
    updatedAt?: DateTimeFilter<"Brewery"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    features?: BreweryFeatureListRelationFilter
    beers?: BreweryBeerListRelationFilter
    foods?: BreweryFoodListRelationFilter
    services?: BreweryServiceListRelationFilter
    music?: BreweryMusicListRelationFilter
    OperatingHours?: OperatingHoursListRelationFilter
    BreweryEvent?: BreweryEventListRelationFilter
    tours?: TourBreweryListRelationFilter
    media?: MediaListRelationFilter
  }

  export type BreweryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    website?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
    comments?: SortOrder
    merchandise?: SortOrder
    social_media?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    features?: BreweryFeatureOrderByRelationAggregateInput
    beers?: BreweryBeerOrderByRelationAggregateInput
    foods?: BreweryFoodOrderByRelationAggregateInput
    services?: BreweryServiceOrderByRelationAggregateInput
    music?: BreweryMusicOrderByRelationAggregateInput
    OperatingHours?: OperatingHoursOrderByRelationAggregateInput
    BreweryEvent?: BreweryEventOrderByRelationAggregateInput
    tours?: TourBreweryOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
  }

  export type BreweryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryWhereInput | BreweryWhereInput[]
    OR?: BreweryWhereInput[]
    NOT?: BreweryWhereInput | BreweryWhereInput[]
    name?: StringFilter<"Brewery"> | string
    type?: StringNullableFilter<"Brewery"> | string | null
    website?: StringNullableFilter<"Brewery"> | string | null
    ownerId?: StringNullableFilter<"Brewery"> | string | null
    managerId?: StringNullableFilter<"Brewery"> | string | null
    comments?: StringNullableFilter<"Brewery"> | string | null
    merchandise?: BoolNullableFilter<"Brewery"> | boolean | null
    social_media?: BoolNullableFilter<"Brewery"> | boolean | null
    status?: EnumStatusFilter<"Brewery"> | $Enums.Status
    locationId?: StringFilter<"Brewery"> | string
    createdAt?: DateTimeFilter<"Brewery"> | Date | string
    updatedAt?: DateTimeFilter<"Brewery"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    features?: BreweryFeatureListRelationFilter
    beers?: BreweryBeerListRelationFilter
    foods?: BreweryFoodListRelationFilter
    services?: BreweryServiceListRelationFilter
    music?: BreweryMusicListRelationFilter
    OperatingHours?: OperatingHoursListRelationFilter
    BreweryEvent?: BreweryEventListRelationFilter
    tours?: TourBreweryListRelationFilter
    media?: MediaListRelationFilter
  }, "id">

  export type BreweryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    website?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
    comments?: SortOrder
    merchandise?: SortOrder
    social_media?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryCountOrderByAggregateInput
    _max?: BreweryMaxOrderByAggregateInput
    _min?: BreweryMinOrderByAggregateInput
  }

  export type BreweryScalarWhereWithAggregatesInput = {
    AND?: BreweryScalarWhereWithAggregatesInput | BreweryScalarWhereWithAggregatesInput[]
    OR?: BreweryScalarWhereWithAggregatesInput[]
    NOT?: BreweryScalarWhereWithAggregatesInput | BreweryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brewery"> | string
    name?: StringWithAggregatesFilter<"Brewery"> | string
    type?: StringNullableWithAggregatesFilter<"Brewery"> | string | null
    website?: StringNullableWithAggregatesFilter<"Brewery"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Brewery"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Brewery"> | string | null
    comments?: StringNullableWithAggregatesFilter<"Brewery"> | string | null
    merchandise?: BoolNullableWithAggregatesFilter<"Brewery"> | boolean | null
    social_media?: BoolNullableWithAggregatesFilter<"Brewery"> | boolean | null
    status?: EnumStatusWithAggregatesFilter<"Brewery"> | $Enums.Status
    locationId?: StringWithAggregatesFilter<"Brewery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Brewery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brewery"> | Date | string
  }

  export type BeerWhereInput = {
    AND?: BeerWhereInput | BeerWhereInput[]
    OR?: BeerWhereInput[]
    NOT?: BeerWhereInput | BeerWhereInput[]
    id?: StringFilter<"Beer"> | string
    type?: StringNullableFilter<"Beer"> | string | null
    brand?: StringNullableFilter<"Beer"> | string | null
    name?: StringNullableFilter<"Beer"> | string | null
    image?: StringNullableFilter<"Beer"> | string | null
    createdAt?: DateTimeFilter<"Beer"> | Date | string
    updatedAt?: DateTimeFilter<"Beer"> | Date | string
    breweries?: BreweryBeerListRelationFilter
  }

  export type BeerOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweries?: BreweryBeerOrderByRelationAggregateInput
  }

  export type BeerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BeerWhereInput | BeerWhereInput[]
    OR?: BeerWhereInput[]
    NOT?: BeerWhereInput | BeerWhereInput[]
    type?: StringNullableFilter<"Beer"> | string | null
    brand?: StringNullableFilter<"Beer"> | string | null
    name?: StringNullableFilter<"Beer"> | string | null
    image?: StringNullableFilter<"Beer"> | string | null
    createdAt?: DateTimeFilter<"Beer"> | Date | string
    updatedAt?: DateTimeFilter<"Beer"> | Date | string
    breweries?: BreweryBeerListRelationFilter
  }, "id">

  export type BeerOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BeerCountOrderByAggregateInput
    _max?: BeerMaxOrderByAggregateInput
    _min?: BeerMinOrderByAggregateInput
  }

  export type BeerScalarWhereWithAggregatesInput = {
    AND?: BeerScalarWhereWithAggregatesInput | BeerScalarWhereWithAggregatesInput[]
    OR?: BeerScalarWhereWithAggregatesInput[]
    NOT?: BeerScalarWhereWithAggregatesInput | BeerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Beer"> | string
    type?: StringNullableWithAggregatesFilter<"Beer"> | string | null
    brand?: StringNullableWithAggregatesFilter<"Beer"> | string | null
    name?: StringNullableWithAggregatesFilter<"Beer"> | string | null
    image?: StringNullableWithAggregatesFilter<"Beer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Beer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Beer"> | Date | string
  }

  export type BreweryBeerWhereInput = {
    AND?: BreweryBeerWhereInput | BreweryBeerWhereInput[]
    OR?: BreweryBeerWhereInput[]
    NOT?: BreweryBeerWhereInput | BreweryBeerWhereInput[]
    id?: StringFilter<"BreweryBeer"> | string
    breweryId?: StringNullableFilter<"BreweryBeer"> | string | null
    beerId?: StringFilter<"BreweryBeer"> | string
    createdAt?: DateTimeFilter<"BreweryBeer"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryBeer"> | Date | string
    brewery?: XOR<BreweryNullableRelationFilter, BreweryWhereInput> | null
    beer?: XOR<BeerRelationFilter, BeerWhereInput>
  }

  export type BreweryBeerOrderByWithRelationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    beerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    beer?: BeerOrderByWithRelationInput
  }

  export type BreweryBeerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryBeerWhereInput | BreweryBeerWhereInput[]
    OR?: BreweryBeerWhereInput[]
    NOT?: BreweryBeerWhereInput | BreweryBeerWhereInput[]
    breweryId?: StringNullableFilter<"BreweryBeer"> | string | null
    beerId?: StringFilter<"BreweryBeer"> | string
    createdAt?: DateTimeFilter<"BreweryBeer"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryBeer"> | Date | string
    brewery?: XOR<BreweryNullableRelationFilter, BreweryWhereInput> | null
    beer?: XOR<BeerRelationFilter, BeerWhereInput>
  }, "id">

  export type BreweryBeerOrderByWithAggregationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    beerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryBeerCountOrderByAggregateInput
    _max?: BreweryBeerMaxOrderByAggregateInput
    _min?: BreweryBeerMinOrderByAggregateInput
  }

  export type BreweryBeerScalarWhereWithAggregatesInput = {
    AND?: BreweryBeerScalarWhereWithAggregatesInput | BreweryBeerScalarWhereWithAggregatesInput[]
    OR?: BreweryBeerScalarWhereWithAggregatesInput[]
    NOT?: BreweryBeerScalarWhereWithAggregatesInput | BreweryBeerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryBeer"> | string
    breweryId?: StringNullableWithAggregatesFilter<"BreweryBeer"> | string | null
    beerId?: StringWithAggregatesFilter<"BreweryBeer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryBeer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryBeer"> | Date | string
  }

  export type FoodWhereInput = {
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    id?: StringFilter<"Food"> | string
    name?: StringFilter<"Food"> | string
    type?: StringNullableFilter<"Food"> | string | null
    image?: StringNullableFilter<"Food"> | string | null
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    breweries?: BreweryFoodListRelationFilter
  }

  export type FoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweries?: BreweryFoodOrderByRelationAggregateInput
  }

  export type FoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    type?: StringNullableFilter<"Food"> | string | null
    image?: StringNullableFilter<"Food"> | string | null
    createdAt?: DateTimeFilter<"Food"> | Date | string
    updatedAt?: DateTimeFilter<"Food"> | Date | string
    breweries?: BreweryFoodListRelationFilter
  }, "id" | "name">

  export type FoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodCountOrderByAggregateInput
    _max?: FoodMaxOrderByAggregateInput
    _min?: FoodMinOrderByAggregateInput
  }

  export type FoodScalarWhereWithAggregatesInput = {
    AND?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    OR?: FoodScalarWhereWithAggregatesInput[]
    NOT?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Food"> | string
    name?: StringWithAggregatesFilter<"Food"> | string
    type?: StringNullableWithAggregatesFilter<"Food"> | string | null
    image?: StringNullableWithAggregatesFilter<"Food"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Food"> | Date | string
  }

  export type BreweryFoodWhereInput = {
    AND?: BreweryFoodWhereInput | BreweryFoodWhereInput[]
    OR?: BreweryFoodWhereInput[]
    NOT?: BreweryFoodWhereInput | BreweryFoodWhereInput[]
    id?: StringFilter<"BreweryFood"> | string
    breweryId?: StringFilter<"BreweryFood"> | string
    foodId?: StringFilter<"BreweryFood"> | string
    createdAt?: DateTimeFilter<"BreweryFood"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFood"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    food?: XOR<FoodRelationFilter, FoodWhereInput>
  }

  export type BreweryFoodOrderByWithRelationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    foodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    food?: FoodOrderByWithRelationInput
  }

  export type BreweryFoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryFoodWhereInput | BreweryFoodWhereInput[]
    OR?: BreweryFoodWhereInput[]
    NOT?: BreweryFoodWhereInput | BreweryFoodWhereInput[]
    breweryId?: StringFilter<"BreweryFood"> | string
    foodId?: StringFilter<"BreweryFood"> | string
    createdAt?: DateTimeFilter<"BreweryFood"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFood"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    food?: XOR<FoodRelationFilter, FoodWhereInput>
  }, "id">

  export type BreweryFoodOrderByWithAggregationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    foodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryFoodCountOrderByAggregateInput
    _max?: BreweryFoodMaxOrderByAggregateInput
    _min?: BreweryFoodMinOrderByAggregateInput
  }

  export type BreweryFoodScalarWhereWithAggregatesInput = {
    AND?: BreweryFoodScalarWhereWithAggregatesInput | BreweryFoodScalarWhereWithAggregatesInput[]
    OR?: BreweryFoodScalarWhereWithAggregatesInput[]
    NOT?: BreweryFoodScalarWhereWithAggregatesInput | BreweryFoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryFood"> | string
    breweryId?: StringWithAggregatesFilter<"BreweryFood"> | string
    foodId?: StringWithAggregatesFilter<"BreweryFood"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryFood"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryFood"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    image?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    breweries?: BreweryServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweries?: BreweryServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    description?: StringNullableFilter<"Service"> | string | null
    image?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    breweries?: BreweryServiceListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    image?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type BreweryServiceWhereInput = {
    AND?: BreweryServiceWhereInput | BreweryServiceWhereInput[]
    OR?: BreweryServiceWhereInput[]
    NOT?: BreweryServiceWhereInput | BreweryServiceWhereInput[]
    id?: StringFilter<"BreweryService"> | string
    breweryId?: StringFilter<"BreweryService"> | string
    serviceId?: StringFilter<"BreweryService"> | string
    createdAt?: DateTimeFilter<"BreweryService"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryService"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type BreweryServiceOrderByWithRelationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BreweryServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryServiceWhereInput | BreweryServiceWhereInput[]
    OR?: BreweryServiceWhereInput[]
    NOT?: BreweryServiceWhereInput | BreweryServiceWhereInput[]
    breweryId?: StringFilter<"BreweryService"> | string
    serviceId?: StringFilter<"BreweryService"> | string
    createdAt?: DateTimeFilter<"BreweryService"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryService"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type BreweryServiceOrderByWithAggregationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryServiceCountOrderByAggregateInput
    _max?: BreweryServiceMaxOrderByAggregateInput
    _min?: BreweryServiceMinOrderByAggregateInput
  }

  export type BreweryServiceScalarWhereWithAggregatesInput = {
    AND?: BreweryServiceScalarWhereWithAggregatesInput | BreweryServiceScalarWhereWithAggregatesInput[]
    OR?: BreweryServiceScalarWhereWithAggregatesInput[]
    NOT?: BreweryServiceScalarWhereWithAggregatesInput | BreweryServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryService"> | string
    breweryId?: StringWithAggregatesFilter<"BreweryService"> | string
    serviceId?: StringWithAggregatesFilter<"BreweryService"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryService"> | Date | string
  }

  export type MusicWhereInput = {
    AND?: MusicWhereInput | MusicWhereInput[]
    OR?: MusicWhereInput[]
    NOT?: MusicWhereInput | MusicWhereInput[]
    id?: StringFilter<"Music"> | string
    genre?: StringFilter<"Music"> | string
    image?: StringNullableFilter<"Music"> | string | null
    createdAt?: DateTimeFilter<"Music"> | Date | string
    updatedAt?: DateTimeFilter<"Music"> | Date | string
    breweries?: BreweryMusicListRelationFilter
  }

  export type MusicOrderByWithRelationInput = {
    id?: SortOrder
    genre?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweries?: BreweryMusicOrderByRelationAggregateInput
  }

  export type MusicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    genre?: string
    AND?: MusicWhereInput | MusicWhereInput[]
    OR?: MusicWhereInput[]
    NOT?: MusicWhereInput | MusicWhereInput[]
    image?: StringNullableFilter<"Music"> | string | null
    createdAt?: DateTimeFilter<"Music"> | Date | string
    updatedAt?: DateTimeFilter<"Music"> | Date | string
    breweries?: BreweryMusicListRelationFilter
  }, "id" | "genre">

  export type MusicOrderByWithAggregationInput = {
    id?: SortOrder
    genre?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MusicCountOrderByAggregateInput
    _max?: MusicMaxOrderByAggregateInput
    _min?: MusicMinOrderByAggregateInput
  }

  export type MusicScalarWhereWithAggregatesInput = {
    AND?: MusicScalarWhereWithAggregatesInput | MusicScalarWhereWithAggregatesInput[]
    OR?: MusicScalarWhereWithAggregatesInput[]
    NOT?: MusicScalarWhereWithAggregatesInput | MusicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Music"> | string
    genre?: StringWithAggregatesFilter<"Music"> | string
    image?: StringNullableWithAggregatesFilter<"Music"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Music"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Music"> | Date | string
  }

  export type BreweryMusicWhereInput = {
    AND?: BreweryMusicWhereInput | BreweryMusicWhereInput[]
    OR?: BreweryMusicWhereInput[]
    NOT?: BreweryMusicWhereInput | BreweryMusicWhereInput[]
    id?: StringFilter<"BreweryMusic"> | string
    breweryId?: StringFilter<"BreweryMusic"> | string
    musicId?: StringFilter<"BreweryMusic"> | string
    createdAt?: DateTimeFilter<"BreweryMusic"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryMusic"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    music?: XOR<MusicRelationFilter, MusicWhereInput>
  }

  export type BreweryMusicOrderByWithRelationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    musicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    music?: MusicOrderByWithRelationInput
  }

  export type BreweryMusicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryMusicWhereInput | BreweryMusicWhereInput[]
    OR?: BreweryMusicWhereInput[]
    NOT?: BreweryMusicWhereInput | BreweryMusicWhereInput[]
    breweryId?: StringFilter<"BreweryMusic"> | string
    musicId?: StringFilter<"BreweryMusic"> | string
    createdAt?: DateTimeFilter<"BreweryMusic"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryMusic"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    music?: XOR<MusicRelationFilter, MusicWhereInput>
  }, "id">

  export type BreweryMusicOrderByWithAggregationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    musicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryMusicCountOrderByAggregateInput
    _max?: BreweryMusicMaxOrderByAggregateInput
    _min?: BreweryMusicMinOrderByAggregateInput
  }

  export type BreweryMusicScalarWhereWithAggregatesInput = {
    AND?: BreweryMusicScalarWhereWithAggregatesInput | BreweryMusicScalarWhereWithAggregatesInput[]
    OR?: BreweryMusicScalarWhereWithAggregatesInput[]
    NOT?: BreweryMusicScalarWhereWithAggregatesInput | BreweryMusicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryMusic"> | string
    breweryId?: StringWithAggregatesFilter<"BreweryMusic"> | string
    musicId?: StringWithAggregatesFilter<"BreweryMusic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryMusic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryMusic"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    image?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    breweries?: BreweryEventListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweries?: BreweryEventOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    image?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    breweries?: BreweryEventListRelationFilter
  }, "id" | "name">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    image?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type BreweryEventWhereInput = {
    AND?: BreweryEventWhereInput | BreweryEventWhereInput[]
    OR?: BreweryEventWhereInput[]
    NOT?: BreweryEventWhereInput | BreweryEventWhereInput[]
    id?: StringFilter<"BreweryEvent"> | string
    breweryId?: StringFilter<"BreweryEvent"> | string
    eventId?: StringFilter<"BreweryEvent"> | string
    createdAt?: DateTimeFilter<"BreweryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryEvent"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type BreweryEventOrderByWithRelationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
  }

  export type BreweryEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryEventWhereInput | BreweryEventWhereInput[]
    OR?: BreweryEventWhereInput[]
    NOT?: BreweryEventWhereInput | BreweryEventWhereInput[]
    breweryId?: StringFilter<"BreweryEvent"> | string
    eventId?: StringFilter<"BreweryEvent"> | string
    createdAt?: DateTimeFilter<"BreweryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryEvent"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "id">

  export type BreweryEventOrderByWithAggregationInput = {
    id?: SortOrder
    breweryId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryEventCountOrderByAggregateInput
    _max?: BreweryEventMaxOrderByAggregateInput
    _min?: BreweryEventMinOrderByAggregateInput
  }

  export type BreweryEventScalarWhereWithAggregatesInput = {
    AND?: BreweryEventScalarWhereWithAggregatesInput | BreweryEventScalarWhereWithAggregatesInput[]
    OR?: BreweryEventScalarWhereWithAggregatesInput[]
    NOT?: BreweryEventScalarWhereWithAggregatesInput | BreweryEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryEvent"> | string
    breweryId?: StringWithAggregatesFilter<"BreweryEvent"> | string
    eventId?: StringWithAggregatesFilter<"BreweryEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryEvent"> | Date | string
  }

  export type BreweryFeatureWhereInput = {
    AND?: BreweryFeatureWhereInput | BreweryFeatureWhereInput[]
    OR?: BreweryFeatureWhereInput[]
    NOT?: BreweryFeatureWhereInput | BreweryFeatureWhereInput[]
    id?: StringFilter<"BreweryFeature"> | string
    logo?: StringNullableFilter<"BreweryFeature"> | string | null
    image?: StringNullableFilter<"BreweryFeature"> | string | null
    description?: StringNullableFilter<"BreweryFeature"> | string | null
    phone?: StringNullableFilter<"BreweryFeature"> | string | null
    facebook?: StringNullableFilter<"BreweryFeature"> | string | null
    x?: StringNullableFilter<"BreweryFeature"> | string | null
    instagram?: StringNullableFilter<"BreweryFeature"> | string | null
    highlighted?: BoolNullableFilter<"BreweryFeature"> | boolean | null
    capacity?: StringNullableFilter<"BreweryFeature"> | string | null
    booklink?: StringNullableFilter<"BreweryFeature"> | string | null
    pricerank?: StringNullableFilter<"BreweryFeature"> | string | null
    state?: IntNullableFilter<"BreweryFeature"> | number | null
    breweryId?: StringFilter<"BreweryFeature"> | string
    createdAt?: DateTimeFilter<"BreweryFeature"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFeature"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
  }

  export type BreweryFeatureOrderByWithRelationInput = {
    id?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    phone?: SortOrder
    facebook?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    highlighted?: SortOrder
    capacity?: SortOrder
    booklink?: SortOrder
    pricerank?: SortOrder
    state?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
  }

  export type BreweryFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreweryFeatureWhereInput | BreweryFeatureWhereInput[]
    OR?: BreweryFeatureWhereInput[]
    NOT?: BreweryFeatureWhereInput | BreweryFeatureWhereInput[]
    logo?: StringNullableFilter<"BreweryFeature"> | string | null
    image?: StringNullableFilter<"BreweryFeature"> | string | null
    description?: StringNullableFilter<"BreweryFeature"> | string | null
    phone?: StringNullableFilter<"BreweryFeature"> | string | null
    facebook?: StringNullableFilter<"BreweryFeature"> | string | null
    x?: StringNullableFilter<"BreweryFeature"> | string | null
    instagram?: StringNullableFilter<"BreweryFeature"> | string | null
    highlighted?: BoolNullableFilter<"BreweryFeature"> | boolean | null
    capacity?: StringNullableFilter<"BreweryFeature"> | string | null
    booklink?: StringNullableFilter<"BreweryFeature"> | string | null
    pricerank?: StringNullableFilter<"BreweryFeature"> | string | null
    state?: IntNullableFilter<"BreweryFeature"> | number | null
    breweryId?: StringFilter<"BreweryFeature"> | string
    createdAt?: DateTimeFilter<"BreweryFeature"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFeature"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
  }, "id">

  export type BreweryFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    phone?: SortOrder
    facebook?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    highlighted?: SortOrder
    capacity?: SortOrder
    booklink?: SortOrder
    pricerank?: SortOrder
    state?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreweryFeatureCountOrderByAggregateInput
    _avg?: BreweryFeatureAvgOrderByAggregateInput
    _max?: BreweryFeatureMaxOrderByAggregateInput
    _min?: BreweryFeatureMinOrderByAggregateInput
    _sum?: BreweryFeatureSumOrderByAggregateInput
  }

  export type BreweryFeatureScalarWhereWithAggregatesInput = {
    AND?: BreweryFeatureScalarWhereWithAggregatesInput | BreweryFeatureScalarWhereWithAggregatesInput[]
    OR?: BreweryFeatureScalarWhereWithAggregatesInput[]
    NOT?: BreweryFeatureScalarWhereWithAggregatesInput | BreweryFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreweryFeature"> | string
    logo?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    image?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    description?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    phone?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    x?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    highlighted?: BoolNullableWithAggregatesFilter<"BreweryFeature"> | boolean | null
    capacity?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    booklink?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    pricerank?: StringNullableWithAggregatesFilter<"BreweryFeature"> | string | null
    state?: IntNullableWithAggregatesFilter<"BreweryFeature"> | number | null
    breweryId?: StringWithAggregatesFilter<"BreweryFeature"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreweryFeature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreweryFeature"> | Date | string
  }

  export type OperatingHoursWhereInput = {
    AND?: OperatingHoursWhereInput | OperatingHoursWhereInput[]
    OR?: OperatingHoursWhereInput[]
    NOT?: OperatingHoursWhereInput | OperatingHoursWhereInput[]
    id?: StringFilter<"OperatingHours"> | string
    mondayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    mondayClose?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    fridayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    fridayClose?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    sundayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    sundayClose?: StringNullableFilter<"OperatingHours"> | string | null
    breweryId?: StringFilter<"OperatingHours"> | string
    createdAt?: DateTimeFilter<"OperatingHours"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHours"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
  }

  export type OperatingHoursOrderByWithRelationInput = {
    id?: SortOrder
    mondayOpen?: SortOrder
    mondayClose?: SortOrder
    tuesdayOpen?: SortOrder
    tuesdayClose?: SortOrder
    wednesdayOpen?: SortOrder
    wednesdayClose?: SortOrder
    thursdayOpen?: SortOrder
    thursdayClose?: SortOrder
    fridayOpen?: SortOrder
    fridayClose?: SortOrder
    saturdayOpen?: SortOrder
    saturdayClose?: SortOrder
    sundayOpen?: SortOrder
    sundayClose?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
  }

  export type OperatingHoursWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperatingHoursWhereInput | OperatingHoursWhereInput[]
    OR?: OperatingHoursWhereInput[]
    NOT?: OperatingHoursWhereInput | OperatingHoursWhereInput[]
    mondayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    mondayClose?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    fridayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    fridayClose?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    sundayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    sundayClose?: StringNullableFilter<"OperatingHours"> | string | null
    breweryId?: StringFilter<"OperatingHours"> | string
    createdAt?: DateTimeFilter<"OperatingHours"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHours"> | Date | string
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
  }, "id">

  export type OperatingHoursOrderByWithAggregationInput = {
    id?: SortOrder
    mondayOpen?: SortOrder
    mondayClose?: SortOrder
    tuesdayOpen?: SortOrder
    tuesdayClose?: SortOrder
    wednesdayOpen?: SortOrder
    wednesdayClose?: SortOrder
    thursdayOpen?: SortOrder
    thursdayClose?: SortOrder
    fridayOpen?: SortOrder
    fridayClose?: SortOrder
    saturdayOpen?: SortOrder
    saturdayClose?: SortOrder
    sundayOpen?: SortOrder
    sundayClose?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperatingHoursCountOrderByAggregateInput
    _max?: OperatingHoursMaxOrderByAggregateInput
    _min?: OperatingHoursMinOrderByAggregateInput
  }

  export type OperatingHoursScalarWhereWithAggregatesInput = {
    AND?: OperatingHoursScalarWhereWithAggregatesInput | OperatingHoursScalarWhereWithAggregatesInput[]
    OR?: OperatingHoursScalarWhereWithAggregatesInput[]
    NOT?: OperatingHoursScalarWhereWithAggregatesInput | OperatingHoursScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperatingHours"> | string
    mondayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    mondayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    tuesdayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    tuesdayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    wednesdayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    wednesdayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    thursdayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    thursdayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    fridayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    fridayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    saturdayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    saturdayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    sundayOpen?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    sundayClose?: StringNullableWithAggregatesFilter<"OperatingHours"> | string | null
    breweryId?: StringWithAggregatesFilter<"OperatingHours"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OperatingHours"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OperatingHours"> | Date | string
  }

  export type TutorialStepsAppWhereInput = {
    AND?: TutorialStepsAppWhereInput | TutorialStepsAppWhereInput[]
    OR?: TutorialStepsAppWhereInput[]
    NOT?: TutorialStepsAppWhereInput | TutorialStepsAppWhereInput[]
    id?: StringFilter<"TutorialStepsApp"> | string
    title?: StringFilter<"TutorialStepsApp"> | string
    description?: StringFilter<"TutorialStepsApp"> | string
    web_image?: StringFilter<"TutorialStepsApp"> | string
    mobile_image?: StringFilter<"TutorialStepsApp"> | string
    orden?: IntFilter<"TutorialStepsApp"> | number
    createdAt?: DateTimeFilter<"TutorialStepsApp"> | Date | string
    updatedAt?: DateTimeFilter<"TutorialStepsApp"> | Date | string
  }

  export type TutorialStepsAppOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    web_image?: SortOrder
    mobile_image?: SortOrder
    orden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutorialStepsAppWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: TutorialStepsAppWhereInput | TutorialStepsAppWhereInput[]
    OR?: TutorialStepsAppWhereInput[]
    NOT?: TutorialStepsAppWhereInput | TutorialStepsAppWhereInput[]
    description?: StringFilter<"TutorialStepsApp"> | string
    web_image?: StringFilter<"TutorialStepsApp"> | string
    mobile_image?: StringFilter<"TutorialStepsApp"> | string
    orden?: IntFilter<"TutorialStepsApp"> | number
    createdAt?: DateTimeFilter<"TutorialStepsApp"> | Date | string
    updatedAt?: DateTimeFilter<"TutorialStepsApp"> | Date | string
  }, "id" | "title">

  export type TutorialStepsAppOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    web_image?: SortOrder
    mobile_image?: SortOrder
    orden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TutorialStepsAppCountOrderByAggregateInput
    _avg?: TutorialStepsAppAvgOrderByAggregateInput
    _max?: TutorialStepsAppMaxOrderByAggregateInput
    _min?: TutorialStepsAppMinOrderByAggregateInput
    _sum?: TutorialStepsAppSumOrderByAggregateInput
  }

  export type TutorialStepsAppScalarWhereWithAggregatesInput = {
    AND?: TutorialStepsAppScalarWhereWithAggregatesInput | TutorialStepsAppScalarWhereWithAggregatesInput[]
    OR?: TutorialStepsAppScalarWhereWithAggregatesInput[]
    NOT?: TutorialStepsAppScalarWhereWithAggregatesInput | TutorialStepsAppScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TutorialStepsApp"> | string
    title?: StringWithAggregatesFilter<"TutorialStepsApp"> | string
    description?: StringWithAggregatesFilter<"TutorialStepsApp"> | string
    web_image?: StringWithAggregatesFilter<"TutorialStepsApp"> | string
    mobile_image?: StringWithAggregatesFilter<"TutorialStepsApp"> | string
    orden?: IntWithAggregatesFilter<"TutorialStepsApp"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TutorialStepsApp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TutorialStepsApp"> | Date | string
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    name?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
  }, "id" | "name">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    name?: StringWithAggregatesFilter<"Tags"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
  }

  export type TourWhereInput = {
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    id?: StringFilter<"Tour"> | string
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    image?: StringNullableFilter<"Tour"> | string | null
    userId?: StringFilter<"Tour"> | string
    cityId?: StringFilter<"Tour"> | string
    radius?: FloatFilter<"Tour"> | number
    startDate?: DateTimeFilter<"Tour"> | Date | string
    breweryCount?: IntFilter<"Tour"> | number
    days?: IntFilter<"Tour"> | number
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    breweries?: TourBreweryListRelationFilter
    city?: XOR<CityRelationFilter, CityWhereInput>
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    radius?: SortOrder
    startDate?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    breweries?: TourBreweryOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
  }

  export type TourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    image?: StringNullableFilter<"Tour"> | string | null
    userId?: StringFilter<"Tour"> | string
    cityId?: StringFilter<"Tour"> | string
    radius?: FloatFilter<"Tour"> | number
    startDate?: DateTimeFilter<"Tour"> | Date | string
    breweryCount?: IntFilter<"Tour"> | number
    days?: IntFilter<"Tour"> | number
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    breweries?: TourBreweryListRelationFilter
    city?: XOR<CityRelationFilter, CityWhereInput>
  }, "id">

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    radius?: SortOrder
    startDate?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourCountOrderByAggregateInput
    _avg?: TourAvgOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
    _sum?: TourSumOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    OR?: TourScalarWhereWithAggregatesInput[]
    NOT?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tour"> | string
    name?: StringWithAggregatesFilter<"Tour"> | string
    description?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    image?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    userId?: StringWithAggregatesFilter<"Tour"> | string
    cityId?: StringWithAggregatesFilter<"Tour"> | string
    radius?: FloatWithAggregatesFilter<"Tour"> | number
    startDate?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    breweryCount?: IntWithAggregatesFilter<"Tour"> | number
    days?: IntWithAggregatesFilter<"Tour"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
  }

  export type TourBreweryWhereInput = {
    AND?: TourBreweryWhereInput | TourBreweryWhereInput[]
    OR?: TourBreweryWhereInput[]
    NOT?: TourBreweryWhereInput | TourBreweryWhereInput[]
    id?: StringFilter<"TourBrewery"> | string
    tourId?: StringFilter<"TourBrewery"> | string
    breweryId?: StringNullableFilter<"TourBrewery"> | string | null
    distance?: FloatFilter<"TourBrewery"> | number
    createdAt?: DateTimeFilter<"TourBrewery"> | Date | string
    updatedAt?: DateTimeFilter<"TourBrewery"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    brewery?: XOR<BreweryNullableRelationFilter, BreweryWhereInput> | null
  }

  export type TourBreweryOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    breweryId?: SortOrder
    distance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tour?: TourOrderByWithRelationInput
    brewery?: BreweryOrderByWithRelationInput
  }

  export type TourBreweryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourBreweryWhereInput | TourBreweryWhereInput[]
    OR?: TourBreweryWhereInput[]
    NOT?: TourBreweryWhereInput | TourBreweryWhereInput[]
    tourId?: StringFilter<"TourBrewery"> | string
    breweryId?: StringNullableFilter<"TourBrewery"> | string | null
    distance?: FloatFilter<"TourBrewery"> | number
    createdAt?: DateTimeFilter<"TourBrewery"> | Date | string
    updatedAt?: DateTimeFilter<"TourBrewery"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    brewery?: XOR<BreweryNullableRelationFilter, BreweryWhereInput> | null
  }, "id">

  export type TourBreweryOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    breweryId?: SortOrder
    distance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourBreweryCountOrderByAggregateInput
    _avg?: TourBreweryAvgOrderByAggregateInput
    _max?: TourBreweryMaxOrderByAggregateInput
    _min?: TourBreweryMinOrderByAggregateInput
    _sum?: TourBrewerySumOrderByAggregateInput
  }

  export type TourBreweryScalarWhereWithAggregatesInput = {
    AND?: TourBreweryScalarWhereWithAggregatesInput | TourBreweryScalarWhereWithAggregatesInput[]
    OR?: TourBreweryScalarWhereWithAggregatesInput[]
    NOT?: TourBreweryScalarWhereWithAggregatesInput | TourBreweryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TourBrewery"> | string
    tourId?: StringWithAggregatesFilter<"TourBrewery"> | string
    breweryId?: StringNullableWithAggregatesFilter<"TourBrewery"> | string | null
    distance?: FloatWithAggregatesFilter<"TourBrewery"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TourBrewery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TourBrewery"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipients?: RecipientListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipients?: RecipientOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipients?: RecipientListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type RecipientWhereInput = {
    AND?: RecipientWhereInput | RecipientWhereInput[]
    OR?: RecipientWhereInput[]
    NOT?: RecipientWhereInput | RecipientWhereInput[]
    id?: StringFilter<"Recipient"> | string
    notificationId?: StringFilter<"Recipient"> | string
    userId?: StringFilter<"Recipient"> | string
    read?: BoolFilter<"Recipient"> | boolean
    createdAt?: DateTimeFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeFilter<"Recipient"> | Date | string
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    recipient?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RecipientOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
  }

  export type RecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipientWhereInput | RecipientWhereInput[]
    OR?: RecipientWhereInput[]
    NOT?: RecipientWhereInput | RecipientWhereInput[]
    notificationId?: StringFilter<"Recipient"> | string
    userId?: StringFilter<"Recipient"> | string
    read?: BoolFilter<"Recipient"> | boolean
    createdAt?: DateTimeFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeFilter<"Recipient"> | Date | string
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    recipient?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RecipientOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecipientCountOrderByAggregateInput
    _max?: RecipientMaxOrderByAggregateInput
    _min?: RecipientMinOrderByAggregateInput
  }

  export type RecipientScalarWhereWithAggregatesInput = {
    AND?: RecipientScalarWhereWithAggregatesInput | RecipientScalarWhereWithAggregatesInput[]
    OR?: RecipientScalarWhereWithAggregatesInput[]
    NOT?: RecipientScalarWhereWithAggregatesInput | RecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipient"> | string
    notificationId?: StringWithAggregatesFilter<"Recipient"> | string
    userId?: StringWithAggregatesFilter<"Recipient"> | string
    read?: BoolWithAggregatesFilter<"Recipient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipient"> | Date | string
  }

  export type AdTypeWhereInput = {
    AND?: AdTypeWhereInput | AdTypeWhereInput[]
    OR?: AdTypeWhereInput[]
    NOT?: AdTypeWhereInput | AdTypeWhereInput[]
    id?: StringFilter<"AdType"> | string
    name?: StringFilter<"AdType"> | string
    description?: StringNullableFilter<"AdType"> | string | null
    image?: StringNullableFilter<"AdType"> | string | null
    limit?: IntFilter<"AdType"> | number
    desktop_width?: IntFilter<"AdType"> | number
    desktop_height?: IntFilter<"AdType"> | number
    mobile_width?: IntFilter<"AdType"> | number
    mobile_height?: IntFilter<"AdType"> | number
    desktop_file_size?: IntFilter<"AdType"> | number
    mobile_file_size?: IntFilter<"AdType"> | number
    status?: EnumStatusFilter<"AdType"> | $Enums.Status
    createdAt?: DateTimeFilter<"AdType"> | Date | string
    updatedAt?: DateTimeFilter<"AdType"> | Date | string
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }

  export type AdTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AdRates?: AdRatesOrderByRelationAggregateInput
    Ad?: AdOrderByRelationAggregateInput
  }

  export type AdTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AdTypeWhereInput | AdTypeWhereInput[]
    OR?: AdTypeWhereInput[]
    NOT?: AdTypeWhereInput | AdTypeWhereInput[]
    description?: StringNullableFilter<"AdType"> | string | null
    image?: StringNullableFilter<"AdType"> | string | null
    limit?: IntFilter<"AdType"> | number
    desktop_width?: IntFilter<"AdType"> | number
    desktop_height?: IntFilter<"AdType"> | number
    mobile_width?: IntFilter<"AdType"> | number
    mobile_height?: IntFilter<"AdType"> | number
    desktop_file_size?: IntFilter<"AdType"> | number
    mobile_file_size?: IntFilter<"AdType"> | number
    status?: EnumStatusFilter<"AdType"> | $Enums.Status
    createdAt?: DateTimeFilter<"AdType"> | Date | string
    updatedAt?: DateTimeFilter<"AdType"> | Date | string
    AdRates?: AdRatesListRelationFilter
    Ad?: AdListRelationFilter
  }, "id" | "name">

  export type AdTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdTypeCountOrderByAggregateInput
    _avg?: AdTypeAvgOrderByAggregateInput
    _max?: AdTypeMaxOrderByAggregateInput
    _min?: AdTypeMinOrderByAggregateInput
    _sum?: AdTypeSumOrderByAggregateInput
  }

  export type AdTypeScalarWhereWithAggregatesInput = {
    AND?: AdTypeScalarWhereWithAggregatesInput | AdTypeScalarWhereWithAggregatesInput[]
    OR?: AdTypeScalarWhereWithAggregatesInput[]
    NOT?: AdTypeScalarWhereWithAggregatesInput | AdTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdType"> | string
    name?: StringWithAggregatesFilter<"AdType"> | string
    description?: StringNullableWithAggregatesFilter<"AdType"> | string | null
    image?: StringNullableWithAggregatesFilter<"AdType"> | string | null
    limit?: IntWithAggregatesFilter<"AdType"> | number
    desktop_width?: IntWithAggregatesFilter<"AdType"> | number
    desktop_height?: IntWithAggregatesFilter<"AdType"> | number
    mobile_width?: IntWithAggregatesFilter<"AdType"> | number
    mobile_height?: IntWithAggregatesFilter<"AdType"> | number
    desktop_file_size?: IntWithAggregatesFilter<"AdType"> | number
    mobile_file_size?: IntWithAggregatesFilter<"AdType"> | number
    status?: EnumStatusWithAggregatesFilter<"AdType"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"AdType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdType"> | Date | string
  }

  export type AdRatesWhereInput = {
    AND?: AdRatesWhereInput | AdRatesWhereInput[]
    OR?: AdRatesWhereInput[]
    NOT?: AdRatesWhereInput | AdRatesWhereInput[]
    id?: StringFilter<"AdRates"> | string
    stateId?: StringFilter<"AdRates"> | string
    cityId?: StringFilter<"AdRates"> | string
    adTypeId?: StringFilter<"AdRates"> | string
    rate?: FloatFilter<"AdRates"> | number
    status?: EnumStatusFilter<"AdRates"> | $Enums.Status
    createdAt?: DateTimeFilter<"AdRates"> | Date | string
    updatedAt?: DateTimeFilter<"AdRates"> | Date | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    adType?: XOR<AdTypeRelationFilter, AdTypeWhereInput>
  }

  export type AdRatesOrderByWithRelationInput = {
    id?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    adTypeId?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    state?: StateOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    adType?: AdTypeOrderByWithRelationInput
  }

  export type AdRatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdRatesWhereInput | AdRatesWhereInput[]
    OR?: AdRatesWhereInput[]
    NOT?: AdRatesWhereInput | AdRatesWhereInput[]
    stateId?: StringFilter<"AdRates"> | string
    cityId?: StringFilter<"AdRates"> | string
    adTypeId?: StringFilter<"AdRates"> | string
    rate?: FloatFilter<"AdRates"> | number
    status?: EnumStatusFilter<"AdRates"> | $Enums.Status
    createdAt?: DateTimeFilter<"AdRates"> | Date | string
    updatedAt?: DateTimeFilter<"AdRates"> | Date | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    adType?: XOR<AdTypeRelationFilter, AdTypeWhereInput>
  }, "id">

  export type AdRatesOrderByWithAggregationInput = {
    id?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    adTypeId?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdRatesCountOrderByAggregateInput
    _avg?: AdRatesAvgOrderByAggregateInput
    _max?: AdRatesMaxOrderByAggregateInput
    _min?: AdRatesMinOrderByAggregateInput
    _sum?: AdRatesSumOrderByAggregateInput
  }

  export type AdRatesScalarWhereWithAggregatesInput = {
    AND?: AdRatesScalarWhereWithAggregatesInput | AdRatesScalarWhereWithAggregatesInput[]
    OR?: AdRatesScalarWhereWithAggregatesInput[]
    NOT?: AdRatesScalarWhereWithAggregatesInput | AdRatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdRates"> | string
    stateId?: StringWithAggregatesFilter<"AdRates"> | string
    cityId?: StringWithAggregatesFilter<"AdRates"> | string
    adTypeId?: StringWithAggregatesFilter<"AdRates"> | string
    rate?: FloatWithAggregatesFilter<"AdRates"> | number
    status?: EnumStatusWithAggregatesFilter<"AdRates"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"AdRates"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdRates"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    Ad?: AdListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Ad?: AdOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    Ad?: AdListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type AdWhereInput = {
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    id?: StringFilter<"Ad"> | string
    name?: StringFilter<"Ad"> | string
    adTypesId?: StringFilter<"Ad"> | string
    linkUrl?: StringNullableFilter<"Ad"> | string | null
    buttonName?: StringNullableFilter<"Ad"> | string | null
    desktopFile?: StringNullableFilter<"Ad"> | string | null
    mobileFile?: StringNullableFilter<"Ad"> | string | null
    font?: StringNullableFilter<"Ad"> | string | null
    text1?: StringNullableFilter<"Ad"> | string | null
    text1Color?: StringNullableFilter<"Ad"> | string | null
    text2?: StringNullableFilter<"Ad"> | string | null
    text2Color?: StringNullableFilter<"Ad"> | string | null
    bgImage?: StringNullableFilter<"Ad"> | string | null
    payStatus?: StringNullableFilter<"Ad"> | string | null
    status?: EnumStatusFilter<"Ad"> | $Enums.Status
    totalCost?: FloatNullableFilter<"Ad"> | number | null
    userId?: StringNullableFilter<"Ad"> | string | null
    categoryId?: StringFilter<"Ad"> | string
    urlVideo?: StringFilter<"Ad"> | string
    desktopVideoFile?: StringFilter<"Ad"> | string
    desktopVideoPreview?: StringFilter<"Ad"> | string
    mobileVideoFile?: StringFilter<"Ad"> | string
    mobileVideoPreview?: StringFilter<"Ad"> | string
    stateId?: StringNullableFilter<"Ad"> | string | null
    cityId?: StringNullableFilter<"Ad"> | string | null
    selectedDays?: IntNullableListFilter<"Ad">
    selectedDates?: DateTimeNullableListFilter<"Ad">
    startDate?: DateTimeFilter<"Ad"> | Date | string
    endDate?: DateTimeFilter<"Ad"> | Date | string
    clicks?: IntFilter<"Ad"> | number
    views?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
    adType?: XOR<AdTypeRelationFilter, AdTypeWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    state?: XOR<StateNullableRelationFilter, StateWhereInput> | null
    city?: XOR<CityNullableRelationFilter, CityWhereInput> | null
  }

  export type AdOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    adTypesId?: SortOrder
    linkUrl?: SortOrder
    buttonName?: SortOrder
    desktopFile?: SortOrder
    mobileFile?: SortOrder
    font?: SortOrder
    text1?: SortOrder
    text1Color?: SortOrder
    text2?: SortOrder
    text2Color?: SortOrder
    bgImage?: SortOrder
    payStatus?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    urlVideo?: SortOrder
    desktopVideoFile?: SortOrder
    desktopVideoPreview?: SortOrder
    mobileVideoFile?: SortOrder
    mobileVideoPreview?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    selectedDays?: SortOrder
    selectedDates?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adType?: AdTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    state?: StateOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
  }

  export type AdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    name?: StringFilter<"Ad"> | string
    adTypesId?: StringFilter<"Ad"> | string
    linkUrl?: StringNullableFilter<"Ad"> | string | null
    buttonName?: StringNullableFilter<"Ad"> | string | null
    desktopFile?: StringNullableFilter<"Ad"> | string | null
    mobileFile?: StringNullableFilter<"Ad"> | string | null
    font?: StringNullableFilter<"Ad"> | string | null
    text1?: StringNullableFilter<"Ad"> | string | null
    text1Color?: StringNullableFilter<"Ad"> | string | null
    text2?: StringNullableFilter<"Ad"> | string | null
    text2Color?: StringNullableFilter<"Ad"> | string | null
    bgImage?: StringNullableFilter<"Ad"> | string | null
    payStatus?: StringNullableFilter<"Ad"> | string | null
    status?: EnumStatusFilter<"Ad"> | $Enums.Status
    totalCost?: FloatNullableFilter<"Ad"> | number | null
    userId?: StringNullableFilter<"Ad"> | string | null
    categoryId?: StringFilter<"Ad"> | string
    urlVideo?: StringFilter<"Ad"> | string
    desktopVideoFile?: StringFilter<"Ad"> | string
    desktopVideoPreview?: StringFilter<"Ad"> | string
    mobileVideoFile?: StringFilter<"Ad"> | string
    mobileVideoPreview?: StringFilter<"Ad"> | string
    stateId?: StringNullableFilter<"Ad"> | string | null
    cityId?: StringNullableFilter<"Ad"> | string | null
    selectedDays?: IntNullableListFilter<"Ad">
    selectedDates?: DateTimeNullableListFilter<"Ad">
    startDate?: DateTimeFilter<"Ad"> | Date | string
    endDate?: DateTimeFilter<"Ad"> | Date | string
    clicks?: IntFilter<"Ad"> | number
    views?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
    adType?: XOR<AdTypeRelationFilter, AdTypeWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    state?: XOR<StateNullableRelationFilter, StateWhereInput> | null
    city?: XOR<CityNullableRelationFilter, CityWhereInput> | null
  }, "id">

  export type AdOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    adTypesId?: SortOrder
    linkUrl?: SortOrder
    buttonName?: SortOrder
    desktopFile?: SortOrder
    mobileFile?: SortOrder
    font?: SortOrder
    text1?: SortOrder
    text1Color?: SortOrder
    text2?: SortOrder
    text2Color?: SortOrder
    bgImage?: SortOrder
    payStatus?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    urlVideo?: SortOrder
    desktopVideoFile?: SortOrder
    desktopVideoPreview?: SortOrder
    mobileVideoFile?: SortOrder
    mobileVideoPreview?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    selectedDays?: SortOrder
    selectedDates?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdCountOrderByAggregateInput
    _avg?: AdAvgOrderByAggregateInput
    _max?: AdMaxOrderByAggregateInput
    _min?: AdMinOrderByAggregateInput
    _sum?: AdSumOrderByAggregateInput
  }

  export type AdScalarWhereWithAggregatesInput = {
    AND?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    OR?: AdScalarWhereWithAggregatesInput[]
    NOT?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ad"> | string
    name?: StringWithAggregatesFilter<"Ad"> | string
    adTypesId?: StringWithAggregatesFilter<"Ad"> | string
    linkUrl?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    buttonName?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    desktopFile?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    mobileFile?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    font?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    text1?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    text1Color?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    text2?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    text2Color?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    bgImage?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    payStatus?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Ad"> | $Enums.Status
    totalCost?: FloatNullableWithAggregatesFilter<"Ad"> | number | null
    userId?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    categoryId?: StringWithAggregatesFilter<"Ad"> | string
    urlVideo?: StringWithAggregatesFilter<"Ad"> | string
    desktopVideoFile?: StringWithAggregatesFilter<"Ad"> | string
    desktopVideoPreview?: StringWithAggregatesFilter<"Ad"> | string
    mobileVideoFile?: StringWithAggregatesFilter<"Ad"> | string
    mobileVideoPreview?: StringWithAggregatesFilter<"Ad"> | string
    stateId?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    selectedDays?: IntNullableListFilter<"Ad">
    selectedDates?: DateTimeNullableListFilter<"Ad">
    startDate?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    clicks?: IntWithAggregatesFilter<"Ad"> | number
    views?: IntWithAggregatesFilter<"Ad"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
  }

  export type TermsWhereInput = {
    AND?: TermsWhereInput | TermsWhereInput[]
    OR?: TermsWhereInput[]
    NOT?: TermsWhereInput | TermsWhereInput[]
    id?: StringFilter<"Terms"> | string
    title?: StringFilter<"Terms"> | string
    content?: StringFilter<"Terms"> | string
    type?: EnumTypeTextFilter<"Terms"> | $Enums.TypeText
    createdAt?: DateTimeFilter<"Terms"> | Date | string
    updatedAt?: DateTimeFilter<"Terms"> | Date | string
  }

  export type TermsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: TermsWhereInput | TermsWhereInput[]
    OR?: TermsWhereInput[]
    NOT?: TermsWhereInput | TermsWhereInput[]
    content?: StringFilter<"Terms"> | string
    type?: EnumTypeTextFilter<"Terms"> | $Enums.TypeText
    createdAt?: DateTimeFilter<"Terms"> | Date | string
    updatedAt?: DateTimeFilter<"Terms"> | Date | string
  }, "id" | "title">

  export type TermsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TermsCountOrderByAggregateInput
    _max?: TermsMaxOrderByAggregateInput
    _min?: TermsMinOrderByAggregateInput
  }

  export type TermsScalarWhereWithAggregatesInput = {
    AND?: TermsScalarWhereWithAggregatesInput | TermsScalarWhereWithAggregatesInput[]
    OR?: TermsScalarWhereWithAggregatesInput[]
    NOT?: TermsScalarWhereWithAggregatesInput | TermsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Terms"> | string
    title?: StringWithAggregatesFilter<"Terms"> | string
    content?: StringWithAggregatesFilter<"Terms"> | string
    type?: EnumTypeTextWithAggregatesFilter<"Terms"> | $Enums.TypeText
    createdAt?: DateTimeWithAggregatesFilter<"Terms"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Terms"> | Date | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: StringFilter<"Feature"> | string
    name?: StringFilter<"Feature"> | string
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }, "id" | "name">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feature"> | string
    name?: StringWithAggregatesFilter<"Feature"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    url?: StringFilter<"Media"> | string
    thumbnail?: StringNullableFilter<"Media"> | string | null
    status?: EnumMediaStatusFilter<"Media"> | $Enums.MediaStatus
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    breweryId?: StringFilter<"Media"> | string
    approvedById?: StringNullableFilter<"Media"> | string | null
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweryId?: SortOrder
    approvedById?: SortOrder
    brewery?: BreweryOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    url?: StringFilter<"Media"> | string
    thumbnail?: StringNullableFilter<"Media"> | string | null
    status?: EnumMediaStatusFilter<"Media"> | $Enums.MediaStatus
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    breweryId?: StringFilter<"Media"> | string
    approvedById?: StringNullableFilter<"Media"> | string | null
    brewery?: XOR<BreweryRelationFilter, BreweryWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweryId?: SortOrder
    approvedById?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"Media"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Media"> | string | null
    status?: EnumMediaStatusWithAggregatesFilter<"Media"> | $Enums.MediaStatus
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    breweryId?: StringWithAggregatesFilter<"Media"> | string
    approvedById?: StringNullableWithAggregatesFilter<"Media"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    Location?: LocationCreateNestedManyWithoutStateInput
    AdRates?: AdRatesCreateNestedManyWithoutStateInput
    Ad?: AdCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    Location?: LocationUncheckedCreateNestedManyWithoutStateInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutStateInput
    Ad?: AdUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    Location?: LocationUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUpdateManyWithoutStateNestedInput
    Ad?: AdUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutStateNestedInput
    Ad?: AdUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateCreateManyInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyCreateInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutCountiesInput
    cities?: CityCreateNestedManyWithoutCountyInput
    Location?: LocationCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateInput = {
    id?: string
    name: string
    county_fips: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutCountyInput
    Location?: LocationUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutCountiesNestedInput
    cities?: CityUpdateManyWithoutCountyNestedInput
    Location?: LocationUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutCountyNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type CountyCreateManyInput = {
    id?: string
    name: string
    county_fips: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutLocationInput
    Brewery?: BreweryCreateNestedManyWithoutLocationInput
    State?: StateCreateNestedOneWithoutLocationInput
    County?: CountyCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    countyId?: string | null
    Brewery?: BreweryUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutLocationNestedInput
    Brewery?: BreweryUpdateManyWithoutLocationNestedInput
    State?: StateUpdateOneWithoutLocationNestedInput
    County?: CountyUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    Brewery?: BreweryUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    countyId?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreweryCreateInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryCreateManyInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeerCreateInput = {
    id?: string
    type?: string | null
    brand?: string | null
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryBeerCreateNestedManyWithoutBeerInput
  }

  export type BeerUncheckedCreateInput = {
    id?: string
    type?: string | null
    brand?: string | null
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryBeerUncheckedCreateNestedManyWithoutBeerInput
  }

  export type BeerUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryBeerUpdateManyWithoutBeerNestedInput
  }

  export type BeerUncheckedUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryBeerUncheckedUpdateManyWithoutBeerNestedInput
  }

  export type BeerCreateManyInput = {
    id?: string
    type?: string | null
    brand?: string | null
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeerUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeerUncheckedUpdateManyInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery?: BreweryCreateNestedOneWithoutBeersInput
    beer: BeerCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryBeerUncheckedCreateInput = {
    id?: string
    breweryId?: string | null
    beerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneWithoutBeersNestedInput
    beer?: BeerUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryBeerUncheckedUpdateInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    beerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerCreateManyInput = {
    id?: string
    breweryId?: string | null
    beerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerUncheckedUpdateManyInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    beerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCreateInput = {
    id?: string
    name: string
    type?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryFoodCreateNestedManyWithoutFoodInput
  }

  export type FoodUncheckedCreateInput = {
    id?: string
    name: string
    type?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryFoodUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryFoodUpdateManyWithoutFoodNestedInput
  }

  export type FoodUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryFoodUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type FoodCreateManyInput = {
    id?: string
    name: string
    type?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutFoodsInput
    food: FoodCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryFoodUncheckedCreateInput = {
    id?: string
    breweryId: string
    foodId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutFoodsNestedInput
    food?: FoodUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryFoodUncheckedUpdateInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodCreateManyInput = {
    id?: string
    breweryId: string
    foodId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodUncheckedUpdateManyInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryServiceUncheckedCreateInput = {
    id?: string
    breweryId: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryServiceUncheckedUpdateInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceCreateManyInput = {
    id?: string
    breweryId: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceUncheckedUpdateManyInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusicCreateInput = {
    id?: string
    genre: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryMusicCreateNestedManyWithoutMusicInput
  }

  export type MusicUncheckedCreateInput = {
    id?: string
    genre: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryMusicUncheckedCreateNestedManyWithoutMusicInput
  }

  export type MusicUpdateInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryMusicUpdateManyWithoutMusicNestedInput
  }

  export type MusicUncheckedUpdateInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryMusicUncheckedUpdateManyWithoutMusicNestedInput
  }

  export type MusicCreateManyInput = {
    id?: string
    genre: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MusicUpdateManyMutationInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusicUncheckedUpdateManyInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutMusicInput
    music: MusicCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryMusicUncheckedCreateInput = {
    id?: string
    breweryId: string
    musicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutMusicNestedInput
    music?: MusicUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryMusicUncheckedUpdateInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    musicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicCreateManyInput = {
    id?: string
    breweryId: string
    musicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicUncheckedUpdateManyInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    musicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: BreweryEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: BreweryEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutBreweryEventInput
    event: EventCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryEventUncheckedCreateInput = {
    id?: string
    breweryId: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutBreweryEventNestedInput
    event?: EventUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryEventUncheckedUpdateInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventCreateManyInput = {
    id?: string
    breweryId: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventUncheckedUpdateManyInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureCreateInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutFeaturesInput
  }

  export type BreweryFeatureUncheckedCreateInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFeatureUpdateInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type BreweryFeatureUncheckedUpdateInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureCreateManyInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFeatureUpdateManyMutationInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureUncheckedUpdateManyInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursCreateInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutOperatingHoursInput
  }

  export type OperatingHoursUncheckedCreateInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHoursUpdateInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutOperatingHoursNestedInput
  }

  export type OperatingHoursUncheckedUpdateInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursCreateManyInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHoursUpdateManyMutationInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursUncheckedUpdateManyInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorialStepsAppCreateInput = {
    id?: string
    title: string
    description: string
    web_image: string
    mobile_image: string
    orden: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutorialStepsAppUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    web_image: string
    mobile_image: string
    orden: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutorialStepsAppUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    web_image?: StringFieldUpdateOperationsInput | string
    mobile_image?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorialStepsAppUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    web_image?: StringFieldUpdateOperationsInput | string
    mobile_image?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorialStepsAppCreateManyInput = {
    id?: string
    title: string
    description: string
    web_image: string
    mobile_image: string
    orden: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TutorialStepsAppUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    web_image?: StringFieldUpdateOperationsInput | string
    mobile_image?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorialStepsAppUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    web_image?: StringFieldUpdateOperationsInput | string
    mobile_image?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTourInput
    breweries?: TourBreweryCreateNestedManyWithoutTourInput
    city: CityCreateNestedOneWithoutTourInput
  }

  export type TourUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    userId: string
    cityId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: TourBreweryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTourNestedInput
    breweries?: TourBreweryUpdateManyWithoutTourNestedInput
    city?: CityUpdateOneRequiredWithoutTourNestedInput
  }

  export type TourUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: TourBreweryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    userId: string
    cityId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryCreateInput = {
    id?: string
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tour: TourCreateNestedOneWithoutBreweriesInput
    brewery?: BreweryCreateNestedOneWithoutToursInput
  }

  export type TourBreweryUncheckedCreateInput = {
    id?: string
    tourId: string
    breweryId?: string | null
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryUpdateInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutBreweriesNestedInput
    brewery?: BreweryUpdateOneWithoutToursNestedInput
  }

  export type TourBreweryUncheckedUpdateInput = {
    tourId?: StringFieldUpdateOperationsInput | string
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryCreateManyInput = {
    id?: string
    tourId: string
    breweryId?: string | null
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryUpdateManyMutationInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryUncheckedUpdateManyInput = {
    tourId?: StringFieldUpdateOperationsInput | string
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentNotificationsInput
    recipients?: RecipientCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: RecipientUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
    recipients?: RecipientUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: RecipientUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientCreateInput = {
    id?: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
    recipient: UserCreateNestedOneWithoutReceivedNotificationsInput
  }

  export type RecipientUncheckedCreateInput = {
    id?: string
    notificationId: string
    userId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUpdateInput = {
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
  }

  export type RecipientUncheckedUpdateInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientCreateManyInput = {
    id?: string
    notificationId: string
    userId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUpdateManyMutationInput = {
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUncheckedUpdateManyInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    AdRates?: AdRatesCreateNestedManyWithoutAdTypeInput
    Ad?: AdCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutAdTypeInput
    Ad?: AdUncheckedCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdRates?: AdRatesUpdateManyWithoutAdTypeNestedInput
    Ad?: AdUpdateManyWithoutAdTypeNestedInput
  }

  export type AdTypeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdRates?: AdRatesUncheckedUpdateManyWithoutAdTypeNestedInput
    Ad?: AdUncheckedUpdateManyWithoutAdTypeNestedInput
  }

  export type AdTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdTypeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesCreateInput = {
    id?: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutAdRatesInput
    city: CityCreateNestedOneWithoutAdRatesInput
    adType: AdTypeCreateNestedOneWithoutAdRatesInput
  }

  export type AdRatesUncheckedCreateInput = {
    id?: string
    stateId: string
    cityId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesUpdateInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutAdRatesNestedInput
    city?: CityUpdateOneRequiredWithoutAdRatesNestedInput
    adType?: AdTypeUpdateOneRequiredWithoutAdRatesNestedInput
  }

  export type AdRatesUncheckedUpdateInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesCreateManyInput = {
    id?: string
    stateId: string
    cityId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesUpdateManyMutationInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesUncheckedUpdateManyInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Ad?: AdCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Ad?: AdUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ad?: AdUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ad?: AdUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCreateInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adType: AdTypeCreateNestedOneWithoutAdInput
    user?: UserCreateNestedOneWithoutAdInput
    category: CategoryCreateNestedOneWithoutAdInput
    state?: StateCreateNestedOneWithoutAdInput
    city?: CityCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adType?: AdTypeUpdateOneRequiredWithoutAdNestedInput
    user?: UserUpdateOneWithoutAdNestedInput
    category?: CategoryUpdateOneRequiredWithoutAdNestedInput
    state?: StateUpdateOneWithoutAdNestedInput
    city?: CityUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCreateManyInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsCreateInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TypeText
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TypeText
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeTextFieldUpdateOperationsInput | $Enums.TypeText
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeTextFieldUpdateOperationsInput | $Enums.TypeText
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsCreateManyInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TypeText
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeTextFieldUpdateOperationsInput | $Enums.TypeText
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeTextFieldUpdateOperationsInput | $Enums.TypeText
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutMediaInput
    approvedBy?: UserCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    breweryId: string
    approvedById?: string | null
  }

  export type MediaUpdateInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutMediaNestedInput
    approvedBy?: UserUpdateOneWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateManyInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    breweryId: string
    approvedById?: string | null
  }

  export type MediaUpdateManyMutationInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BreweryListRelationFilter = {
    every?: BreweryWhereInput
    some?: BreweryWhereInput
    none?: BreweryWhereInput
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type RecipientListRelationFilter = {
    every?: RecipientWhereInput
    some?: RecipientWhereInput
    none?: RecipientWhereInput
  }

  export type TourListRelationFilter = {
    every?: TourWhereInput
    some?: TourWhereInput
    none?: TourWhereInput
  }

  export type AdListRelationFilter = {
    every?: AdWhereInput
    some?: AdWhereInput
    none?: AdWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type BreweryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    current_password?: SortOrder
    birthdate?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    state?: SortOrder
    photo?: SortOrder
    cityId?: SortOrder
    created_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    current_password?: SortOrder
    birthdate?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    state?: SortOrder
    photo?: SortOrder
    cityId?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    current_password?: SortOrder
    birthdate?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    state?: SortOrder
    photo?: SortOrder
    cityId?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CountyListRelationFilter = {
    every?: CountyWhereInput
    some?: CountyWhereInput
    none?: CountyWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type AdRatesListRelationFilter = {
    every?: AdRatesWhereInput
    some?: AdRatesWhereInput
    none?: AdRatesWhereInput
  }

  export type CountyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdRatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CountyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county_fips?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county_fips?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county_fips?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type CountyRelationFilter = {
    is?: CountyWhereInput
    isNot?: CountyWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_ascii?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    ranking?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueCityIdentifier?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    ranking?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_ascii?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    ranking?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueCityIdentifier?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_ascii?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    timezone?: SortOrder
    ranking?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueCityIdentifier?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    population?: SortOrder
    ranking?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StateNullableRelationFilter = {
    is?: StateWhereInput | null
    isNot?: StateWhereInput | null
  }

  export type CountyNullableRelationFilter = {
    is?: CountyWhereInput | null
    isNot?: CountyWhereInput | null
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stateId?: SortOrder
    countyId?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BreweryFeatureListRelationFilter = {
    every?: BreweryFeatureWhereInput
    some?: BreweryFeatureWhereInput
    none?: BreweryFeatureWhereInput
  }

  export type BreweryBeerListRelationFilter = {
    every?: BreweryBeerWhereInput
    some?: BreweryBeerWhereInput
    none?: BreweryBeerWhereInput
  }

  export type BreweryFoodListRelationFilter = {
    every?: BreweryFoodWhereInput
    some?: BreweryFoodWhereInput
    none?: BreweryFoodWhereInput
  }

  export type BreweryServiceListRelationFilter = {
    every?: BreweryServiceWhereInput
    some?: BreweryServiceWhereInput
    none?: BreweryServiceWhereInput
  }

  export type BreweryMusicListRelationFilter = {
    every?: BreweryMusicWhereInput
    some?: BreweryMusicWhereInput
    none?: BreweryMusicWhereInput
  }

  export type OperatingHoursListRelationFilter = {
    every?: OperatingHoursWhereInput
    some?: OperatingHoursWhereInput
    none?: OperatingHoursWhereInput
  }

  export type BreweryEventListRelationFilter = {
    every?: BreweryEventWhereInput
    some?: BreweryEventWhereInput
    none?: BreweryEventWhereInput
  }

  export type TourBreweryListRelationFilter = {
    every?: TourBreweryWhereInput
    some?: TourBreweryWhereInput
    none?: TourBreweryWhereInput
  }

  export type BreweryFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryBeerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryFoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryMusicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatingHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourBreweryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreweryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    website?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
    comments?: SortOrder
    merchandise?: SortOrder
    social_media?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    website?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
    comments?: SortOrder
    merchandise?: SortOrder
    social_media?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    website?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
    comments?: SortOrder
    merchandise?: SortOrder
    social_media?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BeerCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BeerMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BeerMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryNullableRelationFilter = {
    is?: BreweryWhereInput | null
    isNot?: BreweryWhereInput | null
  }

  export type BeerRelationFilter = {
    is?: BeerWhereInput
    isNot?: BeerWhereInput
  }

  export type BreweryBeerCountOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    beerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryBeerMaxOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    beerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryBeerMinOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    beerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryRelationFilter = {
    is?: BreweryWhereInput
    isNot?: BreweryWhereInput
  }

  export type FoodRelationFilter = {
    is?: FoodWhereInput
    isNot?: FoodWhereInput
  }

  export type BreweryFoodCountOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    foodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFoodMaxOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    foodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFoodMinOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    foodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type BreweryServiceCountOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryServiceMinOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicCountOrderByAggregateInput = {
    id?: SortOrder
    genre?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicMaxOrderByAggregateInput = {
    id?: SortOrder
    genre?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicMinOrderByAggregateInput = {
    id?: SortOrder
    genre?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicRelationFilter = {
    is?: MusicWhereInput
    isNot?: MusicWhereInput
  }

  export type BreweryMusicCountOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    musicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryMusicMaxOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    musicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryMusicMinOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    musicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type BreweryEventCountOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryEventMaxOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryEventMinOrderByAggregateInput = {
    id?: SortOrder
    breweryId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    phone?: SortOrder
    facebook?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    highlighted?: SortOrder
    capacity?: SortOrder
    booklink?: SortOrder
    pricerank?: SortOrder
    state?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFeatureAvgOrderByAggregateInput = {
    state?: SortOrder
  }

  export type BreweryFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    phone?: SortOrder
    facebook?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    highlighted?: SortOrder
    capacity?: SortOrder
    booklink?: SortOrder
    pricerank?: SortOrder
    state?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    description?: SortOrder
    phone?: SortOrder
    facebook?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    highlighted?: SortOrder
    capacity?: SortOrder
    booklink?: SortOrder
    pricerank?: SortOrder
    state?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreweryFeatureSumOrderByAggregateInput = {
    state?: SortOrder
  }

  export type OperatingHoursCountOrderByAggregateInput = {
    id?: SortOrder
    mondayOpen?: SortOrder
    mondayClose?: SortOrder
    tuesdayOpen?: SortOrder
    tuesdayClose?: SortOrder
    wednesdayOpen?: SortOrder
    wednesdayClose?: SortOrder
    thursdayOpen?: SortOrder
    thursdayClose?: SortOrder
    fridayOpen?: SortOrder
    fridayClose?: SortOrder
    saturdayOpen?: SortOrder
    saturdayClose?: SortOrder
    sundayOpen?: SortOrder
    sundayClose?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHoursMaxOrderByAggregateInput = {
    id?: SortOrder
    mondayOpen?: SortOrder
    mondayClose?: SortOrder
    tuesdayOpen?: SortOrder
    tuesdayClose?: SortOrder
    wednesdayOpen?: SortOrder
    wednesdayClose?: SortOrder
    thursdayOpen?: SortOrder
    thursdayClose?: SortOrder
    fridayOpen?: SortOrder
    fridayClose?: SortOrder
    saturdayOpen?: SortOrder
    saturdayClose?: SortOrder
    sundayOpen?: SortOrder
    sundayClose?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHoursMinOrderByAggregateInput = {
    id?: SortOrder
    mondayOpen?: SortOrder
    mondayClose?: SortOrder
    tuesdayOpen?: SortOrder
    tuesdayClose?: SortOrder
    wednesdayOpen?: SortOrder
    wednesdayClose?: SortOrder
    thursdayOpen?: SortOrder
    thursdayClose?: SortOrder
    fridayOpen?: SortOrder
    fridayClose?: SortOrder
    saturdayOpen?: SortOrder
    saturdayClose?: SortOrder
    sundayOpen?: SortOrder
    sundayClose?: SortOrder
    breweryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TutorialStepsAppCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    web_image?: SortOrder
    mobile_image?: SortOrder
    orden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutorialStepsAppAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type TutorialStepsAppMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    web_image?: SortOrder
    mobile_image?: SortOrder
    orden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutorialStepsAppMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    web_image?: SortOrder
    mobile_image?: SortOrder
    orden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TutorialStepsAppSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    radius?: SortOrder
    startDate?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourAvgOrderByAggregateInput = {
    radius?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    radius?: SortOrder
    startDate?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    radius?: SortOrder
    startDate?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourSumOrderByAggregateInput = {
    radius?: SortOrder
    breweryCount?: SortOrder
    days?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TourRelationFilter = {
    is?: TourWhereInput
    isNot?: TourWhereInput
  }

  export type TourBreweryCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    breweryId?: SortOrder
    distance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourBreweryAvgOrderByAggregateInput = {
    distance?: SortOrder
  }

  export type TourBreweryMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    breweryId?: SortOrder
    distance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourBreweryMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    breweryId?: SortOrder
    distance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourBrewerySumOrderByAggregateInput = {
    distance?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type RecipientCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipientMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AdTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdTypeAvgOrderByAggregateInput = {
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
  }

  export type AdTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdTypeSumOrderByAggregateInput = {
    limit?: SortOrder
    desktop_width?: SortOrder
    desktop_height?: SortOrder
    mobile_width?: SortOrder
    mobile_height?: SortOrder
    desktop_file_size?: SortOrder
    mobile_file_size?: SortOrder
  }

  export type AdTypeRelationFilter = {
    is?: AdTypeWhereInput
    isNot?: AdTypeWhereInput
  }

  export type AdRatesCountOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    adTypeId?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdRatesAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type AdRatesMaxOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    adTypeId?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdRatesMinOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    adTypeId?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdRatesSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CityNullableRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type AdCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adTypesId?: SortOrder
    linkUrl?: SortOrder
    buttonName?: SortOrder
    desktopFile?: SortOrder
    mobileFile?: SortOrder
    font?: SortOrder
    text1?: SortOrder
    text1Color?: SortOrder
    text2?: SortOrder
    text2Color?: SortOrder
    bgImage?: SortOrder
    payStatus?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    urlVideo?: SortOrder
    desktopVideoFile?: SortOrder
    desktopVideoPreview?: SortOrder
    mobileVideoFile?: SortOrder
    mobileVideoPreview?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    selectedDays?: SortOrder
    selectedDates?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdAvgOrderByAggregateInput = {
    totalCost?: SortOrder
    selectedDays?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
  }

  export type AdMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adTypesId?: SortOrder
    linkUrl?: SortOrder
    buttonName?: SortOrder
    desktopFile?: SortOrder
    mobileFile?: SortOrder
    font?: SortOrder
    text1?: SortOrder
    text1Color?: SortOrder
    text2?: SortOrder
    text2Color?: SortOrder
    bgImage?: SortOrder
    payStatus?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    urlVideo?: SortOrder
    desktopVideoFile?: SortOrder
    desktopVideoPreview?: SortOrder
    mobileVideoFile?: SortOrder
    mobileVideoPreview?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adTypesId?: SortOrder
    linkUrl?: SortOrder
    buttonName?: SortOrder
    desktopFile?: SortOrder
    mobileFile?: SortOrder
    font?: SortOrder
    text1?: SortOrder
    text1Color?: SortOrder
    text2?: SortOrder
    text2Color?: SortOrder
    bgImage?: SortOrder
    payStatus?: SortOrder
    status?: SortOrder
    totalCost?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    urlVideo?: SortOrder
    desktopVideoFile?: SortOrder
    desktopVideoPreview?: SortOrder
    mobileVideoFile?: SortOrder
    mobileVideoPreview?: SortOrder
    stateId?: SortOrder
    cityId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSumOrderByAggregateInput = {
    totalCost?: SortOrder
    selectedDays?: SortOrder
    clicks?: SortOrder
    views?: SortOrder
  }

  export type EnumTypeTextFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeText | EnumTypeTextFieldRefInput<$PrismaModel>
    in?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeTextFilter<$PrismaModel> | $Enums.TypeText
  }

  export type TermsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTypeTextWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeText | EnumTypeTextFieldRefInput<$PrismaModel>
    in?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeTextWithAggregatesFilter<$PrismaModel> | $Enums.TypeText
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeTextFilter<$PrismaModel>
    _max?: NestedEnumTypeTextFilter<$PrismaModel>
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type EnumMediaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaStatus | EnumMediaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaStatusFilter<$PrismaModel> | $Enums.MediaStatus
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweryId?: SortOrder
    approvedById?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweryId?: SortOrder
    approvedById?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    breweryId?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EnumMediaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaStatus | EnumMediaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaStatusWithAggregatesFilter<$PrismaModel> | $Enums.MediaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaStatusFilter<$PrismaModel>
    _max?: NestedEnumMediaStatusFilter<$PrismaModel>
  }

  export type BreweryCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput> | BreweryCreateWithoutOwnerInput[] | BreweryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutOwnerInput | BreweryCreateOrConnectWithoutOwnerInput[]
    createMany?: BreweryCreateManyOwnerInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type BreweryCreateNestedManyWithoutManagerInput = {
    create?: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput> | BreweryCreateWithoutManagerInput[] | BreweryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutManagerInput | BreweryCreateOrConnectWithoutManagerInput[]
    createMany?: BreweryCreateManyManagerInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutUserInput = {
    create?: XOR<CityCreateWithoutUserInput, CityUncheckedCreateWithoutUserInput>
    connectOrCreate?: CityCreateOrConnectWithoutUserInput
    connect?: CityWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RecipientCreateNestedManyWithoutRecipientInput = {
    create?: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput> | RecipientCreateWithoutRecipientInput[] | RecipientUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutRecipientInput | RecipientCreateOrConnectWithoutRecipientInput[]
    createMany?: RecipientCreateManyRecipientInputEnvelope
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
  }

  export type TourCreateNestedManyWithoutUserInput = {
    create?: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput> | TourCreateWithoutUserInput[] | TourUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourCreateOrConnectWithoutUserInput | TourCreateOrConnectWithoutUserInput[]
    createMany?: TourCreateManyUserInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutUserInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput> | MediaCreateWithoutApprovedByInput[] | MediaUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutApprovedByInput | MediaCreateOrConnectWithoutApprovedByInput[]
    createMany?: MediaCreateManyApprovedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type BreweryUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput> | BreweryCreateWithoutOwnerInput[] | BreweryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutOwnerInput | BreweryCreateOrConnectWithoutOwnerInput[]
    createMany?: BreweryCreateManyOwnerInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type BreweryUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput> | BreweryCreateWithoutManagerInput[] | BreweryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutManagerInput | BreweryCreateOrConnectWithoutManagerInput[]
    createMany?: BreweryCreateManyManagerInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RecipientUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput> | RecipientCreateWithoutRecipientInput[] | RecipientUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutRecipientInput | RecipientCreateOrConnectWithoutRecipientInput[]
    createMany?: RecipientCreateManyRecipientInputEnvelope
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput> | TourCreateWithoutUserInput[] | TourUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourCreateOrConnectWithoutUserInput | TourCreateOrConnectWithoutUserInput[]
    createMany?: TourCreateManyUserInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput> | MediaCreateWithoutApprovedByInput[] | MediaUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutApprovedByInput | MediaCreateOrConnectWithoutApprovedByInput[]
    createMany?: MediaCreateManyApprovedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BreweryUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput> | BreweryCreateWithoutOwnerInput[] | BreweryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutOwnerInput | BreweryCreateOrConnectWithoutOwnerInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutOwnerInput | BreweryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BreweryCreateManyOwnerInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutOwnerInput | BreweryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutOwnerInput | BreweryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type BreweryUpdateManyWithoutManagerNestedInput = {
    create?: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput> | BreweryCreateWithoutManagerInput[] | BreweryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutManagerInput | BreweryCreateOrConnectWithoutManagerInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutManagerInput | BreweryUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: BreweryCreateManyManagerInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutManagerInput | BreweryUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutManagerInput | BreweryUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type CityUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<CityCreateWithoutUserInput, CityUncheckedCreateWithoutUserInput>
    connectOrCreate?: CityCreateOrConnectWithoutUserInput
    upsert?: CityUpsertWithoutUserInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUserInput, CityUpdateWithoutUserInput>, CityUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RecipientUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput> | RecipientCreateWithoutRecipientInput[] | RecipientUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutRecipientInput | RecipientCreateOrConnectWithoutRecipientInput[]
    upsert?: RecipientUpsertWithWhereUniqueWithoutRecipientInput | RecipientUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: RecipientCreateManyRecipientInputEnvelope
    set?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    disconnect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    delete?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    update?: RecipientUpdateWithWhereUniqueWithoutRecipientInput | RecipientUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: RecipientUpdateManyWithWhereWithoutRecipientInput | RecipientUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
  }

  export type TourUpdateManyWithoutUserNestedInput = {
    create?: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput> | TourCreateWithoutUserInput[] | TourUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourCreateOrConnectWithoutUserInput | TourCreateOrConnectWithoutUserInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutUserInput | TourUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TourCreateManyUserInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutUserInput | TourUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TourUpdateManyWithWhereWithoutUserInput | TourUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type AdUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutUserInput | AdUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutUserInput | AdUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdUpdateManyWithWhereWithoutUserInput | AdUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput> | MediaCreateWithoutApprovedByInput[] | MediaUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutApprovedByInput | MediaCreateOrConnectWithoutApprovedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutApprovedByInput | MediaUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: MediaCreateManyApprovedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutApprovedByInput | MediaUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutApprovedByInput | MediaUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type BreweryUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput> | BreweryCreateWithoutOwnerInput[] | BreweryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutOwnerInput | BreweryCreateOrConnectWithoutOwnerInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutOwnerInput | BreweryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BreweryCreateManyOwnerInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutOwnerInput | BreweryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutOwnerInput | BreweryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type BreweryUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput> | BreweryCreateWithoutManagerInput[] | BreweryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutManagerInput | BreweryCreateOrConnectWithoutManagerInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutManagerInput | BreweryUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: BreweryCreateManyManagerInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutManagerInput | BreweryUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutManagerInput | BreweryUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RecipientUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput> | RecipientCreateWithoutRecipientInput[] | RecipientUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutRecipientInput | RecipientCreateOrConnectWithoutRecipientInput[]
    upsert?: RecipientUpsertWithWhereUniqueWithoutRecipientInput | RecipientUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: RecipientCreateManyRecipientInputEnvelope
    set?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    disconnect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    delete?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    update?: RecipientUpdateWithWhereUniqueWithoutRecipientInput | RecipientUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: RecipientUpdateManyWithWhereWithoutRecipientInput | RecipientUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput> | TourCreateWithoutUserInput[] | TourUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TourCreateOrConnectWithoutUserInput | TourCreateOrConnectWithoutUserInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutUserInput | TourUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TourCreateManyUserInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutUserInput | TourUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TourUpdateManyWithWhereWithoutUserInput | TourUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutUserInput | AdUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutUserInput | AdUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdUpdateManyWithWhereWithoutUserInput | AdUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput> | MediaCreateWithoutApprovedByInput[] | MediaUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutApprovedByInput | MediaCreateOrConnectWithoutApprovedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutApprovedByInput | MediaUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: MediaCreateManyApprovedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutApprovedByInput | MediaUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutApprovedByInput | MediaUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type CountyCreateNestedManyWithoutStateInput = {
    create?: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput> | CountyCreateWithoutStateInput[] | CountyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CountyCreateOrConnectWithoutStateInput | CountyCreateOrConnectWithoutStateInput[]
    createMany?: CountyCreateManyStateInputEnvelope
    connect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutStateInput = {
    create?: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput> | LocationCreateWithoutStateInput[] | LocationUncheckedCreateWithoutStateInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStateInput | LocationCreateOrConnectWithoutStateInput[]
    createMany?: LocationCreateManyStateInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AdRatesCreateNestedManyWithoutStateInput = {
    create?: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput> | AdRatesCreateWithoutStateInput[] | AdRatesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutStateInput | AdRatesCreateOrConnectWithoutStateInput[]
    createMany?: AdRatesCreateManyStateInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutStateInput = {
    create?: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput> | AdCreateWithoutStateInput[] | AdUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdCreateOrConnectWithoutStateInput | AdCreateOrConnectWithoutStateInput[]
    createMany?: AdCreateManyStateInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type CountyUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput> | CountyCreateWithoutStateInput[] | CountyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CountyCreateOrConnectWithoutStateInput | CountyCreateOrConnectWithoutStateInput[]
    createMany?: CountyCreateManyStateInputEnvelope
    connect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput> | LocationCreateWithoutStateInput[] | LocationUncheckedCreateWithoutStateInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStateInput | LocationCreateOrConnectWithoutStateInput[]
    createMany?: LocationCreateManyStateInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AdRatesUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput> | AdRatesCreateWithoutStateInput[] | AdRatesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutStateInput | AdRatesCreateOrConnectWithoutStateInput[]
    createMany?: AdRatesCreateManyStateInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput> | AdCreateWithoutStateInput[] | AdUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdCreateOrConnectWithoutStateInput | AdCreateOrConnectWithoutStateInput[]
    createMany?: AdCreateManyStateInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type CountyUpdateManyWithoutStateNestedInput = {
    create?: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput> | CountyCreateWithoutStateInput[] | CountyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CountyCreateOrConnectWithoutStateInput | CountyCreateOrConnectWithoutStateInput[]
    upsert?: CountyUpsertWithWhereUniqueWithoutStateInput | CountyUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CountyCreateManyStateInputEnvelope
    set?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    disconnect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    delete?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    connect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    update?: CountyUpdateWithWhereUniqueWithoutStateInput | CountyUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CountyUpdateManyWithWhereWithoutStateInput | CountyUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CountyScalarWhereInput | CountyScalarWhereInput[]
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutStateInput | CityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutStateInput | CityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CityUpdateManyWithWhereWithoutStateInput | CityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutStateNestedInput = {
    create?: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput> | LocationCreateWithoutStateInput[] | LocationUncheckedCreateWithoutStateInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStateInput | LocationCreateOrConnectWithoutStateInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStateInput | LocationUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: LocationCreateManyStateInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStateInput | LocationUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStateInput | LocationUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AdRatesUpdateManyWithoutStateNestedInput = {
    create?: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput> | AdRatesCreateWithoutStateInput[] | AdRatesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutStateInput | AdRatesCreateOrConnectWithoutStateInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutStateInput | AdRatesUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: AdRatesCreateManyStateInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutStateInput | AdRatesUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutStateInput | AdRatesUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUpdateManyWithoutStateNestedInput = {
    create?: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput> | AdCreateWithoutStateInput[] | AdUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdCreateOrConnectWithoutStateInput | AdCreateOrConnectWithoutStateInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutStateInput | AdUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: AdCreateManyStateInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutStateInput | AdUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: AdUpdateManyWithWhereWithoutStateInput | AdUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type CountyUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput> | CountyCreateWithoutStateInput[] | CountyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CountyCreateOrConnectWithoutStateInput | CountyCreateOrConnectWithoutStateInput[]
    upsert?: CountyUpsertWithWhereUniqueWithoutStateInput | CountyUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CountyCreateManyStateInputEnvelope
    set?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    disconnect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    delete?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    connect?: CountyWhereUniqueInput | CountyWhereUniqueInput[]
    update?: CountyUpdateWithWhereUniqueWithoutStateInput | CountyUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CountyUpdateManyWithWhereWithoutStateInput | CountyUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CountyScalarWhereInput | CountyScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput> | CityCreateWithoutStateInput[] | CityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: CityCreateOrConnectWithoutStateInput | CityCreateOrConnectWithoutStateInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutStateInput | CityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: CityCreateManyStateInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutStateInput | CityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: CityUpdateManyWithWhereWithoutStateInput | CityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput> | LocationCreateWithoutStateInput[] | LocationUncheckedCreateWithoutStateInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStateInput | LocationCreateOrConnectWithoutStateInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStateInput | LocationUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: LocationCreateManyStateInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStateInput | LocationUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStateInput | LocationUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AdRatesUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput> | AdRatesCreateWithoutStateInput[] | AdRatesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutStateInput | AdRatesCreateOrConnectWithoutStateInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutStateInput | AdRatesUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: AdRatesCreateManyStateInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutStateInput | AdRatesUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutStateInput | AdRatesUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput> | AdCreateWithoutStateInput[] | AdUncheckedCreateWithoutStateInput[]
    connectOrCreate?: AdCreateOrConnectWithoutStateInput | AdCreateOrConnectWithoutStateInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutStateInput | AdUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: AdCreateManyStateInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutStateInput | AdUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: AdUpdateManyWithWhereWithoutStateInput | AdUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type StateCreateNestedOneWithoutCountiesInput = {
    create?: XOR<StateCreateWithoutCountiesInput, StateUncheckedCreateWithoutCountiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCountiesInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutCountyInput = {
    create?: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput> | CityCreateWithoutCountyInput[] | CityUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountyInput | CityCreateOrConnectWithoutCountyInput[]
    createMany?: CityCreateManyCountyInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutCountyInput = {
    create?: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput> | LocationCreateWithoutCountyInput[] | LocationUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCountyInput | LocationCreateOrConnectWithoutCountyInput[]
    createMany?: LocationCreateManyCountyInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput> | CityCreateWithoutCountyInput[] | CityUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountyInput | CityCreateOrConnectWithoutCountyInput[]
    createMany?: CityCreateManyCountyInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput> | LocationCreateWithoutCountyInput[] | LocationUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCountyInput | LocationCreateOrConnectWithoutCountyInput[]
    createMany?: LocationCreateManyCountyInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type StateUpdateOneRequiredWithoutCountiesNestedInput = {
    create?: XOR<StateCreateWithoutCountiesInput, StateUncheckedCreateWithoutCountiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCountiesInput
    upsert?: StateUpsertWithoutCountiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutCountiesInput, StateUpdateWithoutCountiesInput>, StateUncheckedUpdateWithoutCountiesInput>
  }

  export type CityUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput> | CityCreateWithoutCountyInput[] | CityUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountyInput | CityCreateOrConnectWithoutCountyInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountyInput | CityUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CityCreateManyCountyInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountyInput | CityUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountyInput | CityUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutCountyNestedInput = {
    create?: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput> | LocationCreateWithoutCountyInput[] | LocationUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCountyInput | LocationCreateOrConnectWithoutCountyInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCountyInput | LocationUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: LocationCreateManyCountyInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCountyInput | LocationUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCountyInput | LocationUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput> | CityCreateWithoutCountyInput[] | CityUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountyInput | CityCreateOrConnectWithoutCountyInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountyInput | CityUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CityCreateManyCountyInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountyInput | CityUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountyInput | CityUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput> | LocationCreateWithoutCountyInput[] | LocationUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCountyInput | LocationCreateOrConnectWithoutCountyInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCountyInput | LocationUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: LocationCreateManyCountyInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCountyInput | LocationUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCountyInput | LocationUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountyCreateWithoutCitiesInput, CountyUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCitiesInput
    connect?: CountyWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutCityInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type TourCreateNestedManyWithoutCityInput = {
    create?: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput> | TourCreateWithoutCityInput[] | TourUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TourCreateOrConnectWithoutCityInput | TourCreateOrConnectWithoutCityInput[]
    createMany?: TourCreateManyCityInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type AdRatesCreateNestedManyWithoutCityInput = {
    create?: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput> | AdRatesCreateWithoutCityInput[] | AdRatesUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutCityInput | AdRatesCreateOrConnectWithoutCityInput[]
    createMany?: AdRatesCreateManyCityInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutCityInput = {
    create?: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput> | AdCreateWithoutCityInput[] | AdUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCityInput | AdCreateOrConnectWithoutCityInput[]
    createMany?: AdCreateManyCityInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput> | TourCreateWithoutCityInput[] | TourUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TourCreateOrConnectWithoutCityInput | TourCreateOrConnectWithoutCityInput[]
    createMany?: TourCreateManyCityInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type AdRatesUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput> | AdRatesCreateWithoutCityInput[] | AdRatesUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutCityInput | AdRatesCreateOrConnectWithoutCityInput[]
    createMany?: AdRatesCreateManyCityInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput> | AdCreateWithoutCityInput[] | AdUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCityInput | AdCreateOrConnectWithoutCityInput[]
    createMany?: AdCreateManyCityInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type StateUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutCitiesInput, StateUpdateWithoutCitiesInput>, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type CountyUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountyCreateWithoutCitiesInput, CountyUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCitiesInput
    upsert?: CountyUpsertWithoutCitiesInput
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutCitiesInput, CountyUpdateWithoutCitiesInput>, CountyUncheckedUpdateWithoutCitiesInput>
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutCityNestedInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCityInput | LocationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCityInput | LocationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCityInput | LocationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type TourUpdateManyWithoutCityNestedInput = {
    create?: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput> | TourCreateWithoutCityInput[] | TourUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TourCreateOrConnectWithoutCityInput | TourCreateOrConnectWithoutCityInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutCityInput | TourUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: TourCreateManyCityInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutCityInput | TourUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: TourUpdateManyWithWhereWithoutCityInput | TourUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type AdRatesUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput> | AdRatesCreateWithoutCityInput[] | AdRatesUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutCityInput | AdRatesCreateOrConnectWithoutCityInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutCityInput | AdRatesUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdRatesCreateManyCityInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutCityInput | AdRatesUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutCityInput | AdRatesUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput> | AdCreateWithoutCityInput[] | AdUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCityInput | AdCreateOrConnectWithoutCityInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCityInput | AdUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdCreateManyCityInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCityInput | AdUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCityInput | AdUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCityInput | LocationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCityInput | LocationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCityInput | LocationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput> | TourCreateWithoutCityInput[] | TourUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TourCreateOrConnectWithoutCityInput | TourCreateOrConnectWithoutCityInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutCityInput | TourUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: TourCreateManyCityInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutCityInput | TourUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: TourUpdateManyWithWhereWithoutCityInput | TourUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type AdRatesUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput> | AdRatesCreateWithoutCityInput[] | AdRatesUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutCityInput | AdRatesCreateOrConnectWithoutCityInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutCityInput | AdRatesUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdRatesCreateManyCityInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutCityInput | AdRatesUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutCityInput | AdRatesUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput> | AdCreateWithoutCityInput[] | AdUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCityInput | AdCreateOrConnectWithoutCityInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCityInput | AdUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdCreateManyCityInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCityInput | AdUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCityInput | AdUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutLocationInput = {
    create?: XOR<CityCreateWithoutLocationInput, CityUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CityCreateOrConnectWithoutLocationInput
    connect?: CityWhereUniqueInput
  }

  export type BreweryCreateNestedManyWithoutLocationInput = {
    create?: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput> | BreweryCreateWithoutLocationInput[] | BreweryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutLocationInput | BreweryCreateOrConnectWithoutLocationInput[]
    createMany?: BreweryCreateManyLocationInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type StateCreateNestedOneWithoutLocationInput = {
    create?: XOR<StateCreateWithoutLocationInput, StateUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StateCreateOrConnectWithoutLocationInput
    connect?: StateWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutLocationInput = {
    create?: XOR<CountyCreateWithoutLocationInput, CountyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CountyCreateOrConnectWithoutLocationInput
    connect?: CountyWhereUniqueInput
  }

  export type BreweryUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput> | BreweryCreateWithoutLocationInput[] | BreweryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutLocationInput | BreweryCreateOrConnectWithoutLocationInput[]
    createMany?: BreweryCreateManyLocationInputEnvelope
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<CityCreateWithoutLocationInput, CityUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CityCreateOrConnectWithoutLocationInput
    upsert?: CityUpsertWithoutLocationInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutLocationInput, CityUpdateWithoutLocationInput>, CityUncheckedUpdateWithoutLocationInput>
  }

  export type BreweryUpdateManyWithoutLocationNestedInput = {
    create?: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput> | BreweryCreateWithoutLocationInput[] | BreweryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutLocationInput | BreweryCreateOrConnectWithoutLocationInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutLocationInput | BreweryUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: BreweryCreateManyLocationInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutLocationInput | BreweryUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutLocationInput | BreweryUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type StateUpdateOneWithoutLocationNestedInput = {
    create?: XOR<StateCreateWithoutLocationInput, StateUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StateCreateOrConnectWithoutLocationInput
    upsert?: StateUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: StateWhereInput | boolean
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutLocationInput, StateUpdateWithoutLocationInput>, StateUncheckedUpdateWithoutLocationInput>
  }

  export type CountyUpdateOneWithoutLocationNestedInput = {
    create?: XOR<CountyCreateWithoutLocationInput, CountyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CountyCreateOrConnectWithoutLocationInput
    upsert?: CountyUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutLocationInput, CountyUpdateWithoutLocationInput>, CountyUncheckedUpdateWithoutLocationInput>
  }

  export type BreweryUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput> | BreweryCreateWithoutLocationInput[] | BreweryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BreweryCreateOrConnectWithoutLocationInput | BreweryCreateOrConnectWithoutLocationInput[]
    upsert?: BreweryUpsertWithWhereUniqueWithoutLocationInput | BreweryUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: BreweryCreateManyLocationInputEnvelope
    set?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    disconnect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    delete?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    connect?: BreweryWhereUniqueInput | BreweryWhereUniqueInput[]
    update?: BreweryUpdateWithWhereUniqueWithoutLocationInput | BreweryUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: BreweryUpdateManyWithWhereWithoutLocationInput | BreweryUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutBreweryInput = {
    create?: XOR<LocationCreateWithoutBreweryInput, LocationUncheckedCreateWithoutBreweryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBreweryInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedBreweriesInput = {
    create?: XOR<UserCreateWithoutOwnedBreweriesInput, UserUncheckedCreateWithoutOwnedBreweriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBreweriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedBreweriesInput = {
    create?: XOR<UserCreateWithoutManagedBreweriesInput, UserUncheckedCreateWithoutManagedBreweriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedBreweriesInput
    connect?: UserWhereUniqueInput
  }

  export type BreweryFeatureCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput> | BreweryFeatureCreateWithoutBreweryInput[] | BreweryFeatureUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFeatureCreateOrConnectWithoutBreweryInput | BreweryFeatureCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryFeatureCreateManyBreweryInputEnvelope
    connect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
  }

  export type BreweryBeerCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput> | BreweryBeerCreateWithoutBreweryInput[] | BreweryBeerUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBreweryInput | BreweryBeerCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryBeerCreateManyBreweryInputEnvelope
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
  }

  export type BreweryFoodCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput> | BreweryFoodCreateWithoutBreweryInput[] | BreweryFoodUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutBreweryInput | BreweryFoodCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryFoodCreateManyBreweryInputEnvelope
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
  }

  export type BreweryServiceCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput> | BreweryServiceCreateWithoutBreweryInput[] | BreweryServiceUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutBreweryInput | BreweryServiceCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryServiceCreateManyBreweryInputEnvelope
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
  }

  export type BreweryMusicCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput> | BreweryMusicCreateWithoutBreweryInput[] | BreweryMusicUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutBreweryInput | BreweryMusicCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryMusicCreateManyBreweryInputEnvelope
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
  }

  export type OperatingHoursCreateNestedManyWithoutBreweryInput = {
    create?: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput> | OperatingHoursCreateWithoutBreweryInput[] | OperatingHoursUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: OperatingHoursCreateOrConnectWithoutBreweryInput | OperatingHoursCreateOrConnectWithoutBreweryInput[]
    createMany?: OperatingHoursCreateManyBreweryInputEnvelope
    connect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
  }

  export type BreweryEventCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput> | BreweryEventCreateWithoutBreweryInput[] | BreweryEventUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutBreweryInput | BreweryEventCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryEventCreateManyBreweryInputEnvelope
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
  }

  export type TourBreweryCreateNestedManyWithoutBreweryInput = {
    create?: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput> | TourBreweryCreateWithoutBreweryInput[] | TourBreweryUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutBreweryInput | TourBreweryCreateOrConnectWithoutBreweryInput[]
    createMany?: TourBreweryCreateManyBreweryInputEnvelope
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutBreweryInput = {
    create?: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput> | MediaCreateWithoutBreweryInput[] | MediaUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBreweryInput | MediaCreateOrConnectWithoutBreweryInput[]
    createMany?: MediaCreateManyBreweryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput> | BreweryFeatureCreateWithoutBreweryInput[] | BreweryFeatureUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFeatureCreateOrConnectWithoutBreweryInput | BreweryFeatureCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryFeatureCreateManyBreweryInputEnvelope
    connect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
  }

  export type BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput> | BreweryBeerCreateWithoutBreweryInput[] | BreweryBeerUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBreweryInput | BreweryBeerCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryBeerCreateManyBreweryInputEnvelope
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
  }

  export type BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput> | BreweryFoodCreateWithoutBreweryInput[] | BreweryFoodUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutBreweryInput | BreweryFoodCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryFoodCreateManyBreweryInputEnvelope
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
  }

  export type BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput> | BreweryServiceCreateWithoutBreweryInput[] | BreweryServiceUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutBreweryInput | BreweryServiceCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryServiceCreateManyBreweryInputEnvelope
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
  }

  export type BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput> | BreweryMusicCreateWithoutBreweryInput[] | BreweryMusicUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutBreweryInput | BreweryMusicCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryMusicCreateManyBreweryInputEnvelope
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
  }

  export type OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput> | OperatingHoursCreateWithoutBreweryInput[] | OperatingHoursUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: OperatingHoursCreateOrConnectWithoutBreweryInput | OperatingHoursCreateOrConnectWithoutBreweryInput[]
    createMany?: OperatingHoursCreateManyBreweryInputEnvelope
    connect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
  }

  export type BreweryEventUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput> | BreweryEventCreateWithoutBreweryInput[] | BreweryEventUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutBreweryInput | BreweryEventCreateOrConnectWithoutBreweryInput[]
    createMany?: BreweryEventCreateManyBreweryInputEnvelope
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
  }

  export type TourBreweryUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput> | TourBreweryCreateWithoutBreweryInput[] | TourBreweryUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutBreweryInput | TourBreweryCreateOrConnectWithoutBreweryInput[]
    createMany?: TourBreweryCreateManyBreweryInputEnvelope
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutBreweryInput = {
    create?: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput> | MediaCreateWithoutBreweryInput[] | MediaUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBreweryInput | MediaCreateOrConnectWithoutBreweryInput[]
    createMany?: MediaCreateManyBreweryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type LocationUpdateOneRequiredWithoutBreweryNestedInput = {
    create?: XOR<LocationCreateWithoutBreweryInput, LocationUncheckedCreateWithoutBreweryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBreweryInput
    upsert?: LocationUpsertWithoutBreweryInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutBreweryInput, LocationUpdateWithoutBreweryInput>, LocationUncheckedUpdateWithoutBreweryInput>
  }

  export type UserUpdateOneWithoutOwnedBreweriesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedBreweriesInput, UserUncheckedCreateWithoutOwnedBreweriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBreweriesInput
    upsert?: UserUpsertWithoutOwnedBreweriesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedBreweriesInput, UserUpdateWithoutOwnedBreweriesInput>, UserUncheckedUpdateWithoutOwnedBreweriesInput>
  }

  export type UserUpdateOneWithoutManagedBreweriesNestedInput = {
    create?: XOR<UserCreateWithoutManagedBreweriesInput, UserUncheckedCreateWithoutManagedBreweriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedBreweriesInput
    upsert?: UserUpsertWithoutManagedBreweriesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedBreweriesInput, UserUpdateWithoutManagedBreweriesInput>, UserUncheckedUpdateWithoutManagedBreweriesInput>
  }

  export type BreweryFeatureUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput> | BreweryFeatureCreateWithoutBreweryInput[] | BreweryFeatureUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFeatureCreateOrConnectWithoutBreweryInput | BreweryFeatureCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryFeatureUpsertWithWhereUniqueWithoutBreweryInput | BreweryFeatureUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryFeatureCreateManyBreweryInputEnvelope
    set?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    disconnect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    delete?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    connect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    update?: BreweryFeatureUpdateWithWhereUniqueWithoutBreweryInput | BreweryFeatureUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryFeatureUpdateManyWithWhereWithoutBreweryInput | BreweryFeatureUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryFeatureScalarWhereInput | BreweryFeatureScalarWhereInput[]
  }

  export type BreweryBeerUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput> | BreweryBeerCreateWithoutBreweryInput[] | BreweryBeerUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBreweryInput | BreweryBeerCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryBeerUpsertWithWhereUniqueWithoutBreweryInput | BreweryBeerUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryBeerCreateManyBreweryInputEnvelope
    set?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    disconnect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    delete?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    update?: BreweryBeerUpdateWithWhereUniqueWithoutBreweryInput | BreweryBeerUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryBeerUpdateManyWithWhereWithoutBreweryInput | BreweryBeerUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
  }

  export type BreweryFoodUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput> | BreweryFoodCreateWithoutBreweryInput[] | BreweryFoodUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutBreweryInput | BreweryFoodCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryFoodUpsertWithWhereUniqueWithoutBreweryInput | BreweryFoodUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryFoodCreateManyBreweryInputEnvelope
    set?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    disconnect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    delete?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    update?: BreweryFoodUpdateWithWhereUniqueWithoutBreweryInput | BreweryFoodUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryFoodUpdateManyWithWhereWithoutBreweryInput | BreweryFoodUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
  }

  export type BreweryServiceUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput> | BreweryServiceCreateWithoutBreweryInput[] | BreweryServiceUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutBreweryInput | BreweryServiceCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryServiceUpsertWithWhereUniqueWithoutBreweryInput | BreweryServiceUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryServiceCreateManyBreweryInputEnvelope
    set?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    disconnect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    delete?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    update?: BreweryServiceUpdateWithWhereUniqueWithoutBreweryInput | BreweryServiceUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryServiceUpdateManyWithWhereWithoutBreweryInput | BreweryServiceUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
  }

  export type BreweryMusicUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput> | BreweryMusicCreateWithoutBreweryInput[] | BreweryMusicUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutBreweryInput | BreweryMusicCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryMusicUpsertWithWhereUniqueWithoutBreweryInput | BreweryMusicUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryMusicCreateManyBreweryInputEnvelope
    set?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    disconnect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    delete?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    update?: BreweryMusicUpdateWithWhereUniqueWithoutBreweryInput | BreweryMusicUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryMusicUpdateManyWithWhereWithoutBreweryInput | BreweryMusicUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
  }

  export type OperatingHoursUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput> | OperatingHoursCreateWithoutBreweryInput[] | OperatingHoursUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: OperatingHoursCreateOrConnectWithoutBreweryInput | OperatingHoursCreateOrConnectWithoutBreweryInput[]
    upsert?: OperatingHoursUpsertWithWhereUniqueWithoutBreweryInput | OperatingHoursUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: OperatingHoursCreateManyBreweryInputEnvelope
    set?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    disconnect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    delete?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    connect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    update?: OperatingHoursUpdateWithWhereUniqueWithoutBreweryInput | OperatingHoursUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: OperatingHoursUpdateManyWithWhereWithoutBreweryInput | OperatingHoursUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: OperatingHoursScalarWhereInput | OperatingHoursScalarWhereInput[]
  }

  export type BreweryEventUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput> | BreweryEventCreateWithoutBreweryInput[] | BreweryEventUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutBreweryInput | BreweryEventCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryEventUpsertWithWhereUniqueWithoutBreweryInput | BreweryEventUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryEventCreateManyBreweryInputEnvelope
    set?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    disconnect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    delete?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    update?: BreweryEventUpdateWithWhereUniqueWithoutBreweryInput | BreweryEventUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryEventUpdateManyWithWhereWithoutBreweryInput | BreweryEventUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
  }

  export type TourBreweryUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput> | TourBreweryCreateWithoutBreweryInput[] | TourBreweryUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutBreweryInput | TourBreweryCreateOrConnectWithoutBreweryInput[]
    upsert?: TourBreweryUpsertWithWhereUniqueWithoutBreweryInput | TourBreweryUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: TourBreweryCreateManyBreweryInputEnvelope
    set?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    disconnect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    delete?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    update?: TourBreweryUpdateWithWhereUniqueWithoutBreweryInput | TourBreweryUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: TourBreweryUpdateManyWithWhereWithoutBreweryInput | TourBreweryUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput> | MediaCreateWithoutBreweryInput[] | MediaUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBreweryInput | MediaCreateOrConnectWithoutBreweryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutBreweryInput | MediaUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: MediaCreateManyBreweryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutBreweryInput | MediaUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutBreweryInput | MediaUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput> | BreweryFeatureCreateWithoutBreweryInput[] | BreweryFeatureUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFeatureCreateOrConnectWithoutBreweryInput | BreweryFeatureCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryFeatureUpsertWithWhereUniqueWithoutBreweryInput | BreweryFeatureUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryFeatureCreateManyBreweryInputEnvelope
    set?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    disconnect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    delete?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    connect?: BreweryFeatureWhereUniqueInput | BreweryFeatureWhereUniqueInput[]
    update?: BreweryFeatureUpdateWithWhereUniqueWithoutBreweryInput | BreweryFeatureUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryFeatureUpdateManyWithWhereWithoutBreweryInput | BreweryFeatureUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryFeatureScalarWhereInput | BreweryFeatureScalarWhereInput[]
  }

  export type BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput> | BreweryBeerCreateWithoutBreweryInput[] | BreweryBeerUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBreweryInput | BreweryBeerCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryBeerUpsertWithWhereUniqueWithoutBreweryInput | BreweryBeerUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryBeerCreateManyBreweryInputEnvelope
    set?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    disconnect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    delete?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    update?: BreweryBeerUpdateWithWhereUniqueWithoutBreweryInput | BreweryBeerUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryBeerUpdateManyWithWhereWithoutBreweryInput | BreweryBeerUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
  }

  export type BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput> | BreweryFoodCreateWithoutBreweryInput[] | BreweryFoodUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutBreweryInput | BreweryFoodCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryFoodUpsertWithWhereUniqueWithoutBreweryInput | BreweryFoodUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryFoodCreateManyBreweryInputEnvelope
    set?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    disconnect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    delete?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    update?: BreweryFoodUpdateWithWhereUniqueWithoutBreweryInput | BreweryFoodUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryFoodUpdateManyWithWhereWithoutBreweryInput | BreweryFoodUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
  }

  export type BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput> | BreweryServiceCreateWithoutBreweryInput[] | BreweryServiceUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutBreweryInput | BreweryServiceCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryServiceUpsertWithWhereUniqueWithoutBreweryInput | BreweryServiceUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryServiceCreateManyBreweryInputEnvelope
    set?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    disconnect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    delete?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    update?: BreweryServiceUpdateWithWhereUniqueWithoutBreweryInput | BreweryServiceUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryServiceUpdateManyWithWhereWithoutBreweryInput | BreweryServiceUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
  }

  export type BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput> | BreweryMusicCreateWithoutBreweryInput[] | BreweryMusicUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutBreweryInput | BreweryMusicCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryMusicUpsertWithWhereUniqueWithoutBreweryInput | BreweryMusicUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryMusicCreateManyBreweryInputEnvelope
    set?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    disconnect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    delete?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    update?: BreweryMusicUpdateWithWhereUniqueWithoutBreweryInput | BreweryMusicUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryMusicUpdateManyWithWhereWithoutBreweryInput | BreweryMusicUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
  }

  export type OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput> | OperatingHoursCreateWithoutBreweryInput[] | OperatingHoursUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: OperatingHoursCreateOrConnectWithoutBreweryInput | OperatingHoursCreateOrConnectWithoutBreweryInput[]
    upsert?: OperatingHoursUpsertWithWhereUniqueWithoutBreweryInput | OperatingHoursUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: OperatingHoursCreateManyBreweryInputEnvelope
    set?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    disconnect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    delete?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    connect?: OperatingHoursWhereUniqueInput | OperatingHoursWhereUniqueInput[]
    update?: OperatingHoursUpdateWithWhereUniqueWithoutBreweryInput | OperatingHoursUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: OperatingHoursUpdateManyWithWhereWithoutBreweryInput | OperatingHoursUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: OperatingHoursScalarWhereInput | OperatingHoursScalarWhereInput[]
  }

  export type BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput> | BreweryEventCreateWithoutBreweryInput[] | BreweryEventUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutBreweryInput | BreweryEventCreateOrConnectWithoutBreweryInput[]
    upsert?: BreweryEventUpsertWithWhereUniqueWithoutBreweryInput | BreweryEventUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: BreweryEventCreateManyBreweryInputEnvelope
    set?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    disconnect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    delete?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    update?: BreweryEventUpdateWithWhereUniqueWithoutBreweryInput | BreweryEventUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: BreweryEventUpdateManyWithWhereWithoutBreweryInput | BreweryEventUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
  }

  export type TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput> | TourBreweryCreateWithoutBreweryInput[] | TourBreweryUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutBreweryInput | TourBreweryCreateOrConnectWithoutBreweryInput[]
    upsert?: TourBreweryUpsertWithWhereUniqueWithoutBreweryInput | TourBreweryUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: TourBreweryCreateManyBreweryInputEnvelope
    set?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    disconnect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    delete?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    update?: TourBreweryUpdateWithWhereUniqueWithoutBreweryInput | TourBreweryUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: TourBreweryUpdateManyWithWhereWithoutBreweryInput | TourBreweryUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutBreweryNestedInput = {
    create?: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput> | MediaCreateWithoutBreweryInput[] | MediaUncheckedCreateWithoutBreweryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutBreweryInput | MediaCreateOrConnectWithoutBreweryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutBreweryInput | MediaUpsertWithWhereUniqueWithoutBreweryInput[]
    createMany?: MediaCreateManyBreweryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutBreweryInput | MediaUpdateWithWhereUniqueWithoutBreweryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutBreweryInput | MediaUpdateManyWithWhereWithoutBreweryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type BreweryBeerCreateNestedManyWithoutBeerInput = {
    create?: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput> | BreweryBeerCreateWithoutBeerInput[] | BreweryBeerUncheckedCreateWithoutBeerInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBeerInput | BreweryBeerCreateOrConnectWithoutBeerInput[]
    createMany?: BreweryBeerCreateManyBeerInputEnvelope
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
  }

  export type BreweryBeerUncheckedCreateNestedManyWithoutBeerInput = {
    create?: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput> | BreweryBeerCreateWithoutBeerInput[] | BreweryBeerUncheckedCreateWithoutBeerInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBeerInput | BreweryBeerCreateOrConnectWithoutBeerInput[]
    createMany?: BreweryBeerCreateManyBeerInputEnvelope
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
  }

  export type BreweryBeerUpdateManyWithoutBeerNestedInput = {
    create?: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput> | BreweryBeerCreateWithoutBeerInput[] | BreweryBeerUncheckedCreateWithoutBeerInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBeerInput | BreweryBeerCreateOrConnectWithoutBeerInput[]
    upsert?: BreweryBeerUpsertWithWhereUniqueWithoutBeerInput | BreweryBeerUpsertWithWhereUniqueWithoutBeerInput[]
    createMany?: BreweryBeerCreateManyBeerInputEnvelope
    set?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    disconnect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    delete?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    update?: BreweryBeerUpdateWithWhereUniqueWithoutBeerInput | BreweryBeerUpdateWithWhereUniqueWithoutBeerInput[]
    updateMany?: BreweryBeerUpdateManyWithWhereWithoutBeerInput | BreweryBeerUpdateManyWithWhereWithoutBeerInput[]
    deleteMany?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
  }

  export type BreweryBeerUncheckedUpdateManyWithoutBeerNestedInput = {
    create?: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput> | BreweryBeerCreateWithoutBeerInput[] | BreweryBeerUncheckedCreateWithoutBeerInput[]
    connectOrCreate?: BreweryBeerCreateOrConnectWithoutBeerInput | BreweryBeerCreateOrConnectWithoutBeerInput[]
    upsert?: BreweryBeerUpsertWithWhereUniqueWithoutBeerInput | BreweryBeerUpsertWithWhereUniqueWithoutBeerInput[]
    createMany?: BreweryBeerCreateManyBeerInputEnvelope
    set?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    disconnect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    delete?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    connect?: BreweryBeerWhereUniqueInput | BreweryBeerWhereUniqueInput[]
    update?: BreweryBeerUpdateWithWhereUniqueWithoutBeerInput | BreweryBeerUpdateWithWhereUniqueWithoutBeerInput[]
    updateMany?: BreweryBeerUpdateManyWithWhereWithoutBeerInput | BreweryBeerUpdateManyWithWhereWithoutBeerInput[]
    deleteMany?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
  }

  export type BreweryCreateNestedOneWithoutBeersInput = {
    create?: XOR<BreweryCreateWithoutBeersInput, BreweryUncheckedCreateWithoutBeersInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutBeersInput
    connect?: BreweryWhereUniqueInput
  }

  export type BeerCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<BeerCreateWithoutBreweriesInput, BeerUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: BeerCreateOrConnectWithoutBreweriesInput
    connect?: BeerWhereUniqueInput
  }

  export type BreweryUpdateOneWithoutBeersNestedInput = {
    create?: XOR<BreweryCreateWithoutBeersInput, BreweryUncheckedCreateWithoutBeersInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutBeersInput
    upsert?: BreweryUpsertWithoutBeersInput
    disconnect?: boolean
    delete?: BreweryWhereInput | boolean
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutBeersInput, BreweryUpdateWithoutBeersInput>, BreweryUncheckedUpdateWithoutBeersInput>
  }

  export type BeerUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<BeerCreateWithoutBreweriesInput, BeerUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: BeerCreateOrConnectWithoutBreweriesInput
    upsert?: BeerUpsertWithoutBreweriesInput
    connect?: BeerWhereUniqueInput
    update?: XOR<XOR<BeerUpdateToOneWithWhereWithoutBreweriesInput, BeerUpdateWithoutBreweriesInput>, BeerUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryFoodCreateNestedManyWithoutFoodInput = {
    create?: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput> | BreweryFoodCreateWithoutFoodInput[] | BreweryFoodUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutFoodInput | BreweryFoodCreateOrConnectWithoutFoodInput[]
    createMany?: BreweryFoodCreateManyFoodInputEnvelope
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
  }

  export type BreweryFoodUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput> | BreweryFoodCreateWithoutFoodInput[] | BreweryFoodUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutFoodInput | BreweryFoodCreateOrConnectWithoutFoodInput[]
    createMany?: BreweryFoodCreateManyFoodInputEnvelope
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
  }

  export type BreweryFoodUpdateManyWithoutFoodNestedInput = {
    create?: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput> | BreweryFoodCreateWithoutFoodInput[] | BreweryFoodUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutFoodInput | BreweryFoodCreateOrConnectWithoutFoodInput[]
    upsert?: BreweryFoodUpsertWithWhereUniqueWithoutFoodInput | BreweryFoodUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: BreweryFoodCreateManyFoodInputEnvelope
    set?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    disconnect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    delete?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    update?: BreweryFoodUpdateWithWhereUniqueWithoutFoodInput | BreweryFoodUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: BreweryFoodUpdateManyWithWhereWithoutFoodInput | BreweryFoodUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
  }

  export type BreweryFoodUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput> | BreweryFoodCreateWithoutFoodInput[] | BreweryFoodUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: BreweryFoodCreateOrConnectWithoutFoodInput | BreweryFoodCreateOrConnectWithoutFoodInput[]
    upsert?: BreweryFoodUpsertWithWhereUniqueWithoutFoodInput | BreweryFoodUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: BreweryFoodCreateManyFoodInputEnvelope
    set?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    disconnect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    delete?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    connect?: BreweryFoodWhereUniqueInput | BreweryFoodWhereUniqueInput[]
    update?: BreweryFoodUpdateWithWhereUniqueWithoutFoodInput | BreweryFoodUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: BreweryFoodUpdateManyWithWhereWithoutFoodInput | BreweryFoodUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
  }

  export type BreweryCreateNestedOneWithoutFoodsInput = {
    create?: XOR<BreweryCreateWithoutFoodsInput, BreweryUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutFoodsInput
    connect?: BreweryWhereUniqueInput
  }

  export type FoodCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<FoodCreateWithoutBreweriesInput, FoodUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: FoodCreateOrConnectWithoutBreweriesInput
    connect?: FoodWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutFoodsNestedInput = {
    create?: XOR<BreweryCreateWithoutFoodsInput, BreweryUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutFoodsInput
    upsert?: BreweryUpsertWithoutFoodsInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutFoodsInput, BreweryUpdateWithoutFoodsInput>, BreweryUncheckedUpdateWithoutFoodsInput>
  }

  export type FoodUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<FoodCreateWithoutBreweriesInput, FoodUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: FoodCreateOrConnectWithoutBreweriesInput
    upsert?: FoodUpsertWithoutBreweriesInput
    connect?: FoodWhereUniqueInput
    update?: XOR<XOR<FoodUpdateToOneWithWhereWithoutBreweriesInput, FoodUpdateWithoutBreweriesInput>, FoodUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput> | BreweryServiceCreateWithoutServiceInput[] | BreweryServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutServiceInput | BreweryServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BreweryServiceCreateManyServiceInputEnvelope
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
  }

  export type BreweryServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput> | BreweryServiceCreateWithoutServiceInput[] | BreweryServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutServiceInput | BreweryServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BreweryServiceCreateManyServiceInputEnvelope
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
  }

  export type BreweryServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput> | BreweryServiceCreateWithoutServiceInput[] | BreweryServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutServiceInput | BreweryServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BreweryServiceUpsertWithWhereUniqueWithoutServiceInput | BreweryServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BreweryServiceCreateManyServiceInputEnvelope
    set?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    disconnect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    delete?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    update?: BreweryServiceUpdateWithWhereUniqueWithoutServiceInput | BreweryServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BreweryServiceUpdateManyWithWhereWithoutServiceInput | BreweryServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
  }

  export type BreweryServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput> | BreweryServiceCreateWithoutServiceInput[] | BreweryServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BreweryServiceCreateOrConnectWithoutServiceInput | BreweryServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BreweryServiceUpsertWithWhereUniqueWithoutServiceInput | BreweryServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BreweryServiceCreateManyServiceInputEnvelope
    set?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    disconnect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    delete?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    connect?: BreweryServiceWhereUniqueInput | BreweryServiceWhereUniqueInput[]
    update?: BreweryServiceUpdateWithWhereUniqueWithoutServiceInput | BreweryServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BreweryServiceUpdateManyWithWhereWithoutServiceInput | BreweryServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
  }

  export type BreweryCreateNestedOneWithoutServicesInput = {
    create?: XOR<BreweryCreateWithoutServicesInput, BreweryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutServicesInput
    connect?: BreweryWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<ServiceCreateWithoutBreweriesInput, ServiceUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBreweriesInput
    connect?: ServiceWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BreweryCreateWithoutServicesInput, BreweryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutServicesInput
    upsert?: BreweryUpsertWithoutServicesInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutServicesInput, BreweryUpdateWithoutServicesInput>, BreweryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<ServiceCreateWithoutBreweriesInput, ServiceUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBreweriesInput
    upsert?: ServiceUpsertWithoutBreweriesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBreweriesInput, ServiceUpdateWithoutBreweriesInput>, ServiceUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryMusicCreateNestedManyWithoutMusicInput = {
    create?: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput> | BreweryMusicCreateWithoutMusicInput[] | BreweryMusicUncheckedCreateWithoutMusicInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutMusicInput | BreweryMusicCreateOrConnectWithoutMusicInput[]
    createMany?: BreweryMusicCreateManyMusicInputEnvelope
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
  }

  export type BreweryMusicUncheckedCreateNestedManyWithoutMusicInput = {
    create?: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput> | BreweryMusicCreateWithoutMusicInput[] | BreweryMusicUncheckedCreateWithoutMusicInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutMusicInput | BreweryMusicCreateOrConnectWithoutMusicInput[]
    createMany?: BreweryMusicCreateManyMusicInputEnvelope
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
  }

  export type BreweryMusicUpdateManyWithoutMusicNestedInput = {
    create?: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput> | BreweryMusicCreateWithoutMusicInput[] | BreweryMusicUncheckedCreateWithoutMusicInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutMusicInput | BreweryMusicCreateOrConnectWithoutMusicInput[]
    upsert?: BreweryMusicUpsertWithWhereUniqueWithoutMusicInput | BreweryMusicUpsertWithWhereUniqueWithoutMusicInput[]
    createMany?: BreweryMusicCreateManyMusicInputEnvelope
    set?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    disconnect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    delete?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    update?: BreweryMusicUpdateWithWhereUniqueWithoutMusicInput | BreweryMusicUpdateWithWhereUniqueWithoutMusicInput[]
    updateMany?: BreweryMusicUpdateManyWithWhereWithoutMusicInput | BreweryMusicUpdateManyWithWhereWithoutMusicInput[]
    deleteMany?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
  }

  export type BreweryMusicUncheckedUpdateManyWithoutMusicNestedInput = {
    create?: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput> | BreweryMusicCreateWithoutMusicInput[] | BreweryMusicUncheckedCreateWithoutMusicInput[]
    connectOrCreate?: BreweryMusicCreateOrConnectWithoutMusicInput | BreweryMusicCreateOrConnectWithoutMusicInput[]
    upsert?: BreweryMusicUpsertWithWhereUniqueWithoutMusicInput | BreweryMusicUpsertWithWhereUniqueWithoutMusicInput[]
    createMany?: BreweryMusicCreateManyMusicInputEnvelope
    set?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    disconnect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    delete?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    connect?: BreweryMusicWhereUniqueInput | BreweryMusicWhereUniqueInput[]
    update?: BreweryMusicUpdateWithWhereUniqueWithoutMusicInput | BreweryMusicUpdateWithWhereUniqueWithoutMusicInput[]
    updateMany?: BreweryMusicUpdateManyWithWhereWithoutMusicInput | BreweryMusicUpdateManyWithWhereWithoutMusicInput[]
    deleteMany?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
  }

  export type BreweryCreateNestedOneWithoutMusicInput = {
    create?: XOR<BreweryCreateWithoutMusicInput, BreweryUncheckedCreateWithoutMusicInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutMusicInput
    connect?: BreweryWhereUniqueInput
  }

  export type MusicCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<MusicCreateWithoutBreweriesInput, MusicUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: MusicCreateOrConnectWithoutBreweriesInput
    connect?: MusicWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutMusicNestedInput = {
    create?: XOR<BreweryCreateWithoutMusicInput, BreweryUncheckedCreateWithoutMusicInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutMusicInput
    upsert?: BreweryUpsertWithoutMusicInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutMusicInput, BreweryUpdateWithoutMusicInput>, BreweryUncheckedUpdateWithoutMusicInput>
  }

  export type MusicUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<MusicCreateWithoutBreweriesInput, MusicUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: MusicCreateOrConnectWithoutBreweriesInput
    upsert?: MusicUpsertWithoutBreweriesInput
    connect?: MusicWhereUniqueInput
    update?: XOR<XOR<MusicUpdateToOneWithWhereWithoutBreweriesInput, MusicUpdateWithoutBreweriesInput>, MusicUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryEventCreateNestedManyWithoutEventInput = {
    create?: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput> | BreweryEventCreateWithoutEventInput[] | BreweryEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutEventInput | BreweryEventCreateOrConnectWithoutEventInput[]
    createMany?: BreweryEventCreateManyEventInputEnvelope
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
  }

  export type BreweryEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput> | BreweryEventCreateWithoutEventInput[] | BreweryEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutEventInput | BreweryEventCreateOrConnectWithoutEventInput[]
    createMany?: BreweryEventCreateManyEventInputEnvelope
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
  }

  export type BreweryEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput> | BreweryEventCreateWithoutEventInput[] | BreweryEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutEventInput | BreweryEventCreateOrConnectWithoutEventInput[]
    upsert?: BreweryEventUpsertWithWhereUniqueWithoutEventInput | BreweryEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: BreweryEventCreateManyEventInputEnvelope
    set?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    disconnect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    delete?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    update?: BreweryEventUpdateWithWhereUniqueWithoutEventInput | BreweryEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: BreweryEventUpdateManyWithWhereWithoutEventInput | BreweryEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
  }

  export type BreweryEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput> | BreweryEventCreateWithoutEventInput[] | BreweryEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: BreweryEventCreateOrConnectWithoutEventInput | BreweryEventCreateOrConnectWithoutEventInput[]
    upsert?: BreweryEventUpsertWithWhereUniqueWithoutEventInput | BreweryEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: BreweryEventCreateManyEventInputEnvelope
    set?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    disconnect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    delete?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    connect?: BreweryEventWhereUniqueInput | BreweryEventWhereUniqueInput[]
    update?: BreweryEventUpdateWithWhereUniqueWithoutEventInput | BreweryEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: BreweryEventUpdateManyWithWhereWithoutEventInput | BreweryEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
  }

  export type BreweryCreateNestedOneWithoutBreweryEventInput = {
    create?: XOR<BreweryCreateWithoutBreweryEventInput, BreweryUncheckedCreateWithoutBreweryEventInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutBreweryEventInput
    connect?: BreweryWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<EventCreateWithoutBreweriesInput, EventUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: EventCreateOrConnectWithoutBreweriesInput
    connect?: EventWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutBreweryEventNestedInput = {
    create?: XOR<BreweryCreateWithoutBreweryEventInput, BreweryUncheckedCreateWithoutBreweryEventInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutBreweryEventInput
    upsert?: BreweryUpsertWithoutBreweryEventInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutBreweryEventInput, BreweryUpdateWithoutBreweryEventInput>, BreweryUncheckedUpdateWithoutBreweryEventInput>
  }

  export type EventUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<EventCreateWithoutBreweriesInput, EventUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: EventCreateOrConnectWithoutBreweriesInput
    upsert?: EventUpsertWithoutBreweriesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutBreweriesInput, EventUpdateWithoutBreweriesInput>, EventUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<BreweryCreateWithoutFeaturesInput, BreweryUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutFeaturesInput
    connect?: BreweryWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<BreweryCreateWithoutFeaturesInput, BreweryUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutFeaturesInput
    upsert?: BreweryUpsertWithoutFeaturesInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutFeaturesInput, BreweryUpdateWithoutFeaturesInput>, BreweryUncheckedUpdateWithoutFeaturesInput>
  }

  export type BreweryCreateNestedOneWithoutOperatingHoursInput = {
    create?: XOR<BreweryCreateWithoutOperatingHoursInput, BreweryUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutOperatingHoursInput
    connect?: BreweryWhereUniqueInput
  }

  export type BreweryUpdateOneRequiredWithoutOperatingHoursNestedInput = {
    create?: XOR<BreweryCreateWithoutOperatingHoursInput, BreweryUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutOperatingHoursInput
    upsert?: BreweryUpsertWithoutOperatingHoursInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutOperatingHoursInput, BreweryUpdateWithoutOperatingHoursInput>, BreweryUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutTourInput = {
    create?: XOR<UserCreateWithoutTourInput, UserUncheckedCreateWithoutTourInput>
    connectOrCreate?: UserCreateOrConnectWithoutTourInput
    connect?: UserWhereUniqueInput
  }

  export type TourBreweryCreateNestedManyWithoutTourInput = {
    create?: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput> | TourBreweryCreateWithoutTourInput[] | TourBreweryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutTourInput | TourBreweryCreateOrConnectWithoutTourInput[]
    createMany?: TourBreweryCreateManyTourInputEnvelope
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutTourInput = {
    create?: XOR<CityCreateWithoutTourInput, CityUncheckedCreateWithoutTourInput>
    connectOrCreate?: CityCreateOrConnectWithoutTourInput
    connect?: CityWhereUniqueInput
  }

  export type TourBreweryUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput> | TourBreweryCreateWithoutTourInput[] | TourBreweryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutTourInput | TourBreweryCreateOrConnectWithoutTourInput[]
    createMany?: TourBreweryCreateManyTourInputEnvelope
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTourNestedInput = {
    create?: XOR<UserCreateWithoutTourInput, UserUncheckedCreateWithoutTourInput>
    connectOrCreate?: UserCreateOrConnectWithoutTourInput
    upsert?: UserUpsertWithoutTourInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTourInput, UserUpdateWithoutTourInput>, UserUncheckedUpdateWithoutTourInput>
  }

  export type TourBreweryUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput> | TourBreweryCreateWithoutTourInput[] | TourBreweryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutTourInput | TourBreweryCreateOrConnectWithoutTourInput[]
    upsert?: TourBreweryUpsertWithWhereUniqueWithoutTourInput | TourBreweryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourBreweryCreateManyTourInputEnvelope
    set?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    disconnect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    delete?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    update?: TourBreweryUpdateWithWhereUniqueWithoutTourInput | TourBreweryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourBreweryUpdateManyWithWhereWithoutTourInput | TourBreweryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
  }

  export type CityUpdateOneRequiredWithoutTourNestedInput = {
    create?: XOR<CityCreateWithoutTourInput, CityUncheckedCreateWithoutTourInput>
    connectOrCreate?: CityCreateOrConnectWithoutTourInput
    upsert?: CityUpsertWithoutTourInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutTourInput, CityUpdateWithoutTourInput>, CityUncheckedUpdateWithoutTourInput>
  }

  export type TourBreweryUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput> | TourBreweryCreateWithoutTourInput[] | TourBreweryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourBreweryCreateOrConnectWithoutTourInput | TourBreweryCreateOrConnectWithoutTourInput[]
    upsert?: TourBreweryUpsertWithWhereUniqueWithoutTourInput | TourBreweryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourBreweryCreateManyTourInputEnvelope
    set?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    disconnect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    delete?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    connect?: TourBreweryWhereUniqueInput | TourBreweryWhereUniqueInput[]
    update?: TourBreweryUpdateWithWhereUniqueWithoutTourInput | TourBreweryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourBreweryUpdateManyWithWhereWithoutTourInput | TourBreweryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutBreweriesInput = {
    create?: XOR<TourCreateWithoutBreweriesInput, TourUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: TourCreateOrConnectWithoutBreweriesInput
    connect?: TourWhereUniqueInput
  }

  export type BreweryCreateNestedOneWithoutToursInput = {
    create?: XOR<BreweryCreateWithoutToursInput, BreweryUncheckedCreateWithoutToursInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutToursInput
    connect?: BreweryWhereUniqueInput
  }

  export type TourUpdateOneRequiredWithoutBreweriesNestedInput = {
    create?: XOR<TourCreateWithoutBreweriesInput, TourUncheckedCreateWithoutBreweriesInput>
    connectOrCreate?: TourCreateOrConnectWithoutBreweriesInput
    upsert?: TourUpsertWithoutBreweriesInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutBreweriesInput, TourUpdateWithoutBreweriesInput>, TourUncheckedUpdateWithoutBreweriesInput>
  }

  export type BreweryUpdateOneWithoutToursNestedInput = {
    create?: XOR<BreweryCreateWithoutToursInput, BreweryUncheckedCreateWithoutToursInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutToursInput
    upsert?: BreweryUpsertWithoutToursInput
    disconnect?: boolean
    delete?: BreweryWhereInput | boolean
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutToursInput, BreweryUpdateWithoutToursInput>, BreweryUncheckedUpdateWithoutToursInput>
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type RecipientCreateNestedManyWithoutNotificationInput = {
    create?: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput> | RecipientCreateWithoutNotificationInput[] | RecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutNotificationInput | RecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: RecipientCreateManyNotificationInputEnvelope
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
  }

  export type RecipientUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput> | RecipientCreateWithoutNotificationInput[] | RecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutNotificationInput | RecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: RecipientCreateManyNotificationInputEnvelope
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type RecipientUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput> | RecipientCreateWithoutNotificationInput[] | RecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutNotificationInput | RecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: RecipientUpsertWithWhereUniqueWithoutNotificationInput | RecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: RecipientCreateManyNotificationInputEnvelope
    set?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    disconnect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    delete?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    update?: RecipientUpdateWithWhereUniqueWithoutNotificationInput | RecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: RecipientUpdateManyWithWhereWithoutNotificationInput | RecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
  }

  export type RecipientUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput> | RecipientCreateWithoutNotificationInput[] | RecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: RecipientCreateOrConnectWithoutNotificationInput | RecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: RecipientUpsertWithWhereUniqueWithoutNotificationInput | RecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: RecipientCreateManyNotificationInputEnvelope
    set?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    disconnect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    delete?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    connect?: RecipientWhereUniqueInput | RecipientWhereUniqueInput[]
    update?: RecipientUpdateWithWhereUniqueWithoutNotificationInput | RecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: RecipientUpdateManyWithWhereWithoutNotificationInput | RecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedNotificationsInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NotificationUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    upsert?: NotificationUpsertWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutRecipientsInput, NotificationUpdateWithoutRecipientsInput>, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    upsert?: UserUpsertWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedNotificationsInput, UserUpdateWithoutReceivedNotificationsInput>, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type AdRatesCreateNestedManyWithoutAdTypeInput = {
    create?: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput> | AdRatesCreateWithoutAdTypeInput[] | AdRatesUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutAdTypeInput | AdRatesCreateOrConnectWithoutAdTypeInput[]
    createMany?: AdRatesCreateManyAdTypeInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutAdTypeInput = {
    create?: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput> | AdCreateWithoutAdTypeInput[] | AdUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdTypeInput | AdCreateOrConnectWithoutAdTypeInput[]
    createMany?: AdCreateManyAdTypeInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdRatesUncheckedCreateNestedManyWithoutAdTypeInput = {
    create?: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput> | AdRatesCreateWithoutAdTypeInput[] | AdRatesUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutAdTypeInput | AdRatesCreateOrConnectWithoutAdTypeInput[]
    createMany?: AdRatesCreateManyAdTypeInputEnvelope
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutAdTypeInput = {
    create?: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput> | AdCreateWithoutAdTypeInput[] | AdUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdTypeInput | AdCreateOrConnectWithoutAdTypeInput[]
    createMany?: AdCreateManyAdTypeInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdRatesUpdateManyWithoutAdTypeNestedInput = {
    create?: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput> | AdRatesCreateWithoutAdTypeInput[] | AdRatesUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutAdTypeInput | AdRatesCreateOrConnectWithoutAdTypeInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutAdTypeInput | AdRatesUpsertWithWhereUniqueWithoutAdTypeInput[]
    createMany?: AdRatesCreateManyAdTypeInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutAdTypeInput | AdRatesUpdateWithWhereUniqueWithoutAdTypeInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutAdTypeInput | AdRatesUpdateManyWithWhereWithoutAdTypeInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUpdateManyWithoutAdTypeNestedInput = {
    create?: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput> | AdCreateWithoutAdTypeInput[] | AdUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdTypeInput | AdCreateOrConnectWithoutAdTypeInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAdTypeInput | AdUpsertWithWhereUniqueWithoutAdTypeInput[]
    createMany?: AdCreateManyAdTypeInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAdTypeInput | AdUpdateWithWhereUniqueWithoutAdTypeInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAdTypeInput | AdUpdateManyWithWhereWithoutAdTypeInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdRatesUncheckedUpdateManyWithoutAdTypeNestedInput = {
    create?: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput> | AdRatesCreateWithoutAdTypeInput[] | AdRatesUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdRatesCreateOrConnectWithoutAdTypeInput | AdRatesCreateOrConnectWithoutAdTypeInput[]
    upsert?: AdRatesUpsertWithWhereUniqueWithoutAdTypeInput | AdRatesUpsertWithWhereUniqueWithoutAdTypeInput[]
    createMany?: AdRatesCreateManyAdTypeInputEnvelope
    set?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    disconnect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    delete?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    connect?: AdRatesWhereUniqueInput | AdRatesWhereUniqueInput[]
    update?: AdRatesUpdateWithWhereUniqueWithoutAdTypeInput | AdRatesUpdateWithWhereUniqueWithoutAdTypeInput[]
    updateMany?: AdRatesUpdateManyWithWhereWithoutAdTypeInput | AdRatesUpdateManyWithWhereWithoutAdTypeInput[]
    deleteMany?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutAdTypeNestedInput = {
    create?: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput> | AdCreateWithoutAdTypeInput[] | AdUncheckedCreateWithoutAdTypeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdTypeInput | AdCreateOrConnectWithoutAdTypeInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAdTypeInput | AdUpsertWithWhereUniqueWithoutAdTypeInput[]
    createMany?: AdCreateManyAdTypeInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAdTypeInput | AdUpdateWithWhereUniqueWithoutAdTypeInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAdTypeInput | AdUpdateManyWithWhereWithoutAdTypeInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type StateCreateNestedOneWithoutAdRatesInput = {
    create?: XOR<StateCreateWithoutAdRatesInput, StateUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: StateCreateOrConnectWithoutAdRatesInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdRatesInput = {
    create?: XOR<CityCreateWithoutAdRatesInput, CityUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdRatesInput
    connect?: CityWhereUniqueInput
  }

  export type AdTypeCreateNestedOneWithoutAdRatesInput = {
    create?: XOR<AdTypeCreateWithoutAdRatesInput, AdTypeUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: AdTypeCreateOrConnectWithoutAdRatesInput
    connect?: AdTypeWhereUniqueInput
  }

  export type StateUpdateOneRequiredWithoutAdRatesNestedInput = {
    create?: XOR<StateCreateWithoutAdRatesInput, StateUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: StateCreateOrConnectWithoutAdRatesInput
    upsert?: StateUpsertWithoutAdRatesInput
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutAdRatesInput, StateUpdateWithoutAdRatesInput>, StateUncheckedUpdateWithoutAdRatesInput>
  }

  export type CityUpdateOneRequiredWithoutAdRatesNestedInput = {
    create?: XOR<CityCreateWithoutAdRatesInput, CityUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdRatesInput
    upsert?: CityUpsertWithoutAdRatesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAdRatesInput, CityUpdateWithoutAdRatesInput>, CityUncheckedUpdateWithoutAdRatesInput>
  }

  export type AdTypeUpdateOneRequiredWithoutAdRatesNestedInput = {
    create?: XOR<AdTypeCreateWithoutAdRatesInput, AdTypeUncheckedCreateWithoutAdRatesInput>
    connectOrCreate?: AdTypeCreateOrConnectWithoutAdRatesInput
    upsert?: AdTypeUpsertWithoutAdRatesInput
    connect?: AdTypeWhereUniqueInput
    update?: XOR<XOR<AdTypeUpdateToOneWithWhereWithoutAdRatesInput, AdTypeUpdateWithoutAdRatesInput>, AdTypeUncheckedUpdateWithoutAdRatesInput>
  }

  export type AdCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput> | AdCreateWithoutCategoryInput[] | AdUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCategoryInput | AdCreateOrConnectWithoutCategoryInput[]
    createMany?: AdCreateManyCategoryInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput> | AdCreateWithoutCategoryInput[] | AdUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCategoryInput | AdCreateOrConnectWithoutCategoryInput[]
    createMany?: AdCreateManyCategoryInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput> | AdCreateWithoutCategoryInput[] | AdUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCategoryInput | AdCreateOrConnectWithoutCategoryInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCategoryInput | AdUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AdCreateManyCategoryInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCategoryInput | AdUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCategoryInput | AdUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput> | AdCreateWithoutCategoryInput[] | AdUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCategoryInput | AdCreateOrConnectWithoutCategoryInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCategoryInput | AdUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AdCreateManyCategoryInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCategoryInput | AdUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCategoryInput | AdUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdCreateselectedDaysInput = {
    set: number[]
  }

  export type AdCreateselectedDatesInput = {
    set: Date[] | string[]
  }

  export type AdTypeCreateNestedOneWithoutAdInput = {
    create?: XOR<AdTypeCreateWithoutAdInput, AdTypeUncheckedCreateWithoutAdInput>
    connectOrCreate?: AdTypeCreateOrConnectWithoutAdInput
    connect?: AdTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdInput = {
    create?: XOR<UserCreateWithoutAdInput, UserUncheckedCreateWithoutAdInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutAdInput = {
    create?: XOR<CategoryCreateWithoutAdInput, CategoryUncheckedCreateWithoutAdInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAdInput
    connect?: CategoryWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutAdInput = {
    create?: XOR<StateCreateWithoutAdInput, StateUncheckedCreateWithoutAdInput>
    connectOrCreate?: StateCreateOrConnectWithoutAdInput
    connect?: StateWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdInput = {
    create?: XOR<CityCreateWithoutAdInput, CityUncheckedCreateWithoutAdInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdInput
    connect?: CityWhereUniqueInput
  }

  export type AdUpdateselectedDaysInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AdUpdateselectedDatesInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type AdTypeUpdateOneRequiredWithoutAdNestedInput = {
    create?: XOR<AdTypeCreateWithoutAdInput, AdTypeUncheckedCreateWithoutAdInput>
    connectOrCreate?: AdTypeCreateOrConnectWithoutAdInput
    upsert?: AdTypeUpsertWithoutAdInput
    connect?: AdTypeWhereUniqueInput
    update?: XOR<XOR<AdTypeUpdateToOneWithWhereWithoutAdInput, AdTypeUpdateWithoutAdInput>, AdTypeUncheckedUpdateWithoutAdInput>
  }

  export type UserUpdateOneWithoutAdNestedInput = {
    create?: XOR<UserCreateWithoutAdInput, UserUncheckedCreateWithoutAdInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdInput
    upsert?: UserUpsertWithoutAdInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdInput, UserUpdateWithoutAdInput>, UserUncheckedUpdateWithoutAdInput>
  }

  export type CategoryUpdateOneRequiredWithoutAdNestedInput = {
    create?: XOR<CategoryCreateWithoutAdInput, CategoryUncheckedCreateWithoutAdInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAdInput
    upsert?: CategoryUpsertWithoutAdInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutAdInput, CategoryUpdateWithoutAdInput>, CategoryUncheckedUpdateWithoutAdInput>
  }

  export type StateUpdateOneWithoutAdNestedInput = {
    create?: XOR<StateCreateWithoutAdInput, StateUncheckedCreateWithoutAdInput>
    connectOrCreate?: StateCreateOrConnectWithoutAdInput
    upsert?: StateUpsertWithoutAdInput
    disconnect?: boolean
    delete?: StateWhereInput | boolean
    connect?: StateWhereUniqueInput
    update?: XOR<XOR<StateUpdateToOneWithWhereWithoutAdInput, StateUpdateWithoutAdInput>, StateUncheckedUpdateWithoutAdInput>
  }

  export type CityUpdateOneWithoutAdNestedInput = {
    create?: XOR<CityCreateWithoutAdInput, CityUncheckedCreateWithoutAdInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdInput
    upsert?: CityUpsertWithoutAdInput
    disconnect?: boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAdInput, CityUpdateWithoutAdInput>, CityUncheckedUpdateWithoutAdInput>
  }

  export type EnumTypeTextFieldUpdateOperationsInput = {
    set?: $Enums.TypeText
  }

  export type BreweryCreateNestedOneWithoutMediaInput = {
    create?: XOR<BreweryCreateWithoutMediaInput, BreweryUncheckedCreateWithoutMediaInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutMediaInput
    connect?: BreweryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMediaInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type EnumMediaStatusFieldUpdateOperationsInput = {
    set?: $Enums.MediaStatus
  }

  export type BreweryUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<BreweryCreateWithoutMediaInput, BreweryUncheckedCreateWithoutMediaInput>
    connectOrCreate?: BreweryCreateOrConnectWithoutMediaInput
    upsert?: BreweryUpsertWithoutMediaInput
    connect?: BreweryWhereUniqueInput
    update?: XOR<XOR<BreweryUpdateToOneWithWhereWithoutMediaInput, BreweryUpdateWithoutMediaInput>, BreweryUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateOneWithoutMediaNestedInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    upsert?: UserUpsertWithoutMediaInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaInput, UserUpdateWithoutMediaInput>, UserUncheckedUpdateWithoutMediaInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTypeTextFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeText | EnumTypeTextFieldRefInput<$PrismaModel>
    in?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeTextFilter<$PrismaModel> | $Enums.TypeText
  }

  export type NestedEnumTypeTextWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeText | EnumTypeTextFieldRefInput<$PrismaModel>
    in?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeText[] | ListEnumTypeTextFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeTextWithAggregatesFilter<$PrismaModel> | $Enums.TypeText
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeTextFilter<$PrismaModel>
    _max?: NestedEnumTypeTextFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaStatus | EnumMediaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaStatusFilter<$PrismaModel> | $Enums.MediaStatus
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumMediaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaStatus | EnumMediaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaStatus[] | ListEnumMediaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaStatusWithAggregatesFilter<$PrismaModel> | $Enums.MediaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaStatusFilter<$PrismaModel>
    _max?: NestedEnumMediaStatusFilter<$PrismaModel>
  }

  export type BreweryCreateWithoutOwnerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutOwnerInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput>
  }

  export type BreweryCreateManyOwnerInputEnvelope = {
    data: BreweryCreateManyOwnerInput | BreweryCreateManyOwnerInput[]
  }

  export type BreweryCreateWithoutManagerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutManagerInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput>
  }

  export type BreweryCreateManyManagerInputEnvelope = {
    data: BreweryCreateManyManagerInput | BreweryCreateManyManagerInput[]
  }

  export type CityCreateWithoutUserInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUserInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUserInput, CityUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: RecipientCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: RecipientUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
  }

  export type RecipientCreateWithoutRecipientInput = {
    id?: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
  }

  export type RecipientUncheckedCreateWithoutRecipientInput = {
    id?: string
    notificationId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientCreateOrConnectWithoutRecipientInput = {
    where: RecipientWhereUniqueInput
    create: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput>
  }

  export type RecipientCreateManyRecipientInputEnvelope = {
    data: RecipientCreateManyRecipientInput | RecipientCreateManyRecipientInput[]
  }

  export type TourCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: TourBreweryCreateNestedManyWithoutTourInput
    city: CityCreateNestedOneWithoutTourInput
  }

  export type TourUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    cityId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: TourBreweryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutUserInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput>
  }

  export type TourCreateManyUserInputEnvelope = {
    data: TourCreateManyUserInput | TourCreateManyUserInput[]
  }

  export type AdCreateWithoutUserInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adType: AdTypeCreateNestedOneWithoutAdInput
    category: CategoryCreateNestedOneWithoutAdInput
    state?: StateCreateNestedOneWithoutAdInput
    city?: CityCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateOrConnectWithoutUserInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput>
  }

  export type AdCreateManyUserInputEnvelope = {
    data: AdCreateManyUserInput | AdCreateManyUserInput[]
  }

  export type MediaCreateWithoutApprovedByInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutApprovedByInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    breweryId: string
  }

  export type MediaCreateOrConnectWithoutApprovedByInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput>
  }

  export type MediaCreateManyApprovedByInputEnvelope = {
    data: MediaCreateManyApprovedByInput | MediaCreateManyApprovedByInput[]
  }

  export type BreweryUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BreweryWhereUniqueInput
    update: XOR<BreweryUpdateWithoutOwnerInput, BreweryUncheckedUpdateWithoutOwnerInput>
    create: XOR<BreweryCreateWithoutOwnerInput, BreweryUncheckedCreateWithoutOwnerInput>
  }

  export type BreweryUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BreweryWhereUniqueInput
    data: XOR<BreweryUpdateWithoutOwnerInput, BreweryUncheckedUpdateWithoutOwnerInput>
  }

  export type BreweryUpdateManyWithWhereWithoutOwnerInput = {
    where: BreweryScalarWhereInput
    data: XOR<BreweryUpdateManyMutationInput, BreweryUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BreweryScalarWhereInput = {
    AND?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
    OR?: BreweryScalarWhereInput[]
    NOT?: BreweryScalarWhereInput | BreweryScalarWhereInput[]
    id?: StringFilter<"Brewery"> | string
    name?: StringFilter<"Brewery"> | string
    type?: StringNullableFilter<"Brewery"> | string | null
    website?: StringNullableFilter<"Brewery"> | string | null
    ownerId?: StringNullableFilter<"Brewery"> | string | null
    managerId?: StringNullableFilter<"Brewery"> | string | null
    comments?: StringNullableFilter<"Brewery"> | string | null
    merchandise?: BoolNullableFilter<"Brewery"> | boolean | null
    social_media?: BoolNullableFilter<"Brewery"> | boolean | null
    status?: EnumStatusFilter<"Brewery"> | $Enums.Status
    locationId?: StringFilter<"Brewery"> | string
    createdAt?: DateTimeFilter<"Brewery"> | Date | string
    updatedAt?: DateTimeFilter<"Brewery"> | Date | string
  }

  export type BreweryUpsertWithWhereUniqueWithoutManagerInput = {
    where: BreweryWhereUniqueInput
    update: XOR<BreweryUpdateWithoutManagerInput, BreweryUncheckedUpdateWithoutManagerInput>
    create: XOR<BreweryCreateWithoutManagerInput, BreweryUncheckedCreateWithoutManagerInput>
  }

  export type BreweryUpdateWithWhereUniqueWithoutManagerInput = {
    where: BreweryWhereUniqueInput
    data: XOR<BreweryUpdateWithoutManagerInput, BreweryUncheckedUpdateWithoutManagerInput>
  }

  export type BreweryUpdateManyWithWhereWithoutManagerInput = {
    where: BreweryScalarWhereInput
    data: XOR<BreweryUpdateManyMutationInput, BreweryUncheckedUpdateManyWithoutManagerInput>
  }

  export type CityUpsertWithoutUserInput = {
    update: XOR<CityUpdateWithoutUserInput, CityUncheckedUpdateWithoutUserInput>
    create: XOR<CityCreateWithoutUserInput, CityUncheckedCreateWithoutUserInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUserInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUserInput, CityUncheckedUpdateWithoutUserInput>
  }

  export type CityUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type RecipientUpsertWithWhereUniqueWithoutRecipientInput = {
    where: RecipientWhereUniqueInput
    update: XOR<RecipientUpdateWithoutRecipientInput, RecipientUncheckedUpdateWithoutRecipientInput>
    create: XOR<RecipientCreateWithoutRecipientInput, RecipientUncheckedCreateWithoutRecipientInput>
  }

  export type RecipientUpdateWithWhereUniqueWithoutRecipientInput = {
    where: RecipientWhereUniqueInput
    data: XOR<RecipientUpdateWithoutRecipientInput, RecipientUncheckedUpdateWithoutRecipientInput>
  }

  export type RecipientUpdateManyWithWhereWithoutRecipientInput = {
    where: RecipientScalarWhereInput
    data: XOR<RecipientUpdateManyMutationInput, RecipientUncheckedUpdateManyWithoutRecipientInput>
  }

  export type RecipientScalarWhereInput = {
    AND?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
    OR?: RecipientScalarWhereInput[]
    NOT?: RecipientScalarWhereInput | RecipientScalarWhereInput[]
    id?: StringFilter<"Recipient"> | string
    notificationId?: StringFilter<"Recipient"> | string
    userId?: StringFilter<"Recipient"> | string
    read?: BoolFilter<"Recipient"> | boolean
    createdAt?: DateTimeFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeFilter<"Recipient"> | Date | string
  }

  export type TourUpsertWithWhereUniqueWithoutUserInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutUserInput, TourUncheckedUpdateWithoutUserInput>
    create: XOR<TourCreateWithoutUserInput, TourUncheckedCreateWithoutUserInput>
  }

  export type TourUpdateWithWhereUniqueWithoutUserInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutUserInput, TourUncheckedUpdateWithoutUserInput>
  }

  export type TourUpdateManyWithWhereWithoutUserInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutUserInput>
  }

  export type TourScalarWhereInput = {
    AND?: TourScalarWhereInput | TourScalarWhereInput[]
    OR?: TourScalarWhereInput[]
    NOT?: TourScalarWhereInput | TourScalarWhereInput[]
    id?: StringFilter<"Tour"> | string
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    image?: StringNullableFilter<"Tour"> | string | null
    userId?: StringFilter<"Tour"> | string
    cityId?: StringFilter<"Tour"> | string
    radius?: FloatFilter<"Tour"> | number
    startDate?: DateTimeFilter<"Tour"> | Date | string
    breweryCount?: IntFilter<"Tour"> | number
    days?: IntFilter<"Tour"> | number
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
  }

  export type AdUpsertWithWhereUniqueWithoutUserInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutUserInput, AdUncheckedUpdateWithoutUserInput>
    create: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput>
  }

  export type AdUpdateWithWhereUniqueWithoutUserInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutUserInput, AdUncheckedUpdateWithoutUserInput>
  }

  export type AdUpdateManyWithWhereWithoutUserInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutUserInput>
  }

  export type AdScalarWhereInput = {
    AND?: AdScalarWhereInput | AdScalarWhereInput[]
    OR?: AdScalarWhereInput[]
    NOT?: AdScalarWhereInput | AdScalarWhereInput[]
    id?: StringFilter<"Ad"> | string
    name?: StringFilter<"Ad"> | string
    adTypesId?: StringFilter<"Ad"> | string
    linkUrl?: StringNullableFilter<"Ad"> | string | null
    buttonName?: StringNullableFilter<"Ad"> | string | null
    desktopFile?: StringNullableFilter<"Ad"> | string | null
    mobileFile?: StringNullableFilter<"Ad"> | string | null
    font?: StringNullableFilter<"Ad"> | string | null
    text1?: StringNullableFilter<"Ad"> | string | null
    text1Color?: StringNullableFilter<"Ad"> | string | null
    text2?: StringNullableFilter<"Ad"> | string | null
    text2Color?: StringNullableFilter<"Ad"> | string | null
    bgImage?: StringNullableFilter<"Ad"> | string | null
    payStatus?: StringNullableFilter<"Ad"> | string | null
    status?: EnumStatusFilter<"Ad"> | $Enums.Status
    totalCost?: FloatNullableFilter<"Ad"> | number | null
    userId?: StringNullableFilter<"Ad"> | string | null
    categoryId?: StringFilter<"Ad"> | string
    urlVideo?: StringFilter<"Ad"> | string
    desktopVideoFile?: StringFilter<"Ad"> | string
    desktopVideoPreview?: StringFilter<"Ad"> | string
    mobileVideoFile?: StringFilter<"Ad"> | string
    mobileVideoPreview?: StringFilter<"Ad"> | string
    stateId?: StringNullableFilter<"Ad"> | string | null
    cityId?: StringNullableFilter<"Ad"> | string | null
    selectedDays?: IntNullableListFilter<"Ad">
    selectedDates?: DateTimeNullableListFilter<"Ad">
    startDate?: DateTimeFilter<"Ad"> | Date | string
    endDate?: DateTimeFilter<"Ad"> | Date | string
    clicks?: IntFilter<"Ad"> | number
    views?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutApprovedByInput, MediaUncheckedUpdateWithoutApprovedByInput>
    create: XOR<MediaCreateWithoutApprovedByInput, MediaUncheckedCreateWithoutApprovedByInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutApprovedByInput, MediaUncheckedUpdateWithoutApprovedByInput>
  }

  export type MediaUpdateManyWithWhereWithoutApprovedByInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    url?: StringFilter<"Media"> | string
    thumbnail?: StringNullableFilter<"Media"> | string | null
    status?: EnumMediaStatusFilter<"Media"> | $Enums.MediaStatus
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    breweryId?: StringFilter<"Media"> | string
    approvedById?: StringNullableFilter<"Media"> | string | null
  }

  export type CountyCreateWithoutStateInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutCountyInput
    Location?: LocationCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutCountyInput
    Location?: LocationUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutStateInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput>
  }

  export type CountyCreateManyStateInputEnvelope = {
    data: CountyCreateManyStateInput | CountyCreateManyStateInput[]
  }

  export type CityCreateWithoutStateInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    city_ascii?: string | null
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: CityCreateManyStateInput | CityCreateManyStateInput[]
  }

  export type LocationCreateWithoutStateInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutLocationInput
    Brewery?: BreweryCreateNestedManyWithoutLocationInput
    County?: CountyCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStateInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    countyId?: string | null
    Brewery?: BreweryUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStateInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput>
  }

  export type LocationCreateManyStateInputEnvelope = {
    data: LocationCreateManyStateInput | LocationCreateManyStateInput[]
  }

  export type AdRatesCreateWithoutStateInput = {
    id?: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutAdRatesInput
    adType: AdTypeCreateNestedOneWithoutAdRatesInput
  }

  export type AdRatesUncheckedCreateWithoutStateInput = {
    id?: string
    cityId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesCreateOrConnectWithoutStateInput = {
    where: AdRatesWhereUniqueInput
    create: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput>
  }

  export type AdRatesCreateManyStateInputEnvelope = {
    data: AdRatesCreateManyStateInput | AdRatesCreateManyStateInput[]
  }

  export type AdCreateWithoutStateInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adType: AdTypeCreateNestedOneWithoutAdInput
    user?: UserCreateNestedOneWithoutAdInput
    category: CategoryCreateNestedOneWithoutAdInput
    city?: CityCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateOrConnectWithoutStateInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput>
  }

  export type AdCreateManyStateInputEnvelope = {
    data: AdCreateManyStateInput | AdCreateManyStateInput[]
  }

  export type CountyUpsertWithWhereUniqueWithoutStateInput = {
    where: CountyWhereUniqueInput
    update: XOR<CountyUpdateWithoutStateInput, CountyUncheckedUpdateWithoutStateInput>
    create: XOR<CountyCreateWithoutStateInput, CountyUncheckedCreateWithoutStateInput>
  }

  export type CountyUpdateWithWhereUniqueWithoutStateInput = {
    where: CountyWhereUniqueInput
    data: XOR<CountyUpdateWithoutStateInput, CountyUncheckedUpdateWithoutStateInput>
  }

  export type CountyUpdateManyWithWhereWithoutStateInput = {
    where: CountyScalarWhereInput
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyWithoutStateInput>
  }

  export type CountyScalarWhereInput = {
    AND?: CountyScalarWhereInput | CountyScalarWhereInput[]
    OR?: CountyScalarWhereInput[]
    NOT?: CountyScalarWhereInput | CountyScalarWhereInput[]
    id?: StringFilter<"County"> | string
    name?: StringFilter<"County"> | string
    county_fips?: StringFilter<"County"> | string
    stateId?: StringFilter<"County"> | string
    createdAt?: DateTimeFilter<"County"> | Date | string
    updatedAt?: DateTimeFilter<"County"> | Date | string
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutStateInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    city_ascii?: StringNullableFilter<"City"> | string | null
    stateId?: StringFilter<"City"> | string
    countyId?: StringFilter<"City"> | string
    lat?: FloatNullableFilter<"City"> | number | null
    lng?: FloatNullableFilter<"City"> | number | null
    population?: IntNullableFilter<"City"> | number | null
    timezone?: StringNullableFilter<"City"> | string | null
    ranking?: IntNullableFilter<"City"> | number | null
    zip?: StringNullableFilter<"City"> | string | null
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    uniqueCityIdentifier?: StringFilter<"City"> | string
  }

  export type LocationUpsertWithWhereUniqueWithoutStateInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutStateInput, LocationUncheckedUpdateWithoutStateInput>
    create: XOR<LocationCreateWithoutStateInput, LocationUncheckedCreateWithoutStateInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutStateInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutStateInput, LocationUncheckedUpdateWithoutStateInput>
  }

  export type LocationUpdateManyWithWhereWithoutStateInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutStateInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    cityId?: StringFilter<"Location"> | string
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    zip?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    stateId?: StringNullableFilter<"Location"> | string | null
    countyId?: StringNullableFilter<"Location"> | string | null
  }

  export type AdRatesUpsertWithWhereUniqueWithoutStateInput = {
    where: AdRatesWhereUniqueInput
    update: XOR<AdRatesUpdateWithoutStateInput, AdRatesUncheckedUpdateWithoutStateInput>
    create: XOR<AdRatesCreateWithoutStateInput, AdRatesUncheckedCreateWithoutStateInput>
  }

  export type AdRatesUpdateWithWhereUniqueWithoutStateInput = {
    where: AdRatesWhereUniqueInput
    data: XOR<AdRatesUpdateWithoutStateInput, AdRatesUncheckedUpdateWithoutStateInput>
  }

  export type AdRatesUpdateManyWithWhereWithoutStateInput = {
    where: AdRatesScalarWhereInput
    data: XOR<AdRatesUpdateManyMutationInput, AdRatesUncheckedUpdateManyWithoutStateInput>
  }

  export type AdRatesScalarWhereInput = {
    AND?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
    OR?: AdRatesScalarWhereInput[]
    NOT?: AdRatesScalarWhereInput | AdRatesScalarWhereInput[]
    id?: StringFilter<"AdRates"> | string
    stateId?: StringFilter<"AdRates"> | string
    cityId?: StringFilter<"AdRates"> | string
    adTypeId?: StringFilter<"AdRates"> | string
    rate?: FloatFilter<"AdRates"> | number
    status?: EnumStatusFilter<"AdRates"> | $Enums.Status
    createdAt?: DateTimeFilter<"AdRates"> | Date | string
    updatedAt?: DateTimeFilter<"AdRates"> | Date | string
  }

  export type AdUpsertWithWhereUniqueWithoutStateInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutStateInput, AdUncheckedUpdateWithoutStateInput>
    create: XOR<AdCreateWithoutStateInput, AdUncheckedCreateWithoutStateInput>
  }

  export type AdUpdateWithWhereUniqueWithoutStateInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutStateInput, AdUncheckedUpdateWithoutStateInput>
  }

  export type AdUpdateManyWithWhereWithoutStateInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutStateInput>
  }

  export type StateCreateWithoutCountiesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutStateInput
    Location?: LocationCreateNestedManyWithoutStateInput
    AdRates?: AdRatesCreateNestedManyWithoutStateInput
    Ad?: AdCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountiesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    Location?: LocationUncheckedCreateNestedManyWithoutStateInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutStateInput
    Ad?: AdUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountiesInput, StateUncheckedCreateWithoutCountiesInput>
  }

  export type CityCreateWithoutCountyInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountyInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountyInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput>
  }

  export type CityCreateManyCountyInputEnvelope = {
    data: CityCreateManyCountyInput | CityCreateManyCountyInput[]
  }

  export type LocationCreateWithoutCountyInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutLocationInput
    Brewery?: BreweryCreateNestedManyWithoutLocationInput
    State?: StateCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCountyInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    Brewery?: BreweryUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCountyInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput>
  }

  export type LocationCreateManyCountyInputEnvelope = {
    data: LocationCreateManyCountyInput | LocationCreateManyCountyInput[]
  }

  export type StateUpsertWithoutCountiesInput = {
    update: XOR<StateUpdateWithoutCountiesInput, StateUncheckedUpdateWithoutCountiesInput>
    create: XOR<StateCreateWithoutCountiesInput, StateUncheckedCreateWithoutCountiesInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutCountiesInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutCountiesInput, StateUncheckedUpdateWithoutCountiesInput>
  }

  export type StateUpdateWithoutCountiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutStateNestedInput
    Location?: LocationUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUpdateManyWithoutStateNestedInput
    Ad?: AdUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCountiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutStateNestedInput
    Ad?: AdUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutCountyInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountyInput, CityUncheckedUpdateWithoutCountyInput>
    create: XOR<CityCreateWithoutCountyInput, CityUncheckedCreateWithoutCountyInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountyInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountyInput, CityUncheckedUpdateWithoutCountyInput>
  }

  export type CityUpdateManyWithWhereWithoutCountyInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountyInput>
  }

  export type LocationUpsertWithWhereUniqueWithoutCountyInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutCountyInput, LocationUncheckedUpdateWithoutCountyInput>
    create: XOR<LocationCreateWithoutCountyInput, LocationUncheckedCreateWithoutCountyInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutCountyInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutCountyInput, LocationUncheckedUpdateWithoutCountyInput>
  }

  export type LocationUpdateManyWithWhereWithoutCountyInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutCountyInput>
  }

  export type StateCreateWithoutCitiesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyCreateNestedManyWithoutStateInput
    Location?: LocationCreateNestedManyWithoutStateInput
    AdRates?: AdRatesCreateNestedManyWithoutStateInput
    Ad?: AdCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyUncheckedCreateNestedManyWithoutStateInput
    Location?: LocationUncheckedCreateNestedManyWithoutStateInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutStateInput
    Ad?: AdUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type CountyCreateWithoutCitiesInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutCountiesInput
    Location?: LocationCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    county_fips: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutCitiesInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutCitiesInput, CountyUncheckedCreateWithoutCitiesInput>
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
  }

  export type LocationCreateWithoutCityInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Brewery?: BreweryCreateNestedManyWithoutLocationInput
    State?: StateCreateNestedOneWithoutLocationInput
    County?: CountyCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCityInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    countyId?: string | null
    Brewery?: BreweryUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCityInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput>
  }

  export type LocationCreateManyCityInputEnvelope = {
    data: LocationCreateManyCityInput | LocationCreateManyCityInput[]
  }

  export type TourCreateWithoutCityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTourInput
    breweries?: TourBreweryCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    userId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    breweries?: TourBreweryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutCityInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput>
  }

  export type TourCreateManyCityInputEnvelope = {
    data: TourCreateManyCityInput | TourCreateManyCityInput[]
  }

  export type AdRatesCreateWithoutCityInput = {
    id?: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutAdRatesInput
    adType: AdTypeCreateNestedOneWithoutAdRatesInput
  }

  export type AdRatesUncheckedCreateWithoutCityInput = {
    id?: string
    stateId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesCreateOrConnectWithoutCityInput = {
    where: AdRatesWhereUniqueInput
    create: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput>
  }

  export type AdRatesCreateManyCityInputEnvelope = {
    data: AdRatesCreateManyCityInput | AdRatesCreateManyCityInput[]
  }

  export type AdCreateWithoutCityInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adType: AdTypeCreateNestedOneWithoutAdInput
    user?: UserCreateNestedOneWithoutAdInput
    category: CategoryCreateNestedOneWithoutAdInput
    state?: StateCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateOrConnectWithoutCityInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput>
  }

  export type AdCreateManyCityInputEnvelope = {
    data: AdCreateManyCityInput | AdCreateManyCityInput[]
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutCitiesInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUpdateManyWithoutStateNestedInput
    Location?: LocationUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUpdateManyWithoutStateNestedInput
    Ad?: AdUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUncheckedUpdateManyWithoutStateNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutStateNestedInput
    Ad?: AdUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CountyUpsertWithoutCitiesInput = {
    update: XOR<CountyUpdateWithoutCitiesInput, CountyUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountyCreateWithoutCitiesInput, CountyUncheckedCreateWithoutCitiesInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutCitiesInput, CountyUncheckedUpdateWithoutCitiesInput>
  }

  export type CountyUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutCountiesNestedInput
    Location?: LocationUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    current_password?: StringNullableFilter<"User"> | string | null
    birthdate?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    state?: EnumStatusFilter<"User"> | $Enums.Status
    photo?: StringNullableFilter<"User"> | string | null
    cityId?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutCityInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutCityInput, LocationUncheckedUpdateWithoutCityInput>
    create: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutCityInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutCityInput, LocationUncheckedUpdateWithoutCityInput>
  }

  export type LocationUpdateManyWithWhereWithoutCityInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutCityInput>
  }

  export type TourUpsertWithWhereUniqueWithoutCityInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutCityInput, TourUncheckedUpdateWithoutCityInput>
    create: XOR<TourCreateWithoutCityInput, TourUncheckedCreateWithoutCityInput>
  }

  export type TourUpdateWithWhereUniqueWithoutCityInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutCityInput, TourUncheckedUpdateWithoutCityInput>
  }

  export type TourUpdateManyWithWhereWithoutCityInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutCityInput>
  }

  export type AdRatesUpsertWithWhereUniqueWithoutCityInput = {
    where: AdRatesWhereUniqueInput
    update: XOR<AdRatesUpdateWithoutCityInput, AdRatesUncheckedUpdateWithoutCityInput>
    create: XOR<AdRatesCreateWithoutCityInput, AdRatesUncheckedCreateWithoutCityInput>
  }

  export type AdRatesUpdateWithWhereUniqueWithoutCityInput = {
    where: AdRatesWhereUniqueInput
    data: XOR<AdRatesUpdateWithoutCityInput, AdRatesUncheckedUpdateWithoutCityInput>
  }

  export type AdRatesUpdateManyWithWhereWithoutCityInput = {
    where: AdRatesScalarWhereInput
    data: XOR<AdRatesUpdateManyMutationInput, AdRatesUncheckedUpdateManyWithoutCityInput>
  }

  export type AdUpsertWithWhereUniqueWithoutCityInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutCityInput, AdUncheckedUpdateWithoutCityInput>
    create: XOR<AdCreateWithoutCityInput, AdUncheckedCreateWithoutCityInput>
  }

  export type AdUpdateWithWhereUniqueWithoutCityInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutCityInput, AdUncheckedUpdateWithoutCityInput>
  }

  export type AdUpdateManyWithWhereWithoutCityInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutCityInput>
  }

  export type CityCreateWithoutLocationInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutLocationInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutLocationInput, CityUncheckedCreateWithoutLocationInput>
  }

  export type BreweryCreateWithoutLocationInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutLocationInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput>
  }

  export type BreweryCreateManyLocationInputEnvelope = {
    data: BreweryCreateManyLocationInput | BreweryCreateManyLocationInput[]
  }

  export type StateCreateWithoutLocationInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    AdRates?: AdRatesCreateNestedManyWithoutStateInput
    Ad?: AdCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutStateInput
    Ad?: AdUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutLocationInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutLocationInput, StateUncheckedCreateWithoutLocationInput>
  }

  export type CountyCreateWithoutLocationInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutCountiesInput
    cities?: CityCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    county_fips: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutLocationInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutLocationInput, CountyUncheckedCreateWithoutLocationInput>
  }

  export type CityUpsertWithoutLocationInput = {
    update: XOR<CityUpdateWithoutLocationInput, CityUncheckedUpdateWithoutLocationInput>
    create: XOR<CityCreateWithoutLocationInput, CityUncheckedCreateWithoutLocationInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutLocationInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutLocationInput, CityUncheckedUpdateWithoutLocationInput>
  }

  export type CityUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type BreweryUpsertWithWhereUniqueWithoutLocationInput = {
    where: BreweryWhereUniqueInput
    update: XOR<BreweryUpdateWithoutLocationInput, BreweryUncheckedUpdateWithoutLocationInput>
    create: XOR<BreweryCreateWithoutLocationInput, BreweryUncheckedCreateWithoutLocationInput>
  }

  export type BreweryUpdateWithWhereUniqueWithoutLocationInput = {
    where: BreweryWhereUniqueInput
    data: XOR<BreweryUpdateWithoutLocationInput, BreweryUncheckedUpdateWithoutLocationInput>
  }

  export type BreweryUpdateManyWithWhereWithoutLocationInput = {
    where: BreweryScalarWhereInput
    data: XOR<BreweryUpdateManyMutationInput, BreweryUncheckedUpdateManyWithoutLocationInput>
  }

  export type StateUpsertWithoutLocationInput = {
    update: XOR<StateUpdateWithoutLocationInput, StateUncheckedUpdateWithoutLocationInput>
    create: XOR<StateCreateWithoutLocationInput, StateUncheckedCreateWithoutLocationInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutLocationInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutLocationInput, StateUncheckedUpdateWithoutLocationInput>
  }

  export type StateUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUpdateManyWithoutStateNestedInput
    Ad?: AdUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutStateNestedInput
    Ad?: AdUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CountyUpsertWithoutLocationInput = {
    update: XOR<CountyUpdateWithoutLocationInput, CountyUncheckedUpdateWithoutLocationInput>
    create: XOR<CountyCreateWithoutLocationInput, CountyUncheckedCreateWithoutLocationInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutLocationInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutLocationInput, CountyUncheckedUpdateWithoutLocationInput>
  }

  export type CountyUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutCountiesNestedInput
    cities?: CityUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type LocationCreateWithoutBreweryInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutLocationInput
    State?: StateCreateNestedOneWithoutLocationInput
    County?: CountyCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutBreweryInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    countyId?: string | null
  }

  export type LocationCreateOrConnectWithoutBreweryInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutBreweryInput, LocationUncheckedCreateWithoutBreweryInput>
  }

  export type UserCreateWithoutOwnedBreweriesInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutOwnedBreweriesInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutOwnedBreweriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedBreweriesInput, UserUncheckedCreateWithoutOwnedBreweriesInput>
  }

  export type UserCreateWithoutManagedBreweriesInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutManagedBreweriesInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutManagedBreweriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedBreweriesInput, UserUncheckedCreateWithoutManagedBreweriesInput>
  }

  export type BreweryFeatureCreateWithoutBreweryInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFeatureUncheckedCreateWithoutBreweryInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFeatureCreateOrConnectWithoutBreweryInput = {
    where: BreweryFeatureWhereUniqueInput
    create: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryFeatureCreateManyBreweryInputEnvelope = {
    data: BreweryFeatureCreateManyBreweryInput | BreweryFeatureCreateManyBreweryInput[]
  }

  export type BreweryBeerCreateWithoutBreweryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    beer: BeerCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryBeerUncheckedCreateWithoutBreweryInput = {
    id?: string
    beerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerCreateOrConnectWithoutBreweryInput = {
    where: BreweryBeerWhereUniqueInput
    create: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryBeerCreateManyBreweryInputEnvelope = {
    data: BreweryBeerCreateManyBreweryInput | BreweryBeerCreateManyBreweryInput[]
  }

  export type BreweryFoodCreateWithoutBreweryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    food: FoodCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryFoodUncheckedCreateWithoutBreweryInput = {
    id?: string
    foodId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodCreateOrConnectWithoutBreweryInput = {
    where: BreweryFoodWhereUniqueInput
    create: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryFoodCreateManyBreweryInputEnvelope = {
    data: BreweryFoodCreateManyBreweryInput | BreweryFoodCreateManyBreweryInput[]
  }

  export type BreweryServiceCreateWithoutBreweryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryServiceUncheckedCreateWithoutBreweryInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceCreateOrConnectWithoutBreweryInput = {
    where: BreweryServiceWhereUniqueInput
    create: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryServiceCreateManyBreweryInputEnvelope = {
    data: BreweryServiceCreateManyBreweryInput | BreweryServiceCreateManyBreweryInput[]
  }

  export type BreweryMusicCreateWithoutBreweryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    music: MusicCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryMusicUncheckedCreateWithoutBreweryInput = {
    id?: string
    musicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicCreateOrConnectWithoutBreweryInput = {
    where: BreweryMusicWhereUniqueInput
    create: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryMusicCreateManyBreweryInputEnvelope = {
    data: BreweryMusicCreateManyBreweryInput | BreweryMusicCreateManyBreweryInput[]
  }

  export type OperatingHoursCreateWithoutBreweryInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHoursUncheckedCreateWithoutBreweryInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHoursCreateOrConnectWithoutBreweryInput = {
    where: OperatingHoursWhereUniqueInput
    create: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput>
  }

  export type OperatingHoursCreateManyBreweryInputEnvelope = {
    data: OperatingHoursCreateManyBreweryInput | OperatingHoursCreateManyBreweryInput[]
  }

  export type BreweryEventCreateWithoutBreweryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutBreweriesInput
  }

  export type BreweryEventUncheckedCreateWithoutBreweryInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventCreateOrConnectWithoutBreweryInput = {
    where: BreweryEventWhereUniqueInput
    create: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryEventCreateManyBreweryInputEnvelope = {
    data: BreweryEventCreateManyBreweryInput | BreweryEventCreateManyBreweryInput[]
  }

  export type TourBreweryCreateWithoutBreweryInput = {
    id?: string
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tour: TourCreateNestedOneWithoutBreweriesInput
  }

  export type TourBreweryUncheckedCreateWithoutBreweryInput = {
    id?: string
    tourId: string
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryCreateOrConnectWithoutBreweryInput = {
    where: TourBreweryWhereUniqueInput
    create: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput>
  }

  export type TourBreweryCreateManyBreweryInputEnvelope = {
    data: TourBreweryCreateManyBreweryInput | TourBreweryCreateManyBreweryInput[]
  }

  export type MediaCreateWithoutBreweryInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutBreweryInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedById?: string | null
  }

  export type MediaCreateOrConnectWithoutBreweryInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput>
  }

  export type MediaCreateManyBreweryInputEnvelope = {
    data: MediaCreateManyBreweryInput | MediaCreateManyBreweryInput[]
  }

  export type LocationUpsertWithoutBreweryInput = {
    update: XOR<LocationUpdateWithoutBreweryInput, LocationUncheckedUpdateWithoutBreweryInput>
    create: XOR<LocationCreateWithoutBreweryInput, LocationUncheckedCreateWithoutBreweryInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutBreweryInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutBreweryInput, LocationUncheckedUpdateWithoutBreweryInput>
  }

  export type LocationUpdateWithoutBreweryInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutLocationNestedInput
    State?: StateUpdateOneWithoutLocationNestedInput
    County?: CountyUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutBreweryInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutOwnedBreweriesInput = {
    update: XOR<UserUpdateWithoutOwnedBreweriesInput, UserUncheckedUpdateWithoutOwnedBreweriesInput>
    create: XOR<UserCreateWithoutOwnedBreweriesInput, UserUncheckedCreateWithoutOwnedBreweriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedBreweriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedBreweriesInput, UserUncheckedUpdateWithoutOwnedBreweriesInput>
  }

  export type UserUpdateWithoutOwnedBreweriesInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedBreweriesInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutManagedBreweriesInput = {
    update: XOR<UserUpdateWithoutManagedBreweriesInput, UserUncheckedUpdateWithoutManagedBreweriesInput>
    create: XOR<UserCreateWithoutManagedBreweriesInput, UserUncheckedCreateWithoutManagedBreweriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedBreweriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedBreweriesInput, UserUncheckedUpdateWithoutManagedBreweriesInput>
  }

  export type UserUpdateWithoutManagedBreweriesInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedBreweriesInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type BreweryFeatureUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryFeatureWhereUniqueInput
    update: XOR<BreweryFeatureUpdateWithoutBreweryInput, BreweryFeatureUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryFeatureCreateWithoutBreweryInput, BreweryFeatureUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryFeatureUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryFeatureWhereUniqueInput
    data: XOR<BreweryFeatureUpdateWithoutBreweryInput, BreweryFeatureUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryFeatureUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryFeatureScalarWhereInput
    data: XOR<BreweryFeatureUpdateManyMutationInput, BreweryFeatureUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryFeatureScalarWhereInput = {
    AND?: BreweryFeatureScalarWhereInput | BreweryFeatureScalarWhereInput[]
    OR?: BreweryFeatureScalarWhereInput[]
    NOT?: BreweryFeatureScalarWhereInput | BreweryFeatureScalarWhereInput[]
    id?: StringFilter<"BreweryFeature"> | string
    logo?: StringNullableFilter<"BreweryFeature"> | string | null
    image?: StringNullableFilter<"BreweryFeature"> | string | null
    description?: StringNullableFilter<"BreweryFeature"> | string | null
    phone?: StringNullableFilter<"BreweryFeature"> | string | null
    facebook?: StringNullableFilter<"BreweryFeature"> | string | null
    x?: StringNullableFilter<"BreweryFeature"> | string | null
    instagram?: StringNullableFilter<"BreweryFeature"> | string | null
    highlighted?: BoolNullableFilter<"BreweryFeature"> | boolean | null
    capacity?: StringNullableFilter<"BreweryFeature"> | string | null
    booklink?: StringNullableFilter<"BreweryFeature"> | string | null
    pricerank?: StringNullableFilter<"BreweryFeature"> | string | null
    state?: IntNullableFilter<"BreweryFeature"> | number | null
    breweryId?: StringFilter<"BreweryFeature"> | string
    createdAt?: DateTimeFilter<"BreweryFeature"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFeature"> | Date | string
  }

  export type BreweryBeerUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryBeerWhereUniqueInput
    update: XOR<BreweryBeerUpdateWithoutBreweryInput, BreweryBeerUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryBeerCreateWithoutBreweryInput, BreweryBeerUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryBeerUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryBeerWhereUniqueInput
    data: XOR<BreweryBeerUpdateWithoutBreweryInput, BreweryBeerUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryBeerUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryBeerScalarWhereInput
    data: XOR<BreweryBeerUpdateManyMutationInput, BreweryBeerUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryBeerScalarWhereInput = {
    AND?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
    OR?: BreweryBeerScalarWhereInput[]
    NOT?: BreweryBeerScalarWhereInput | BreweryBeerScalarWhereInput[]
    id?: StringFilter<"BreweryBeer"> | string
    breweryId?: StringNullableFilter<"BreweryBeer"> | string | null
    beerId?: StringFilter<"BreweryBeer"> | string
    createdAt?: DateTimeFilter<"BreweryBeer"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryBeer"> | Date | string
  }

  export type BreweryFoodUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryFoodWhereUniqueInput
    update: XOR<BreweryFoodUpdateWithoutBreweryInput, BreweryFoodUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryFoodCreateWithoutBreweryInput, BreweryFoodUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryFoodUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryFoodWhereUniqueInput
    data: XOR<BreweryFoodUpdateWithoutBreweryInput, BreweryFoodUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryFoodUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryFoodScalarWhereInput
    data: XOR<BreweryFoodUpdateManyMutationInput, BreweryFoodUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryFoodScalarWhereInput = {
    AND?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
    OR?: BreweryFoodScalarWhereInput[]
    NOT?: BreweryFoodScalarWhereInput | BreweryFoodScalarWhereInput[]
    id?: StringFilter<"BreweryFood"> | string
    breweryId?: StringFilter<"BreweryFood"> | string
    foodId?: StringFilter<"BreweryFood"> | string
    createdAt?: DateTimeFilter<"BreweryFood"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryFood"> | Date | string
  }

  export type BreweryServiceUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryServiceWhereUniqueInput
    update: XOR<BreweryServiceUpdateWithoutBreweryInput, BreweryServiceUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryServiceCreateWithoutBreweryInput, BreweryServiceUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryServiceUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryServiceWhereUniqueInput
    data: XOR<BreweryServiceUpdateWithoutBreweryInput, BreweryServiceUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryServiceUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryServiceScalarWhereInput
    data: XOR<BreweryServiceUpdateManyMutationInput, BreweryServiceUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryServiceScalarWhereInput = {
    AND?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
    OR?: BreweryServiceScalarWhereInput[]
    NOT?: BreweryServiceScalarWhereInput | BreweryServiceScalarWhereInput[]
    id?: StringFilter<"BreweryService"> | string
    breweryId?: StringFilter<"BreweryService"> | string
    serviceId?: StringFilter<"BreweryService"> | string
    createdAt?: DateTimeFilter<"BreweryService"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryService"> | Date | string
  }

  export type BreweryMusicUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryMusicWhereUniqueInput
    update: XOR<BreweryMusicUpdateWithoutBreweryInput, BreweryMusicUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryMusicCreateWithoutBreweryInput, BreweryMusicUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryMusicUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryMusicWhereUniqueInput
    data: XOR<BreweryMusicUpdateWithoutBreweryInput, BreweryMusicUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryMusicUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryMusicScalarWhereInput
    data: XOR<BreweryMusicUpdateManyMutationInput, BreweryMusicUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryMusicScalarWhereInput = {
    AND?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
    OR?: BreweryMusicScalarWhereInput[]
    NOT?: BreweryMusicScalarWhereInput | BreweryMusicScalarWhereInput[]
    id?: StringFilter<"BreweryMusic"> | string
    breweryId?: StringFilter<"BreweryMusic"> | string
    musicId?: StringFilter<"BreweryMusic"> | string
    createdAt?: DateTimeFilter<"BreweryMusic"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryMusic"> | Date | string
  }

  export type OperatingHoursUpsertWithWhereUniqueWithoutBreweryInput = {
    where: OperatingHoursWhereUniqueInput
    update: XOR<OperatingHoursUpdateWithoutBreweryInput, OperatingHoursUncheckedUpdateWithoutBreweryInput>
    create: XOR<OperatingHoursCreateWithoutBreweryInput, OperatingHoursUncheckedCreateWithoutBreweryInput>
  }

  export type OperatingHoursUpdateWithWhereUniqueWithoutBreweryInput = {
    where: OperatingHoursWhereUniqueInput
    data: XOR<OperatingHoursUpdateWithoutBreweryInput, OperatingHoursUncheckedUpdateWithoutBreweryInput>
  }

  export type OperatingHoursUpdateManyWithWhereWithoutBreweryInput = {
    where: OperatingHoursScalarWhereInput
    data: XOR<OperatingHoursUpdateManyMutationInput, OperatingHoursUncheckedUpdateManyWithoutBreweryInput>
  }

  export type OperatingHoursScalarWhereInput = {
    AND?: OperatingHoursScalarWhereInput | OperatingHoursScalarWhereInput[]
    OR?: OperatingHoursScalarWhereInput[]
    NOT?: OperatingHoursScalarWhereInput | OperatingHoursScalarWhereInput[]
    id?: StringFilter<"OperatingHours"> | string
    mondayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    mondayClose?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    tuesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    wednesdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    thursdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    fridayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    fridayClose?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    saturdayClose?: StringNullableFilter<"OperatingHours"> | string | null
    sundayOpen?: StringNullableFilter<"OperatingHours"> | string | null
    sundayClose?: StringNullableFilter<"OperatingHours"> | string | null
    breweryId?: StringFilter<"OperatingHours"> | string
    createdAt?: DateTimeFilter<"OperatingHours"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHours"> | Date | string
  }

  export type BreweryEventUpsertWithWhereUniqueWithoutBreweryInput = {
    where: BreweryEventWhereUniqueInput
    update: XOR<BreweryEventUpdateWithoutBreweryInput, BreweryEventUncheckedUpdateWithoutBreweryInput>
    create: XOR<BreweryEventCreateWithoutBreweryInput, BreweryEventUncheckedCreateWithoutBreweryInput>
  }

  export type BreweryEventUpdateWithWhereUniqueWithoutBreweryInput = {
    where: BreweryEventWhereUniqueInput
    data: XOR<BreweryEventUpdateWithoutBreweryInput, BreweryEventUncheckedUpdateWithoutBreweryInput>
  }

  export type BreweryEventUpdateManyWithWhereWithoutBreweryInput = {
    where: BreweryEventScalarWhereInput
    data: XOR<BreweryEventUpdateManyMutationInput, BreweryEventUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryEventScalarWhereInput = {
    AND?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
    OR?: BreweryEventScalarWhereInput[]
    NOT?: BreweryEventScalarWhereInput | BreweryEventScalarWhereInput[]
    id?: StringFilter<"BreweryEvent"> | string
    breweryId?: StringFilter<"BreweryEvent"> | string
    eventId?: StringFilter<"BreweryEvent"> | string
    createdAt?: DateTimeFilter<"BreweryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"BreweryEvent"> | Date | string
  }

  export type TourBreweryUpsertWithWhereUniqueWithoutBreweryInput = {
    where: TourBreweryWhereUniqueInput
    update: XOR<TourBreweryUpdateWithoutBreweryInput, TourBreweryUncheckedUpdateWithoutBreweryInput>
    create: XOR<TourBreweryCreateWithoutBreweryInput, TourBreweryUncheckedCreateWithoutBreweryInput>
  }

  export type TourBreweryUpdateWithWhereUniqueWithoutBreweryInput = {
    where: TourBreweryWhereUniqueInput
    data: XOR<TourBreweryUpdateWithoutBreweryInput, TourBreweryUncheckedUpdateWithoutBreweryInput>
  }

  export type TourBreweryUpdateManyWithWhereWithoutBreweryInput = {
    where: TourBreweryScalarWhereInput
    data: XOR<TourBreweryUpdateManyMutationInput, TourBreweryUncheckedUpdateManyWithoutBreweryInput>
  }

  export type TourBreweryScalarWhereInput = {
    AND?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
    OR?: TourBreweryScalarWhereInput[]
    NOT?: TourBreweryScalarWhereInput | TourBreweryScalarWhereInput[]
    id?: StringFilter<"TourBrewery"> | string
    tourId?: StringFilter<"TourBrewery"> | string
    breweryId?: StringNullableFilter<"TourBrewery"> | string | null
    distance?: FloatFilter<"TourBrewery"> | number
    createdAt?: DateTimeFilter<"TourBrewery"> | Date | string
    updatedAt?: DateTimeFilter<"TourBrewery"> | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutBreweryInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutBreweryInput, MediaUncheckedUpdateWithoutBreweryInput>
    create: XOR<MediaCreateWithoutBreweryInput, MediaUncheckedCreateWithoutBreweryInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutBreweryInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutBreweryInput, MediaUncheckedUpdateWithoutBreweryInput>
  }

  export type MediaUpdateManyWithWhereWithoutBreweryInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutBreweryInput>
  }

  export type BreweryBeerCreateWithoutBeerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery?: BreweryCreateNestedOneWithoutBeersInput
  }

  export type BreweryBeerUncheckedCreateWithoutBeerInput = {
    id?: string
    breweryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerCreateOrConnectWithoutBeerInput = {
    where: BreweryBeerWhereUniqueInput
    create: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput>
  }

  export type BreweryBeerCreateManyBeerInputEnvelope = {
    data: BreweryBeerCreateManyBeerInput | BreweryBeerCreateManyBeerInput[]
  }

  export type BreweryBeerUpsertWithWhereUniqueWithoutBeerInput = {
    where: BreweryBeerWhereUniqueInput
    update: XOR<BreweryBeerUpdateWithoutBeerInput, BreweryBeerUncheckedUpdateWithoutBeerInput>
    create: XOR<BreweryBeerCreateWithoutBeerInput, BreweryBeerUncheckedCreateWithoutBeerInput>
  }

  export type BreweryBeerUpdateWithWhereUniqueWithoutBeerInput = {
    where: BreweryBeerWhereUniqueInput
    data: XOR<BreweryBeerUpdateWithoutBeerInput, BreweryBeerUncheckedUpdateWithoutBeerInput>
  }

  export type BreweryBeerUpdateManyWithWhereWithoutBeerInput = {
    where: BreweryBeerScalarWhereInput
    data: XOR<BreweryBeerUpdateManyMutationInput, BreweryBeerUncheckedUpdateManyWithoutBeerInput>
  }

  export type BreweryCreateWithoutBeersInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutBeersInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutBeersInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutBeersInput, BreweryUncheckedCreateWithoutBeersInput>
  }

  export type BeerCreateWithoutBreweriesInput = {
    id?: string
    type?: string | null
    brand?: string | null
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeerUncheckedCreateWithoutBreweriesInput = {
    id?: string
    type?: string | null
    brand?: string | null
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BeerCreateOrConnectWithoutBreweriesInput = {
    where: BeerWhereUniqueInput
    create: XOR<BeerCreateWithoutBreweriesInput, BeerUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryUpsertWithoutBeersInput = {
    update: XOR<BreweryUpdateWithoutBeersInput, BreweryUncheckedUpdateWithoutBeersInput>
    create: XOR<BreweryCreateWithoutBeersInput, BreweryUncheckedCreateWithoutBeersInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutBeersInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutBeersInput, BreweryUncheckedUpdateWithoutBeersInput>
  }

  export type BreweryUpdateWithoutBeersInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutBeersInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BeerUpsertWithoutBreweriesInput = {
    update: XOR<BeerUpdateWithoutBreweriesInput, BeerUncheckedUpdateWithoutBreweriesInput>
    create: XOR<BeerCreateWithoutBreweriesInput, BeerUncheckedCreateWithoutBreweriesInput>
    where?: BeerWhereInput
  }

  export type BeerUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: BeerWhereInput
    data: XOR<BeerUpdateWithoutBreweriesInput, BeerUncheckedUpdateWithoutBreweriesInput>
  }

  export type BeerUpdateWithoutBreweriesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeerUncheckedUpdateWithoutBreweriesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutFoodsInput
  }

  export type BreweryFoodUncheckedCreateWithoutFoodInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodCreateOrConnectWithoutFoodInput = {
    where: BreweryFoodWhereUniqueInput
    create: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput>
  }

  export type BreweryFoodCreateManyFoodInputEnvelope = {
    data: BreweryFoodCreateManyFoodInput | BreweryFoodCreateManyFoodInput[]
  }

  export type BreweryFoodUpsertWithWhereUniqueWithoutFoodInput = {
    where: BreweryFoodWhereUniqueInput
    update: XOR<BreweryFoodUpdateWithoutFoodInput, BreweryFoodUncheckedUpdateWithoutFoodInput>
    create: XOR<BreweryFoodCreateWithoutFoodInput, BreweryFoodUncheckedCreateWithoutFoodInput>
  }

  export type BreweryFoodUpdateWithWhereUniqueWithoutFoodInput = {
    where: BreweryFoodWhereUniqueInput
    data: XOR<BreweryFoodUpdateWithoutFoodInput, BreweryFoodUncheckedUpdateWithoutFoodInput>
  }

  export type BreweryFoodUpdateManyWithWhereWithoutFoodInput = {
    where: BreweryFoodScalarWhereInput
    data: XOR<BreweryFoodUpdateManyMutationInput, BreweryFoodUncheckedUpdateManyWithoutFoodInput>
  }

  export type BreweryCreateWithoutFoodsInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutFoodsInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutFoodsInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutFoodsInput, BreweryUncheckedCreateWithoutFoodsInput>
  }

  export type FoodCreateWithoutBreweriesInput = {
    id?: string
    name: string
    type?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodUncheckedCreateWithoutBreweriesInput = {
    id?: string
    name: string
    type?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCreateOrConnectWithoutBreweriesInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutBreweriesInput, FoodUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryUpsertWithoutFoodsInput = {
    update: XOR<BreweryUpdateWithoutFoodsInput, BreweryUncheckedUpdateWithoutFoodsInput>
    create: XOR<BreweryCreateWithoutFoodsInput, BreweryUncheckedCreateWithoutFoodsInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutFoodsInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutFoodsInput, BreweryUncheckedUpdateWithoutFoodsInput>
  }

  export type BreweryUpdateWithoutFoodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutFoodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type FoodUpsertWithoutBreweriesInput = {
    update: XOR<FoodUpdateWithoutBreweriesInput, FoodUncheckedUpdateWithoutBreweriesInput>
    create: XOR<FoodCreateWithoutBreweriesInput, FoodUncheckedCreateWithoutBreweriesInput>
    where?: FoodWhereInput
  }

  export type FoodUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: FoodWhereInput
    data: XOR<FoodUpdateWithoutBreweriesInput, FoodUncheckedUpdateWithoutBreweriesInput>
  }

  export type FoodUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodUncheckedUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutServicesInput
  }

  export type BreweryServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceCreateOrConnectWithoutServiceInput = {
    where: BreweryServiceWhereUniqueInput
    create: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput>
  }

  export type BreweryServiceCreateManyServiceInputEnvelope = {
    data: BreweryServiceCreateManyServiceInput | BreweryServiceCreateManyServiceInput[]
  }

  export type BreweryServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BreweryServiceWhereUniqueInput
    update: XOR<BreweryServiceUpdateWithoutServiceInput, BreweryServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BreweryServiceCreateWithoutServiceInput, BreweryServiceUncheckedCreateWithoutServiceInput>
  }

  export type BreweryServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BreweryServiceWhereUniqueInput
    data: XOR<BreweryServiceUpdateWithoutServiceInput, BreweryServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BreweryServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BreweryServiceScalarWhereInput
    data: XOR<BreweryServiceUpdateManyMutationInput, BreweryServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type BreweryCreateWithoutServicesInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutServicesInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutServicesInput, BreweryUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutBreweriesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBreweriesInput, ServiceUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryUpsertWithoutServicesInput = {
    update: XOR<BreweryUpdateWithoutServicesInput, BreweryUncheckedUpdateWithoutServicesInput>
    create: XOR<BreweryCreateWithoutServicesInput, BreweryUncheckedCreateWithoutServicesInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutServicesInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutServicesInput, BreweryUncheckedUpdateWithoutServicesInput>
  }

  export type BreweryUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type ServiceUpsertWithoutBreweriesInput = {
    update: XOR<ServiceUpdateWithoutBreweriesInput, ServiceUncheckedUpdateWithoutBreweriesInput>
    create: XOR<ServiceCreateWithoutBreweriesInput, ServiceUncheckedCreateWithoutBreweriesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBreweriesInput, ServiceUncheckedUpdateWithoutBreweriesInput>
  }

  export type ServiceUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicCreateWithoutMusicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutMusicInput
  }

  export type BreweryMusicUncheckedCreateWithoutMusicInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicCreateOrConnectWithoutMusicInput = {
    where: BreweryMusicWhereUniqueInput
    create: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput>
  }

  export type BreweryMusicCreateManyMusicInputEnvelope = {
    data: BreweryMusicCreateManyMusicInput | BreweryMusicCreateManyMusicInput[]
  }

  export type BreweryMusicUpsertWithWhereUniqueWithoutMusicInput = {
    where: BreweryMusicWhereUniqueInput
    update: XOR<BreweryMusicUpdateWithoutMusicInput, BreweryMusicUncheckedUpdateWithoutMusicInput>
    create: XOR<BreweryMusicCreateWithoutMusicInput, BreweryMusicUncheckedCreateWithoutMusicInput>
  }

  export type BreweryMusicUpdateWithWhereUniqueWithoutMusicInput = {
    where: BreweryMusicWhereUniqueInput
    data: XOR<BreweryMusicUpdateWithoutMusicInput, BreweryMusicUncheckedUpdateWithoutMusicInput>
  }

  export type BreweryMusicUpdateManyWithWhereWithoutMusicInput = {
    where: BreweryMusicScalarWhereInput
    data: XOR<BreweryMusicUpdateManyMutationInput, BreweryMusicUncheckedUpdateManyWithoutMusicInput>
  }

  export type BreweryCreateWithoutMusicInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutMusicInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutMusicInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutMusicInput, BreweryUncheckedCreateWithoutMusicInput>
  }

  export type MusicCreateWithoutBreweriesInput = {
    id?: string
    genre: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MusicUncheckedCreateWithoutBreweriesInput = {
    id?: string
    genre: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MusicCreateOrConnectWithoutBreweriesInput = {
    where: MusicWhereUniqueInput
    create: XOR<MusicCreateWithoutBreweriesInput, MusicUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryUpsertWithoutMusicInput = {
    update: XOR<BreweryUpdateWithoutMusicInput, BreweryUncheckedUpdateWithoutMusicInput>
    create: XOR<BreweryCreateWithoutMusicInput, BreweryUncheckedCreateWithoutMusicInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutMusicInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutMusicInput, BreweryUncheckedUpdateWithoutMusicInput>
  }

  export type BreweryUpdateWithoutMusicInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutMusicInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type MusicUpsertWithoutBreweriesInput = {
    update: XOR<MusicUpdateWithoutBreweriesInput, MusicUncheckedUpdateWithoutBreweriesInput>
    create: XOR<MusicCreateWithoutBreweriesInput, MusicUncheckedCreateWithoutBreweriesInput>
    where?: MusicWhereInput
  }

  export type MusicUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: MusicWhereInput
    data: XOR<MusicUpdateWithoutBreweriesInput, MusicUncheckedUpdateWithoutBreweriesInput>
  }

  export type MusicUpdateWithoutBreweriesInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusicUncheckedUpdateWithoutBreweriesInput = {
    genre?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventCreateWithoutEventInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery: BreweryCreateNestedOneWithoutBreweryEventInput
  }

  export type BreweryEventUncheckedCreateWithoutEventInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventCreateOrConnectWithoutEventInput = {
    where: BreweryEventWhereUniqueInput
    create: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput>
  }

  export type BreweryEventCreateManyEventInputEnvelope = {
    data: BreweryEventCreateManyEventInput | BreweryEventCreateManyEventInput[]
  }

  export type BreweryEventUpsertWithWhereUniqueWithoutEventInput = {
    where: BreweryEventWhereUniqueInput
    update: XOR<BreweryEventUpdateWithoutEventInput, BreweryEventUncheckedUpdateWithoutEventInput>
    create: XOR<BreweryEventCreateWithoutEventInput, BreweryEventUncheckedCreateWithoutEventInput>
  }

  export type BreweryEventUpdateWithWhereUniqueWithoutEventInput = {
    where: BreweryEventWhereUniqueInput
    data: XOR<BreweryEventUpdateWithoutEventInput, BreweryEventUncheckedUpdateWithoutEventInput>
  }

  export type BreweryEventUpdateManyWithWhereWithoutEventInput = {
    where: BreweryEventScalarWhereInput
    data: XOR<BreweryEventUpdateManyMutationInput, BreweryEventUncheckedUpdateManyWithoutEventInput>
  }

  export type BreweryCreateWithoutBreweryEventInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutBreweryEventInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutBreweryEventInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutBreweryEventInput, BreweryUncheckedCreateWithoutBreweryEventInput>
  }

  export type EventCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    date: Date | string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutBreweriesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutBreweriesInput, EventUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryUpsertWithoutBreweryEventInput = {
    update: XOR<BreweryUpdateWithoutBreweryEventInput, BreweryUncheckedUpdateWithoutBreweryEventInput>
    create: XOR<BreweryCreateWithoutBreweryEventInput, BreweryUncheckedCreateWithoutBreweryEventInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutBreweryEventInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutBreweryEventInput, BreweryUncheckedUpdateWithoutBreweryEventInput>
  }

  export type BreweryUpdateWithoutBreweryEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutBreweryEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type EventUpsertWithoutBreweriesInput = {
    update: XOR<EventUpdateWithoutBreweriesInput, EventUncheckedUpdateWithoutBreweriesInput>
    create: XOR<EventCreateWithoutBreweriesInput, EventUncheckedCreateWithoutBreweriesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutBreweriesInput, EventUncheckedUpdateWithoutBreweriesInput>
  }

  export type EventUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryCreateWithoutFeaturesInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutFeaturesInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutFeaturesInput, BreweryUncheckedCreateWithoutFeaturesInput>
  }

  export type BreweryUpsertWithoutFeaturesInput = {
    update: XOR<BreweryUpdateWithoutFeaturesInput, BreweryUncheckedUpdateWithoutFeaturesInput>
    create: XOR<BreweryCreateWithoutFeaturesInput, BreweryUncheckedCreateWithoutFeaturesInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutFeaturesInput, BreweryUncheckedUpdateWithoutFeaturesInput>
  }

  export type BreweryUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryCreateWithoutOperatingHoursInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutOperatingHoursInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutOperatingHoursInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutOperatingHoursInput, BreweryUncheckedCreateWithoutOperatingHoursInput>
  }

  export type BreweryUpsertWithoutOperatingHoursInput = {
    update: XOR<BreweryUpdateWithoutOperatingHoursInput, BreweryUncheckedUpdateWithoutOperatingHoursInput>
    create: XOR<BreweryCreateWithoutOperatingHoursInput, BreweryUncheckedCreateWithoutOperatingHoursInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutOperatingHoursInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutOperatingHoursInput, BreweryUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type BreweryUpdateWithoutOperatingHoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutOperatingHoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type UserCreateWithoutTourInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutTourInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutTourInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTourInput, UserUncheckedCreateWithoutTourInput>
  }

  export type TourBreweryCreateWithoutTourInput = {
    id?: string
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brewery?: BreweryCreateNestedOneWithoutToursInput
  }

  export type TourBreweryUncheckedCreateWithoutTourInput = {
    id?: string
    breweryId?: string | null
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryCreateOrConnectWithoutTourInput = {
    where: TourBreweryWhereUniqueInput
    create: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput>
  }

  export type TourBreweryCreateManyTourInputEnvelope = {
    data: TourBreweryCreateManyTourInput | TourBreweryCreateManyTourInput[]
  }

  export type CityCreateWithoutTourInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTourInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTourInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTourInput, CityUncheckedCreateWithoutTourInput>
  }

  export type UserUpsertWithoutTourInput = {
    update: XOR<UserUpdateWithoutTourInput, UserUncheckedUpdateWithoutTourInput>
    create: XOR<UserCreateWithoutTourInput, UserUncheckedCreateWithoutTourInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTourInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTourInput, UserUncheckedUpdateWithoutTourInput>
  }

  export type UserUpdateWithoutTourInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTourInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type TourBreweryUpsertWithWhereUniqueWithoutTourInput = {
    where: TourBreweryWhereUniqueInput
    update: XOR<TourBreweryUpdateWithoutTourInput, TourBreweryUncheckedUpdateWithoutTourInput>
    create: XOR<TourBreweryCreateWithoutTourInput, TourBreweryUncheckedCreateWithoutTourInput>
  }

  export type TourBreweryUpdateWithWhereUniqueWithoutTourInput = {
    where: TourBreweryWhereUniqueInput
    data: XOR<TourBreweryUpdateWithoutTourInput, TourBreweryUncheckedUpdateWithoutTourInput>
  }

  export type TourBreweryUpdateManyWithWhereWithoutTourInput = {
    where: TourBreweryScalarWhereInput
    data: XOR<TourBreweryUpdateManyMutationInput, TourBreweryUncheckedUpdateManyWithoutTourInput>
  }

  export type CityUpsertWithoutTourInput = {
    update: XOR<CityUpdateWithoutTourInput, CityUncheckedUpdateWithoutTourInput>
    create: XOR<CityCreateWithoutTourInput, CityUncheckedCreateWithoutTourInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutTourInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutTourInput, CityUncheckedUpdateWithoutTourInput>
  }

  export type CityUpdateWithoutTourInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTourInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type TourCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTourInput
    city: CityCreateNestedOneWithoutTourInput
  }

  export type TourUncheckedCreateWithoutBreweriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    userId: string
    cityId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourCreateOrConnectWithoutBreweriesInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutBreweriesInput, TourUncheckedCreateWithoutBreweriesInput>
  }

  export type BreweryCreateWithoutToursInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    media?: MediaCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutToursInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    media?: MediaUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutToursInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutToursInput, BreweryUncheckedCreateWithoutToursInput>
  }

  export type TourUpsertWithoutBreweriesInput = {
    update: XOR<TourUpdateWithoutBreweriesInput, TourUncheckedUpdateWithoutBreweriesInput>
    create: XOR<TourCreateWithoutBreweriesInput, TourUncheckedCreateWithoutBreweriesInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutBreweriesInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutBreweriesInput, TourUncheckedUpdateWithoutBreweriesInput>
  }

  export type TourUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTourNestedInput
    city?: CityUpdateOneRequiredWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutBreweriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryUpsertWithoutToursInput = {
    update: XOR<BreweryUpdateWithoutToursInput, BreweryUncheckedUpdateWithoutToursInput>
    create: XOR<BreweryCreateWithoutToursInput, BreweryUncheckedCreateWithoutToursInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutToursInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutToursInput, BreweryUncheckedUpdateWithoutToursInput>
  }

  export type BreweryUpdateWithoutToursInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutToursInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type RecipientCreateWithoutNotificationInput = {
    id?: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutReceivedNotificationsInput
  }

  export type RecipientUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientCreateOrConnectWithoutNotificationInput = {
    where: RecipientWhereUniqueInput
    create: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput>
  }

  export type RecipientCreateManyNotificationInputEnvelope = {
    data: RecipientCreateManyNotificationInput | RecipientCreateManyNotificationInput[]
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type RecipientUpsertWithWhereUniqueWithoutNotificationInput = {
    where: RecipientWhereUniqueInput
    update: XOR<RecipientUpdateWithoutNotificationInput, RecipientUncheckedUpdateWithoutNotificationInput>
    create: XOR<RecipientCreateWithoutNotificationInput, RecipientUncheckedCreateWithoutNotificationInput>
  }

  export type RecipientUpdateWithWhereUniqueWithoutNotificationInput = {
    where: RecipientWhereUniqueInput
    data: XOR<RecipientUpdateWithoutNotificationInput, RecipientUncheckedUpdateWithoutNotificationInput>
  }

  export type RecipientUpdateManyWithWhereWithoutNotificationInput = {
    where: RecipientScalarWhereInput
    data: XOR<RecipientUpdateManyMutationInput, RecipientUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationCreateWithoutRecipientsInput = {
    id?: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientsInput = {
    id?: string
    title: string
    message: string
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
  }

  export type UserCreateWithoutReceivedNotificationsInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutReceivedNotificationsInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutReceivedNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
  }

  export type NotificationUpsertWithoutRecipientsInput = {
    update: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type NotificationUpdateWithoutRecipientsInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientsInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReceivedNotificationsInput = {
    update: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateWithoutReceivedNotificationsInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedNotificationsInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type AdRatesCreateWithoutAdTypeInput = {
    id?: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    state: StateCreateNestedOneWithoutAdRatesInput
    city: CityCreateNestedOneWithoutAdRatesInput
  }

  export type AdRatesUncheckedCreateWithoutAdTypeInput = {
    id?: string
    stateId: string
    cityId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesCreateOrConnectWithoutAdTypeInput = {
    where: AdRatesWhereUniqueInput
    create: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput>
  }

  export type AdRatesCreateManyAdTypeInputEnvelope = {
    data: AdRatesCreateManyAdTypeInput | AdRatesCreateManyAdTypeInput[]
  }

  export type AdCreateWithoutAdTypeInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdInput
    category: CategoryCreateNestedOneWithoutAdInput
    state?: StateCreateNestedOneWithoutAdInput
    city?: CityCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateWithoutAdTypeInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateOrConnectWithoutAdTypeInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput>
  }

  export type AdCreateManyAdTypeInputEnvelope = {
    data: AdCreateManyAdTypeInput | AdCreateManyAdTypeInput[]
  }

  export type AdRatesUpsertWithWhereUniqueWithoutAdTypeInput = {
    where: AdRatesWhereUniqueInput
    update: XOR<AdRatesUpdateWithoutAdTypeInput, AdRatesUncheckedUpdateWithoutAdTypeInput>
    create: XOR<AdRatesCreateWithoutAdTypeInput, AdRatesUncheckedCreateWithoutAdTypeInput>
  }

  export type AdRatesUpdateWithWhereUniqueWithoutAdTypeInput = {
    where: AdRatesWhereUniqueInput
    data: XOR<AdRatesUpdateWithoutAdTypeInput, AdRatesUncheckedUpdateWithoutAdTypeInput>
  }

  export type AdRatesUpdateManyWithWhereWithoutAdTypeInput = {
    where: AdRatesScalarWhereInput
    data: XOR<AdRatesUpdateManyMutationInput, AdRatesUncheckedUpdateManyWithoutAdTypeInput>
  }

  export type AdUpsertWithWhereUniqueWithoutAdTypeInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutAdTypeInput, AdUncheckedUpdateWithoutAdTypeInput>
    create: XOR<AdCreateWithoutAdTypeInput, AdUncheckedCreateWithoutAdTypeInput>
  }

  export type AdUpdateWithWhereUniqueWithoutAdTypeInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutAdTypeInput, AdUncheckedUpdateWithoutAdTypeInput>
  }

  export type AdUpdateManyWithWhereWithoutAdTypeInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutAdTypeInput>
  }

  export type StateCreateWithoutAdRatesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    Location?: LocationCreateNestedManyWithoutStateInput
    Ad?: AdCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutAdRatesInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    Location?: LocationUncheckedCreateNestedManyWithoutStateInput
    Ad?: AdUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutAdRatesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutAdRatesInput, StateUncheckedCreateWithoutAdRatesInput>
  }

  export type CityCreateWithoutAdRatesInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    Ad?: AdCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAdRatesInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    Ad?: AdUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAdRatesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdRatesInput, CityUncheckedCreateWithoutAdRatesInput>
  }

  export type AdTypeCreateWithoutAdRatesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    Ad?: AdCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeUncheckedCreateWithoutAdRatesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    Ad?: AdUncheckedCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeCreateOrConnectWithoutAdRatesInput = {
    where: AdTypeWhereUniqueInput
    create: XOR<AdTypeCreateWithoutAdRatesInput, AdTypeUncheckedCreateWithoutAdRatesInput>
  }

  export type StateUpsertWithoutAdRatesInput = {
    update: XOR<StateUpdateWithoutAdRatesInput, StateUncheckedUpdateWithoutAdRatesInput>
    create: XOR<StateCreateWithoutAdRatesInput, StateUncheckedCreateWithoutAdRatesInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutAdRatesInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutAdRatesInput, StateUncheckedUpdateWithoutAdRatesInput>
  }

  export type StateUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    Location?: LocationUpdateManyWithoutStateNestedInput
    Ad?: AdUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStateNestedInput
    Ad?: AdUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutAdRatesInput = {
    update: XOR<CityUpdateWithoutAdRatesInput, CityUncheckedUpdateWithoutAdRatesInput>
    create: XOR<CityCreateWithoutAdRatesInput, CityUncheckedCreateWithoutAdRatesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAdRatesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAdRatesInput, CityUncheckedUpdateWithoutAdRatesInput>
  }

  export type CityUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type AdTypeUpsertWithoutAdRatesInput = {
    update: XOR<AdTypeUpdateWithoutAdRatesInput, AdTypeUncheckedUpdateWithoutAdRatesInput>
    create: XOR<AdTypeCreateWithoutAdRatesInput, AdTypeUncheckedCreateWithoutAdRatesInput>
    where?: AdTypeWhereInput
  }

  export type AdTypeUpdateToOneWithWhereWithoutAdRatesInput = {
    where?: AdTypeWhereInput
    data: XOR<AdTypeUpdateWithoutAdRatesInput, AdTypeUncheckedUpdateWithoutAdRatesInput>
  }

  export type AdTypeUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ad?: AdUpdateManyWithoutAdTypeNestedInput
  }

  export type AdTypeUncheckedUpdateWithoutAdRatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ad?: AdUncheckedUpdateManyWithoutAdTypeNestedInput
  }

  export type AdCreateWithoutCategoryInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adType: AdTypeCreateNestedOneWithoutAdInput
    user?: UserCreateNestedOneWithoutAdInput
    state?: StateCreateNestedOneWithoutAdInput
    city?: CityCreateNestedOneWithoutAdInput
  }

  export type AdUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateOrConnectWithoutCategoryInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput>
  }

  export type AdCreateManyCategoryInputEnvelope = {
    data: AdCreateManyCategoryInput | AdCreateManyCategoryInput[]
  }

  export type AdUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutCategoryInput, AdUncheckedUpdateWithoutCategoryInput>
    create: XOR<AdCreateWithoutCategoryInput, AdUncheckedCreateWithoutCategoryInput>
  }

  export type AdUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutCategoryInput, AdUncheckedUpdateWithoutCategoryInput>
  }

  export type AdUpdateManyWithWhereWithoutCategoryInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AdTypeCreateWithoutAdInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    AdRates?: AdRatesCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeUncheckedCreateWithoutAdInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    limit: number
    desktop_width: number
    desktop_height: number
    mobile_width: number
    mobile_height: number
    desktop_file_size: number
    mobile_file_size: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutAdTypeInput
  }

  export type AdTypeCreateOrConnectWithoutAdInput = {
    where: AdTypeWhereUniqueInput
    create: XOR<AdTypeCreateWithoutAdInput, AdTypeUncheckedCreateWithoutAdInput>
  }

  export type UserCreateWithoutAdInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Media?: MediaCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutAdInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Media?: MediaUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutAdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdInput, UserUncheckedCreateWithoutAdInput>
  }

  export type CategoryCreateWithoutAdInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutAdInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutAdInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutAdInput, CategoryUncheckedCreateWithoutAdInput>
  }

  export type StateCreateWithoutAdInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    Location?: LocationCreateNestedManyWithoutStateInput
    AdRates?: AdRatesCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutAdInput = {
    id?: string
    name: string
    state_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    counties?: CountyUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    Location?: LocationUncheckedCreateNestedManyWithoutStateInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutAdInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutAdInput, StateUncheckedCreateWithoutAdInput>
  }

  export type CityCreateWithoutAdInput = {
    id?: string
    name: string
    city_ascii?: string | null
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    state: StateCreateNestedOneWithoutCitiesInput
    county: CountyCreateNestedOneWithoutCitiesInput
    User?: UserCreateNestedManyWithoutCityInput
    Location?: LocationCreateNestedManyWithoutCityInput
    Tour?: TourCreateNestedManyWithoutCityInput
    AdRates?: AdRatesCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAdInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
    User?: UserUncheckedCreateNestedManyWithoutCityInput
    Location?: LocationUncheckedCreateNestedManyWithoutCityInput
    Tour?: TourUncheckedCreateNestedManyWithoutCityInput
    AdRates?: AdRatesUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAdInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdInput, CityUncheckedCreateWithoutAdInput>
  }

  export type AdTypeUpsertWithoutAdInput = {
    update: XOR<AdTypeUpdateWithoutAdInput, AdTypeUncheckedUpdateWithoutAdInput>
    create: XOR<AdTypeCreateWithoutAdInput, AdTypeUncheckedCreateWithoutAdInput>
    where?: AdTypeWhereInput
  }

  export type AdTypeUpdateToOneWithWhereWithoutAdInput = {
    where?: AdTypeWhereInput
    data: XOR<AdTypeUpdateWithoutAdInput, AdTypeUncheckedUpdateWithoutAdInput>
  }

  export type AdTypeUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdRates?: AdRatesUpdateManyWithoutAdTypeNestedInput
  }

  export type AdTypeUncheckedUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    limit?: IntFieldUpdateOperationsInput | number
    desktop_width?: IntFieldUpdateOperationsInput | number
    desktop_height?: IntFieldUpdateOperationsInput | number
    mobile_width?: IntFieldUpdateOperationsInput | number
    mobile_height?: IntFieldUpdateOperationsInput | number
    desktop_file_size?: IntFieldUpdateOperationsInput | number
    mobile_file_size?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdRates?: AdRatesUncheckedUpdateManyWithoutAdTypeNestedInput
  }

  export type UserUpsertWithoutAdInput = {
    update: XOR<UserUpdateWithoutAdInput, UserUncheckedUpdateWithoutAdInput>
    create: XOR<UserCreateWithoutAdInput, UserUncheckedCreateWithoutAdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdInput, UserUncheckedUpdateWithoutAdInput>
  }

  export type UserUpdateWithoutAdInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAdInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type CategoryUpsertWithoutAdInput = {
    update: XOR<CategoryUpdateWithoutAdInput, CategoryUncheckedUpdateWithoutAdInput>
    create: XOR<CategoryCreateWithoutAdInput, CategoryUncheckedCreateWithoutAdInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutAdInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutAdInput, CategoryUncheckedUpdateWithoutAdInput>
  }

  export type CategoryUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUpsertWithoutAdInput = {
    update: XOR<StateUpdateWithoutAdInput, StateUncheckedUpdateWithoutAdInput>
    create: XOR<StateCreateWithoutAdInput, StateUncheckedCreateWithoutAdInput>
    where?: StateWhereInput
  }

  export type StateUpdateToOneWithWhereWithoutAdInput = {
    where?: StateWhereInput
    data: XOR<StateUpdateWithoutAdInput, StateUncheckedUpdateWithoutAdInput>
  }

  export type StateUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    Location?: LocationUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counties?: CountyUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStateNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutStateNestedInput
  }

  export type CityUpsertWithoutAdInput = {
    update: XOR<CityUpdateWithoutAdInput, CityUncheckedUpdateWithoutAdInput>
    create: XOR<CityCreateWithoutAdInput, CityUncheckedCreateWithoutAdInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAdInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAdInput, CityUncheckedUpdateWithoutAdInput>
  }

  export type CityUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAdInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
  }

  export type BreweryCreateWithoutMediaInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutBreweryInput
    owner?: UserCreateNestedOneWithoutOwnedBreweriesInput
    manager?: UserCreateNestedOneWithoutManagedBreweriesInput
    features?: BreweryFeatureCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryCreateNestedManyWithoutBreweryInput
  }

  export type BreweryUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: BreweryFeatureUncheckedCreateNestedManyWithoutBreweryInput
    beers?: BreweryBeerUncheckedCreateNestedManyWithoutBreweryInput
    foods?: BreweryFoodUncheckedCreateNestedManyWithoutBreweryInput
    services?: BreweryServiceUncheckedCreateNestedManyWithoutBreweryInput
    music?: BreweryMusicUncheckedCreateNestedManyWithoutBreweryInput
    OperatingHours?: OperatingHoursUncheckedCreateNestedManyWithoutBreweryInput
    BreweryEvent?: BreweryEventUncheckedCreateNestedManyWithoutBreweryInput
    tours?: TourBreweryUncheckedCreateNestedManyWithoutBreweryInput
  }

  export type BreweryCreateOrConnectWithoutMediaInput = {
    where: BreweryWhereUniqueInput
    create: XOR<BreweryCreateWithoutMediaInput, BreweryUncheckedCreateWithoutMediaInput>
  }

  export type UserCreateWithoutMediaInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
    ownedBreweries?: BreweryCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryCreateNestedManyWithoutManagerInput
    city: CityCreateNestedOneWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientCreateNestedManyWithoutRecipientInput
    Tour?: TourCreateNestedManyWithoutUserInput
    Ad?: AdCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMediaInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    cityId: string
    created_at?: Date | string
    ownedBreweries?: BreweryUncheckedCreateNestedManyWithoutOwnerInput
    managedBreweries?: BreweryUncheckedCreateNestedManyWithoutManagerInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: RecipientUncheckedCreateNestedManyWithoutRecipientInput
    Tour?: TourUncheckedCreateNestedManyWithoutUserInput
    Ad?: AdUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
  }

  export type BreweryUpsertWithoutMediaInput = {
    update: XOR<BreweryUpdateWithoutMediaInput, BreweryUncheckedUpdateWithoutMediaInput>
    create: XOR<BreweryCreateWithoutMediaInput, BreweryUncheckedCreateWithoutMediaInput>
    where?: BreweryWhereInput
  }

  export type BreweryUpdateToOneWithWhereWithoutMediaInput = {
    where?: BreweryWhereInput
    data: XOR<BreweryUpdateWithoutMediaInput, BreweryUncheckedUpdateWithoutMediaInput>
  }

  export type BreweryUpdateWithoutMediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutMediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type UserUpsertWithoutMediaInput = {
    update: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateWithoutMediaInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    city?: CityUpdateOneRequiredWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BreweryCreateManyOwnerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryCreateManyManagerInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    title: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientCreateManyRecipientInput = {
    id?: string
    notificationId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    cityId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyUserInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateManyApprovedByInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    breweryId: string
  }

  export type BreweryUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateManyWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutBreweryNestedInput
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateManyWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: RecipientUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: RecipientUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUpdateWithoutRecipientInput = {
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type RecipientUncheckedUpdateWithoutRecipientInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUncheckedUpdateManyWithoutRecipientInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: TourBreweryUpdateManyWithoutTourNestedInput
    city?: CityUpdateOneRequiredWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: TourBreweryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adType?: AdTypeUpdateOneRequiredWithoutAdNestedInput
    category?: CategoryUpdateOneRequiredWithoutAdNestedInput
    state?: StateUpdateOneWithoutAdNestedInput
    city?: CityUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutApprovedByInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutApprovedByInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyWithoutApprovedByInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryId?: StringFieldUpdateOperationsInput | string
  }

  export type CountyCreateManyStateInput = {
    id?: string
    name: string
    county_fips: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateManyStateInput = {
    id?: string
    name: string
    city_ascii?: string | null
    countyId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
  }

  export type LocationCreateManyStateInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    countyId?: string | null
  }

  export type AdRatesCreateManyStateInput = {
    id?: string
    cityId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyStateInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountyUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutCountyNestedInput
    Location?: LocationUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutCountyNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county_fips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    county?: CountyUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUpdateWithoutStateInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutLocationNestedInput
    Brewery?: BreweryUpdateManyWithoutLocationNestedInput
    County?: CountyUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStateInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    Brewery?: BreweryUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutStateInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdRatesUpdateWithoutStateInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAdRatesNestedInput
    adType?: AdTypeUpdateOneRequiredWithoutAdRatesNestedInput
  }

  export type AdRatesUncheckedUpdateWithoutStateInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesUncheckedUpdateManyWithoutStateInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adType?: AdTypeUpdateOneRequiredWithoutAdNestedInput
    user?: UserUpdateOneWithoutAdNestedInput
    category?: CategoryUpdateOneRequiredWithoutAdNestedInput
    city?: CityUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyCountyInput = {
    id?: string
    name: string
    city_ascii?: string | null
    stateId: string
    lat?: number | null
    lng?: number | null
    population?: number | null
    timezone?: string | null
    ranking?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueCityIdentifier: string
  }

  export type LocationCreateManyCountyInput = {
    id?: string
    address: string
    cityId: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
  }

  export type CityUpdateWithoutCountyInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    User?: UserUpdateManyWithoutCityNestedInput
    Location?: LocationUpdateManyWithoutCityNestedInput
    Tour?: TourUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUpdateManyWithoutCityNestedInput
    Ad?: AdUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountyInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutCityNestedInput
    Location?: LocationUncheckedUpdateManyWithoutCityNestedInput
    Tour?: TourUncheckedUpdateManyWithoutCityNestedInput
    AdRates?: AdRatesUncheckedUpdateManyWithoutCityNestedInput
    Ad?: AdUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountyInput = {
    name?: StringFieldUpdateOperationsInput | string
    city_ascii?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueCityIdentifier?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUpdateWithoutCountyInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutLocationNestedInput
    Brewery?: BreweryUpdateManyWithoutLocationNestedInput
    State?: StateUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCountyInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    Brewery?: BreweryUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutCountyInput = {
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyCityInput = {
    id?: string
    firstname?: string | null
    lastname?: string | null
    email: string
    current_password?: string | null
    birthdate?: string | null
    phone_number?: string | null
    role?: $Enums.Role
    state?: $Enums.Status
    photo?: string | null
    created_at?: Date | string
  }

  export type LocationCreateManyCityInput = {
    id?: string
    address: string
    latitude?: number | null
    longitude?: number | null
    zip?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stateId?: string | null
    countyId?: string | null
  }

  export type TourCreateManyCityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    userId: string
    radius: number
    startDate: Date | string
    breweryCount: number
    days: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesCreateManyCityInput = {
    id?: string
    stateId: string
    adTypeId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyCityInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCityInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUpdateManyWithoutRecipientNestedInput
    Tour?: TourUpdateManyWithoutUserNestedInput
    Ad?: AdUpdateManyWithoutUserNestedInput
    Media?: MediaUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBreweries?: BreweryUncheckedUpdateManyWithoutOwnerNestedInput
    managedBreweries?: BreweryUncheckedUpdateManyWithoutManagerNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: RecipientUncheckedUpdateManyWithoutRecipientNestedInput
    Tour?: TourUncheckedUpdateManyWithoutUserNestedInput
    Ad?: AdUncheckedUpdateManyWithoutUserNestedInput
    Media?: MediaUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    current_password?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    state?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutCityInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Brewery?: BreweryUpdateManyWithoutLocationNestedInput
    State?: StateUpdateOneWithoutLocationNestedInput
    County?: CountyUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCityInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    Brewery?: BreweryUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutCityInput = {
    address?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TourUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTourNestedInput
    breweries?: TourBreweryUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breweries?: TourBreweryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateManyWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    radius?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    breweryCount?: IntFieldUpdateOperationsInput | number
    days?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesUpdateWithoutCityInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutAdRatesNestedInput
    adType?: AdTypeUpdateOneRequiredWithoutAdRatesNestedInput
  }

  export type AdRatesUncheckedUpdateWithoutCityInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesUncheckedUpdateManyWithoutCityInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    adTypeId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adType?: AdTypeUpdateOneRequiredWithoutAdNestedInput
    user?: UserUpdateOneWithoutAdNestedInput
    category?: CategoryUpdateOneRequiredWithoutAdNestedInput
    state?: StateUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryCreateManyLocationInput = {
    id?: string
    name: string
    type?: string | null
    website?: string | null
    ownerId?: string | null
    managerId?: string | null
    comments?: string | null
    merchandise?: boolean | null
    social_media?: boolean | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedBreweriesNestedInput
    manager?: UserUpdateOneWithoutManagedBreweriesNestedInput
    features?: BreweryFeatureUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUpdateManyWithoutBreweryNestedInput
    media?: MediaUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: BreweryFeatureUncheckedUpdateManyWithoutBreweryNestedInput
    beers?: BreweryBeerUncheckedUpdateManyWithoutBreweryNestedInput
    foods?: BreweryFoodUncheckedUpdateManyWithoutBreweryNestedInput
    services?: BreweryServiceUncheckedUpdateManyWithoutBreweryNestedInput
    music?: BreweryMusicUncheckedUpdateManyWithoutBreweryNestedInput
    OperatingHours?: OperatingHoursUncheckedUpdateManyWithoutBreweryNestedInput
    BreweryEvent?: BreweryEventUncheckedUpdateManyWithoutBreweryNestedInput
    tours?: TourBreweryUncheckedUpdateManyWithoutBreweryNestedInput
    media?: MediaUncheckedUpdateManyWithoutBreweryNestedInput
  }

  export type BreweryUncheckedUpdateManyWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    merchandise?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureCreateManyBreweryInput = {
    id?: string
    logo?: string | null
    image?: string | null
    description?: string | null
    phone?: string | null
    facebook?: string | null
    x?: string | null
    instagram?: string | null
    highlighted?: boolean | null
    capacity?: string | null
    booklink?: string | null
    pricerank?: string | null
    state?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerCreateManyBreweryInput = {
    id?: string
    beerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodCreateManyBreweryInput = {
    id?: string
    foodId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceCreateManyBreweryInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicCreateManyBreweryInput = {
    id?: string
    musicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHoursCreateManyBreweryInput = {
    id?: string
    mondayOpen?: string | null
    mondayClose?: string | null
    tuesdayOpen?: string | null
    tuesdayClose?: string | null
    wednesdayOpen?: string | null
    wednesdayClose?: string | null
    thursdayOpen?: string | null
    thursdayClose?: string | null
    fridayOpen?: string | null
    fridayClose?: string | null
    saturdayOpen?: string | null
    saturdayClose?: string | null
    sundayOpen?: string | null
    sundayClose?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventCreateManyBreweryInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryCreateManyBreweryInput = {
    id?: string
    tourId: string
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateManyBreweryInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    thumbnail?: string | null
    status?: $Enums.MediaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedById?: string | null
  }

  export type BreweryFeatureUpdateWithoutBreweryInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureUncheckedUpdateWithoutBreweryInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFeatureUncheckedUpdateManyWithoutBreweryInput = {
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    highlighted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capacity?: NullableStringFieldUpdateOperationsInput | string | null
    booklink?: NullableStringFieldUpdateOperationsInput | string | null
    pricerank?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerUpdateWithoutBreweryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beer?: BeerUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryBeerUncheckedUpdateWithoutBreweryInput = {
    beerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerUncheckedUpdateManyWithoutBreweryInput = {
    beerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodUpdateWithoutBreweryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryFoodUncheckedUpdateWithoutBreweryInput = {
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodUncheckedUpdateManyWithoutBreweryInput = {
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceUpdateWithoutBreweryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryServiceUncheckedUpdateWithoutBreweryInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceUncheckedUpdateManyWithoutBreweryInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicUpdateWithoutBreweryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    music?: MusicUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryMusicUncheckedUpdateWithoutBreweryInput = {
    musicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicUncheckedUpdateManyWithoutBreweryInput = {
    musicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursUpdateWithoutBreweryInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursUncheckedUpdateWithoutBreweryInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHoursUncheckedUpdateManyWithoutBreweryInput = {
    mondayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    mondayClose?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    tuesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    wednesdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    thursdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    fridayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    fridayClose?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    saturdayClose?: NullableStringFieldUpdateOperationsInput | string | null
    sundayOpen?: NullableStringFieldUpdateOperationsInput | string | null
    sundayClose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventUpdateWithoutBreweryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type BreweryEventUncheckedUpdateWithoutBreweryInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventUncheckedUpdateManyWithoutBreweryInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryUpdateWithoutBreweryInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutBreweriesNestedInput
  }

  export type TourBreweryUncheckedUpdateWithoutBreweryInput = {
    tourId?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryUncheckedUpdateManyWithoutBreweryInput = {
    tourId?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutBreweryInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutBreweryInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUncheckedUpdateManyWithoutBreweryInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMediaStatusFieldUpdateOperationsInput | $Enums.MediaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreweryBeerCreateManyBeerInput = {
    id?: string
    breweryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryBeerUpdateWithoutBeerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneWithoutBeersNestedInput
  }

  export type BreweryBeerUncheckedUpdateWithoutBeerInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryBeerUncheckedUpdateManyWithoutBeerInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodCreateManyFoodInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryFoodUpdateWithoutFoodInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutFoodsNestedInput
  }

  export type BreweryFoodUncheckedUpdateWithoutFoodInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryFoodUncheckedUpdateManyWithoutFoodInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceCreateManyServiceInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryServiceUpdateWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutServicesNestedInput
  }

  export type BreweryServiceUncheckedUpdateWithoutServiceInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryServiceUncheckedUpdateManyWithoutServiceInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicCreateManyMusicInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryMusicUpdateWithoutMusicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutMusicNestedInput
  }

  export type BreweryMusicUncheckedUpdateWithoutMusicInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryMusicUncheckedUpdateManyWithoutMusicInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventCreateManyEventInput = {
    id?: string
    breweryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreweryEventUpdateWithoutEventInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneRequiredWithoutBreweryEventNestedInput
  }

  export type BreweryEventUncheckedUpdateWithoutEventInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreweryEventUncheckedUpdateManyWithoutEventInput = {
    breweryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryCreateManyTourInput = {
    id?: string
    breweryId?: string | null
    distance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourBreweryUpdateWithoutTourInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brewery?: BreweryUpdateOneWithoutToursNestedInput
  }

  export type TourBreweryUncheckedUpdateWithoutTourInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourBreweryUncheckedUpdateManyWithoutTourInput = {
    breweryId?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientCreateManyNotificationInput = {
    id?: string
    userId: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUpdateWithoutNotificationInput = {
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
  }

  export type RecipientUncheckedUpdateWithoutNotificationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUncheckedUpdateManyWithoutNotificationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesCreateManyAdTypeInput = {
    id?: string
    stateId: string
    cityId: string
    rate: number
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyAdTypeInput = {
    id?: string
    name: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    categoryId: string
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdRatesUpdateWithoutAdTypeInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StateUpdateOneRequiredWithoutAdRatesNestedInput
    city?: CityUpdateOneRequiredWithoutAdRatesNestedInput
  }

  export type AdRatesUncheckedUpdateWithoutAdTypeInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdRatesUncheckedUpdateManyWithoutAdTypeInput = {
    stateId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutAdTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdNestedInput
    category?: CategoryUpdateOneRequiredWithoutAdNestedInput
    state?: StateUpdateOneWithoutAdNestedInput
    city?: CityUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutAdTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyWithoutAdTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCreateManyCategoryInput = {
    id?: string
    name: string
    adTypesId: string
    linkUrl?: string | null
    buttonName?: string | null
    desktopFile?: string | null
    mobileFile?: string | null
    font?: string | null
    text1?: string | null
    text1Color?: string | null
    text2?: string | null
    text2Color?: string | null
    bgImage?: string | null
    payStatus?: string | null
    status?: $Enums.Status
    totalCost?: number | null
    userId?: string | null
    urlVideo: string
    desktopVideoFile: string
    desktopVideoPreview: string
    mobileVideoFile: string
    mobileVideoPreview: string
    stateId?: string | null
    cityId?: string | null
    selectedDays?: AdCreateselectedDaysInput | number[]
    selectedDates?: AdCreateselectedDatesInput | Date[] | string[]
    startDate: Date | string
    endDate: Date | string
    clicks?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adType?: AdTypeUpdateOneRequiredWithoutAdNestedInput
    user?: UserUpdateOneWithoutAdNestedInput
    state?: StateUpdateOneWithoutAdNestedInput
    city?: CityUpdateOneWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    adTypesId?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonName?: NullableStringFieldUpdateOperationsInput | string | null
    desktopFile?: NullableStringFieldUpdateOperationsInput | string | null
    mobileFile?: NullableStringFieldUpdateOperationsInput | string | null
    font?: NullableStringFieldUpdateOperationsInput | string | null
    text1?: NullableStringFieldUpdateOperationsInput | string | null
    text1Color?: NullableStringFieldUpdateOperationsInput | string | null
    text2?: NullableStringFieldUpdateOperationsInput | string | null
    text2Color?: NullableStringFieldUpdateOperationsInput | string | null
    bgImage?: NullableStringFieldUpdateOperationsInput | string | null
    payStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    urlVideo?: StringFieldUpdateOperationsInput | string
    desktopVideoFile?: StringFieldUpdateOperationsInput | string
    desktopVideoPreview?: StringFieldUpdateOperationsInput | string
    mobileVideoFile?: StringFieldUpdateOperationsInput | string
    mobileVideoPreview?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedDays?: AdUpdateselectedDaysInput | number[]
    selectedDates?: AdUpdateselectedDatesInput | Date[] | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateCountOutputTypeDefaultArgs instead
     */
    export type StateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountyCountOutputTypeDefaultArgs instead
     */
    export type CountyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryCountOutputTypeDefaultArgs instead
     */
    export type BreweryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeerCountOutputTypeDefaultArgs instead
     */
    export type BeerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodCountOutputTypeDefaultArgs instead
     */
    export type FoodCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusicCountOutputTypeDefaultArgs instead
     */
    export type MusicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourCountOutputTypeDefaultArgs instead
     */
    export type TourCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationCountOutputTypeDefaultArgs instead
     */
    export type NotificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdTypeCountOutputTypeDefaultArgs instead
     */
    export type AdTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateDefaultArgs instead
     */
    export type StateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountyDefaultArgs instead
     */
    export type CountyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryDefaultArgs instead
     */
    export type BreweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeerDefaultArgs instead
     */
    export type BeerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryBeerDefaultArgs instead
     */
    export type BreweryBeerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryBeerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodDefaultArgs instead
     */
    export type FoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryFoodDefaultArgs instead
     */
    export type BreweryFoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryFoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryServiceDefaultArgs instead
     */
    export type BreweryServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusicDefaultArgs instead
     */
    export type MusicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryMusicDefaultArgs instead
     */
    export type BreweryMusicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryMusicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryEventDefaultArgs instead
     */
    export type BreweryEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreweryFeatureDefaultArgs instead
     */
    export type BreweryFeatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreweryFeatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatingHoursDefaultArgs instead
     */
    export type OperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatingHoursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TutorialStepsAppDefaultArgs instead
     */
    export type TutorialStepsAppArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TutorialStepsAppDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagsDefaultArgs instead
     */
    export type TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourDefaultArgs instead
     */
    export type TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourBreweryDefaultArgs instead
     */
    export type TourBreweryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourBreweryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipientDefaultArgs instead
     */
    export type RecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdTypeDefaultArgs instead
     */
    export type AdTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdRatesDefaultArgs instead
     */
    export type AdRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdRatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdDefaultArgs instead
     */
    export type AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TermsDefaultArgs instead
     */
    export type TermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TermsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureDefaultArgs instead
     */
    export type FeatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}